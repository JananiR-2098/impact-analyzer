import {
  _typeof,
  init_typeof
} from "./chunk-KUSPHE5X.js";
import {
  Graph,
  NgxGraphModule,
  init_graph,
  init_swimlane_ngx_graph
} from "./chunk-ETWESAIJ.js";
import {
  HttpClient,
  init_http
} from "./chunk-2JYLQ5V4.js";
import {
  Sharedservice,
  init_sharedservice
} from "./chunk-DZTESG6R.js";
import {
  EVENT_MANAGER_PLUGINS,
  EventManagerPlugin,
  init_dom_renderer
} from "./chunk-CXVR4RNQ.js";
import {
  CommonModule,
  getDOM,
  init_common,
  isPlatformBrowser
} from "./chunk-YTZC332H.js";
import {
  ANIMATION_MODULE_TYPE,
  APP_ID,
  ApplicationRef,
  BehaviorSubject,
  CSP_NONCE,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ConnectableObservable,
  Console,
  ContentChild,
  ContentChildren,
  DOCUMENT,
  DestroyRef,
  Directive,
  ElementRef,
  EnvironmentInjector,
  ErrorHandler,
  EventEmitter,
  FactoryTarget,
  HostAttributeToken,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  NgModule,
  NgZone,
  Observable,
  Optional,
  Output,
  PLATFORM_ID,
  QueryList,
  Renderer2,
  RendererFactory2,
  RuntimeError,
  SecurityContext,
  SkipSelf,
  Subject,
  Subscription,
  TemplateRef,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation,
  XSS_SECURITY_URL,
  __decorate,
  _sanitizeHtml,
  _sanitizeUrl,
  afterNextRender,
  allowSanitizationBypassAndThrow,
  animationFrameScheduler,
  asapScheduler,
  auditTime,
  booleanAttribute,
  bypassSanitizationTrustHtml,
  bypassSanitizationTrustResourceUrl,
  bypassSanitizationTrustScript,
  bypassSanitizationTrustStyle,
  bypassSanitizationTrustUrl,
  catchError,
  combineLatest,
  concat,
  core_exports,
  createComponent,
  debounceTime,
  distinctUntilChanged,
  effect,
  filter,
  finalize,
  forkJoin,
  forwardRef,
  fromEvent,
  init_core,
  init_esm,
  init_operators,
  init_tslib_es6,
  inject,
  isObservable,
  map,
  mapTo,
  merge,
  numberAttribute,
  of,
  pairwise,
  share,
  shareReplay,
  signal,
  skip,
  startWith,
  switchMap,
  take,
  takeUntil,
  tap,
  throwError,
  untracked,
  unwrapSafeValue,
  ɵɵngDeclareClassMetadata,
  ɵɵngDeclareComponent,
  ɵɵngDeclareDirective,
  ɵɵngDeclareFactory,
  ɵɵngDeclareInjectable,
  ɵɵngDeclareInjector,
  ɵɵngDeclareNgModule
} from "./chunk-SUDYP63D.js";
import {
  require_html2canvas
} from "./chunk-2X73HGYV.js";
import {
  __async,
  __esm,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-GGUFBIL7.js";

// angular:jit:template:src\app\sidebar\sidebar.html
var sidebar_default;
var init_sidebar = __esm({
  "angular:jit:template:src\\app\\sidebar\\sidebar.html"() {
    sidebar_default = '<div class="analysis-container">\r\n\r\n  <div class="analysis-header">\r\n    <div class="analysis-title">Analysis</div>\r\n    <div class="analysis-actions">\r\n      <button mat-icon-button color="primary" style="font-size: 5px;" (click)="exportPDF()" aria-label="Download PDF">\r\n        <mat-icon>download</mat-icon> \r\n      </button>\r\n    </div>\r\n  </div>\r\n  \r\n  <div id="exportSection" class="analysis-body">\r\n    <div class="analysis-outputs">\r\n\r\n      <div class="output output-graph">\r\n        <div class="output-title">Impacted Files and Code Flow</div>\r\n          <div *ngIf="graphData && graphData.length > 1">\r\n            <button mat-raised-button *ngFor="let g of graphData; let i = index" (click)="selectedGraph = g">\r\n             Graph {{ i + 1 }}\r\n            </button>\r\n          </div>\r\n        <div class="output-graph graph-wrapper" *ngIf="selectedGraph">\r\n        <app-graph\r\n            [graph]="selectedGraph">\r\n          </app-graph>        </div>\r\n      </div>\r\n\r\n      <div class="output output-testplan">\r\n        <div class="output-title">Test Plan Overview</div>\r\n        <div class="output-content" [innerHTML]="testPlanHtml"></div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n\r\n  <div class="chat-footer">\r\n    <!-- reserved for actions (e.g., close, clear) -->\r\n  </div>\r\n\r\n</div>';
  }
});

// angular:jit:style:src\app\sidebar\sidebar.css
var sidebar_default2;
var init_sidebar2 = __esm({
  "angular:jit:style:src\\app\\sidebar\\sidebar.css"() {
    sidebar_default2 = '/* src/app/sidebar/sidebar.css */\n:host {\n  display: block;\n  padding: 0;\n}\n.analysis-container {\n  display: flex;\n  flex-direction: column;\n  position: fixed;\n  right: 10px;\n  top: 2vh;\n  width: 58vw;\n  height: 96vh;\n  border: 1px solid #e0e0e0;\n  border-radius: 8px;\n  background-color: #c6bcbc;\n  overflow: hidden;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n  font-family:\n    Inter,\n    system-ui,\n    -apple-system,\n    "Segoe UI",\n    Roboto,\n    Arial;\n}\n.analysis-header {\n  padding: 8px 10px;\n  background:\n    linear-gradient(\n      90deg,\n      #63b9d8,\n      #676f6c 40%);\n  border-bottom: 1px solid #e0e0e0;\n  color: #333;\n  font-size: 1.15em;\n  font-weight: 600;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n.analysis-title {\n  color: #333;\n}\n.analysis-actions {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n}\n.analysis-actions button {\n  color: #fff;\n}\n.analysis-body {\n  padding: 12px 16px;\n  overflow-y: auto;\n  overflow-y: hidden;\n  flex: 1;\n  background: #f6f1f1;\n  padding-right: 8px;\n}\n.analysis-outputs {\n  display: flex;\n  flex-direction: column;\n  gap: 20px;\n}\n.output {\n  background: #ffffff;\n  border-radius: 12px;\n  padding: 14px 16px;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);\n}\n.output-title {\n  font-size: 0.9rem;\n  font-weight: 600;\n  margin-bottom: 6px;\n}\n.output-graph .graph-wrapper {\n  border: none;\n  padding: 0;\n  background: transparent;\n  height: 350px;\n  max-height: 70vh;\n  overflow-y: auto;\n  scrollbar-width: thin;\n  display: flex;\n  flex-direction: column;\n}\n.graph-wrapper app-graph {\n  display: block;\n  width: 100%;\n  height: 100%;\n  min-height: 0;\n  max-height: none;\n  flex: 1 0 auto;\n}\n.output-testplan .output-content {\n  max-height: 200px;\n  overflow-y: auto;\n  display: block;\n  scrollbar-width: thin;\n}\n.output-content {\n  margin: 0;\n  font-size: 1em;\n  line-height: 1.6;\n  white-space: normal;\n  word-break: break-word;\n}\n.output-content ul,\n.output-content ol {\n  margin-left: 1.5em;\n  padding-left: 1em;\n}\n.output-content strong,\n.output-content b {\n  font-weight: bold;\n}\n.output-content h1,\n.output-content h2,\n.output-content h3 {\n  margin-top: 1em;\n  font-weight: bold;\n}\n.output-content hr {\n  border: none;\n  border-top: 1px solid #ccc;\n  margin: 1em 0;\n}\n.analysis-footer {\n  border-top: 1px solid rgba(0, 0, 0, 0.06);\n  padding: 8px 12px;\n  background: #fafafa;\n}\n/*# sourceMappingURL=sidebar.css.map */\n';
  }
});

// node_modules/marked/lib/marked.esm.js
function L() {
  return { async: false, breaks: false, extensions: null, gfm: true, hooks: null, pedantic: false, renderer: null, silent: false, tokenizer: null, walkTokens: null };
}
function G(l4) {
  T = l4;
}
function k(l4, e = "") {
  let t2 = typeof l4 == "string" ? l4 : l4.source, n = { replace: (r, i2) => {
    let s2 = typeof i2 == "string" ? i2 : i2.source;
    return s2 = s2.replace(m.caret, "$1"), t2 = t2.replace(r, s2), n;
  }, getRegex: () => new RegExp(t2, e) };
  return n;
}
function w(l4, e) {
  if (e) {
    if (m.escapeTest.test(l4)) return l4.replace(m.escapeReplace, de);
  } else if (m.escapeTestNoEncode.test(l4)) return l4.replace(m.escapeReplaceNoEncode, de);
  return l4;
}
function J(l4) {
  try {
    l4 = encodeURI(l4).replace(m.percentDecode, "%");
  } catch {
    return null;
  }
  return l4;
}
function V(l4, e) {
  let t2 = l4.replace(m.findPipe, (i2, s2, a2) => {
    let o2 = false, u2 = s2;
    for (; --u2 >= 0 && a2[u2] === "\\"; ) o2 = !o2;
    return o2 ? "|" : " |";
  }), n = t2.split(m.splitPipe), r = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; r < n.length; r++) n[r] = n[r].trim().replace(m.slashPipe, "|");
  return n;
}
function z(l4, e, t2) {
  let n = l4.length;
  if (n === 0) return "";
  let r = 0;
  for (; r < n; ) {
    let i2 = l4.charAt(n - r - 1);
    if (i2 === e && !t2) r++;
    else if (i2 !== e && t2) r++;
    else break;
  }
  return l4.slice(0, n - r);
}
function ge(l4, e) {
  if (l4.indexOf(e[1]) === -1) return -1;
  let t2 = 0;
  for (let n = 0; n < l4.length; n++) if (l4[n] === "\\") n++;
  else if (l4[n] === e[0]) t2++;
  else if (l4[n] === e[1] && (t2--, t2 < 0)) return n;
  return t2 > 0 ? -2 : -1;
}
function fe(l4, e, t2, n, r) {
  let i2 = e.href, s2 = e.title || null, a2 = l4[1].replace(r.other.outputLinkReplace, "$1");
  n.state.inLink = true;
  let o2 = { type: l4[0].charAt(0) === "!" ? "image" : "link", raw: t2, href: i2, title: s2, text: a2, tokens: n.inlineTokens(a2) };
  return n.state.inLink = false, o2;
}
function Ve(l4, e, t2) {
  let n = l4.match(t2.other.indentCodeCompensation);
  if (n === null) return e;
  let r = n[1];
  return e.split(`
`).map((i2) => {
    let s2 = i2.match(t2.other.beginningSpace);
    if (s2 === null) return i2;
    let [a2] = s2;
    return a2.length >= r.length ? i2.slice(r.length) : i2;
  }).join(`
`);
}
function d(l4, e) {
  return _.parse(l4, e);
}
var T, C, xe, m, be, Re, Te, E, Oe, F, se, ie, we, j, ye, Q, Pe, Se, v, U, $e, oe, _e, K, ne, Le, Me, ze, Ae, ae, Ce, D, W, le, Ee, ue, Ie, Be, qe, pe, ve, De, ce, He, Ze, Ge, Ne, Fe, je, Qe, q, Ue, he, ke, Ke, re, X, We, N, Xe, I, M, Je, de, y, x, P, $, b, S, B, _, Ht, Zt, Gt, Nt, Ft, Qt, Ut;
var init_marked_esm = __esm({
  "node_modules/marked/lib/marked.esm.js"() {
    "use strict";
    T = L();
    C = { exec: () => null };
    xe = (() => {
      try {
        return !!new RegExp("(?<=1)(?<!1)");
      } catch {
        return false;
      }
    })();
    m = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, listTaskCheckbox: /\[[ xX]\]/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (l4) => new RegExp(`^( {0,3}${l4})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (l4) => new RegExp(`^ {0,${Math.min(3, l4 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (l4) => new RegExp(`^ {0,${Math.min(3, l4 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (l4) => new RegExp(`^ {0,${Math.min(3, l4 - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (l4) => new RegExp(`^ {0,${Math.min(3, l4 - 1)}}#`), htmlBeginRegex: (l4) => new RegExp(`^ {0,${Math.min(3, l4 - 1)}}<(?:[a-z].*>|!--)`, "i") };
    be = /^(?:[ \t]*(?:\n|$))+/;
    Re = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
    Te = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
    E = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
    Oe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
    F = /(?:[*+-]|\d{1,9}[.)])/;
    se = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
    ie = k(se).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
    we = k(se).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
    j = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
    ye = /^[^\n]+/;
    Q = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/;
    Pe = k(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Q).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
    Se = k(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, F).getRegex();
    v = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    U = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
    $e = k("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", U).replace("tag", v).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    oe = k(j).replace("hr", E).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex();
    _e = k(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", oe).getRegex();
    K = { blockquote: _e, code: Re, def: Pe, fences: Te, heading: Oe, hr: E, html: $e, lheading: ie, list: Se, newline: be, paragraph: oe, table: C, text: ye };
    ne = k("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", E).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex();
    Le = __spreadProps(__spreadValues({}, K), { lheading: we, table: ne, paragraph: k(j).replace("hr", E).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", ne).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex() });
    Me = __spreadProps(__spreadValues({}, K), { html: k(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", U).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: C, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: k(j).replace("hr", E).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", ie).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() });
    ze = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
    Ae = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
    ae = /^( {2,}|\\)\n(?!\s*$)/;
    Ce = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
    D = /[\p{P}\p{S}]/u;
    W = /[\s\p{P}\p{S}]/u;
    le = /[^\s\p{P}\p{S}]/u;
    Ee = k(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, W).getRegex();
    ue = /(?!~)[\p{P}\p{S}]/u;
    Ie = /(?!~)[\s\p{P}\p{S}]/u;
    Be = /(?:[^\s\p{P}\p{S}]|~)/u;
    qe = k(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", xe ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex();
    pe = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
    ve = k(pe, "u").replace(/punct/g, D).getRegex();
    De = k(pe, "u").replace(/punct/g, ue).getRegex();
    ce = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
    He = k(ce, "gu").replace(/notPunctSpace/g, le).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex();
    Ze = k(ce, "gu").replace(/notPunctSpace/g, Be).replace(/punctSpace/g, Ie).replace(/punct/g, ue).getRegex();
    Ge = k("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, le).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex();
    Ne = k(/\\(punct)/, "gu").replace(/punct/g, D).getRegex();
    Fe = k(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
    je = k(U).replace("(?:-->|$)", "-->").getRegex();
    Qe = k("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", je).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
    q = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/;
    Ue = k(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", q).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
    he = k(/^!?\[(label)\]\[(ref)\]/).replace("label", q).replace("ref", Q).getRegex();
    ke = k(/^!?\[(ref)\](?:\[\])?/).replace("ref", Q).getRegex();
    Ke = k("reflink|nolink(?!\\()", "g").replace("reflink", he).replace("nolink", ke).getRegex();
    re = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/;
    X = { _backpedal: C, anyPunctuation: Ne, autolink: Fe, blockSkip: qe, br: ae, code: Ae, del: C, emStrongLDelim: ve, emStrongRDelimAst: He, emStrongRDelimUnd: Ge, escape: ze, link: Ue, nolink: ke, punctuation: Ee, reflink: he, reflinkSearch: Ke, tag: Qe, text: Ce, url: C };
    We = __spreadProps(__spreadValues({}, X), { link: k(/^!?\[(label)\]\((.*?)\)/).replace("label", q).getRegex(), reflink: k(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", q).getRegex() });
    N = __spreadProps(__spreadValues({}, X), { emStrongRDelimAst: Ze, emStrongLDelim: De, url: k(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", re).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: k(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", re).getRegex() });
    Xe = __spreadProps(__spreadValues({}, N), { br: k(ae).replace("{2,}", "*").getRegex(), text: k(N.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() });
    I = { normal: K, gfm: Le, pedantic: Me };
    M = { normal: X, gfm: N, breaks: Xe, pedantic: We };
    Je = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
    de = (l4) => Je[l4];
    y = class {
      options;
      rules;
      lexer;
      constructor(e) {
        this.options = e || T;
      }
      space(e) {
        let t2 = this.rules.block.newline.exec(e);
        if (t2 && t2[0].length > 0) return { type: "space", raw: t2[0] };
      }
      code(e) {
        let t2 = this.rules.block.code.exec(e);
        if (t2) {
          let n = t2[0].replace(this.rules.other.codeRemoveIndent, "");
          return { type: "code", raw: t2[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : z(n, `
`) };
        }
      }
      fences(e) {
        let t2 = this.rules.block.fences.exec(e);
        if (t2) {
          let n = t2[0], r = Ve(n, t2[3] || "", this.rules);
          return { type: "code", raw: n, lang: t2[2] ? t2[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t2[2], text: r };
        }
      }
      heading(e) {
        let t2 = this.rules.block.heading.exec(e);
        if (t2) {
          let n = t2[2].trim();
          if (this.rules.other.endingHash.test(n)) {
            let r = z(n, "#");
            (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (n = r.trim());
          }
          return { type: "heading", raw: t2[0], depth: t2[1].length, text: n, tokens: this.lexer.inline(n) };
        }
      }
      hr(e) {
        let t2 = this.rules.block.hr.exec(e);
        if (t2) return { type: "hr", raw: z(t2[0], `
`) };
      }
      blockquote(e) {
        let t2 = this.rules.block.blockquote.exec(e);
        if (t2) {
          let n = z(t2[0], `
`).split(`
`), r = "", i2 = "", s2 = [];
          for (; n.length > 0; ) {
            let a2 = false, o2 = [], u2;
            for (u2 = 0; u2 < n.length; u2++) if (this.rules.other.blockquoteStart.test(n[u2])) o2.push(n[u2]), a2 = true;
            else if (!a2) o2.push(n[u2]);
            else break;
            n = n.slice(u2);
            let p2 = o2.join(`
`), c2 = p2.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
            r = r ? `${r}
${p2}` : p2, i2 = i2 ? `${i2}
${c2}` : c2;
            let g2 = this.lexer.state.top;
            if (this.lexer.state.top = true, this.lexer.blockTokens(c2, s2, true), this.lexer.state.top = g2, n.length === 0) break;
            let h2 = s2.at(-1);
            if (h2?.type === "code") break;
            if (h2?.type === "blockquote") {
              let R3 = h2, f2 = R3.raw + `
` + n.join(`
`), O3 = this.blockquote(f2);
              s2[s2.length - 1] = O3, r = r.substring(0, r.length - R3.raw.length) + O3.raw, i2 = i2.substring(0, i2.length - R3.text.length) + O3.text;
              break;
            } else if (h2?.type === "list") {
              let R3 = h2, f2 = R3.raw + `
` + n.join(`
`), O3 = this.list(f2);
              s2[s2.length - 1] = O3, r = r.substring(0, r.length - h2.raw.length) + O3.raw, i2 = i2.substring(0, i2.length - R3.raw.length) + O3.raw, n = f2.substring(s2.at(-1).raw.length).split(`
`);
              continue;
            }
          }
          return { type: "blockquote", raw: r, tokens: s2, text: i2 };
        }
      }
      list(e) {
        let t2 = this.rules.block.list.exec(e);
        if (t2) {
          let n = t2[1].trim(), r = n.length > 1, i2 = { type: "list", raw: "", ordered: r, start: r ? +n.slice(0, -1) : "", loose: false, items: [] };
          n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r ? n : "[*+-]");
          let s2 = this.rules.other.listItemRegex(n), a2 = false;
          for (; e; ) {
            let u2 = false, p2 = "", c2 = "";
            if (!(t2 = s2.exec(e)) || this.rules.block.hr.test(e)) break;
            p2 = t2[0], e = e.substring(p2.length);
            let g2 = t2[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (H3) => " ".repeat(3 * H3.length)), h2 = e.split(`
`, 1)[0], R3 = !g2.trim(), f2 = 0;
            if (this.options.pedantic ? (f2 = 2, c2 = g2.trimStart()) : R3 ? f2 = t2[1].length + 1 : (f2 = t2[2].search(this.rules.other.nonSpaceChar), f2 = f2 > 4 ? 1 : f2, c2 = g2.slice(f2), f2 += t2[1].length), R3 && this.rules.other.blankLine.test(h2) && (p2 += h2 + `
`, e = e.substring(h2.length + 1), u2 = true), !u2) {
              let H3 = this.rules.other.nextBulletRegex(f2), Y3 = this.rules.other.hrRegex(f2), ee2 = this.rules.other.fencesBeginRegex(f2), te2 = this.rules.other.headingBeginRegex(f2), me2 = this.rules.other.htmlBeginRegex(f2);
              for (; e; ) {
                let Z3 = e.split(`
`, 1)[0], A3;
                if (h2 = Z3, this.options.pedantic ? (h2 = h2.replace(this.rules.other.listReplaceNesting, "  "), A3 = h2) : A3 = h2.replace(this.rules.other.tabCharGlobal, "    "), ee2.test(h2) || te2.test(h2) || me2.test(h2) || H3.test(h2) || Y3.test(h2)) break;
                if (A3.search(this.rules.other.nonSpaceChar) >= f2 || !h2.trim()) c2 += `
` + A3.slice(f2);
                else {
                  if (R3 || g2.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || ee2.test(g2) || te2.test(g2) || Y3.test(g2)) break;
                  c2 += `
` + h2;
                }
                !R3 && !h2.trim() && (R3 = true), p2 += Z3 + `
`, e = e.substring(Z3.length + 1), g2 = A3.slice(f2);
              }
            }
            i2.loose || (a2 ? i2.loose = true : this.rules.other.doubleBlankLine.test(p2) && (a2 = true));
            let O3 = null;
            this.options.gfm && (O3 = this.rules.other.listIsTask.exec(c2), O3 && (c2 = c2.replace(this.rules.other.listReplaceTask, ""))), i2.items.push({ type: "list_item", raw: p2, task: !!O3, loose: false, text: c2, tokens: [] }), i2.raw += p2;
          }
          let o2 = i2.items.at(-1);
          if (o2) o2.raw = o2.raw.trimEnd(), o2.text = o2.text.trimEnd();
          else return;
          i2.raw = i2.raw.trimEnd();
          for (let u2 of i2.items) {
            if (this.lexer.state.top = false, u2.tokens = this.lexer.blockTokens(u2.text, []), u2.task) {
              let p2 = this.rules.other.listTaskCheckbox.exec(u2.raw);
              if (p2) {
                let c2 = { type: "checkbox", raw: p2[0] + " ", checked: p2[0] !== "[ ]" };
                u2.checked = c2.checked, i2.loose ? u2.tokens[0] && ["paragraph", "text"].includes(u2.tokens[0].type) && "tokens" in u2.tokens[0] && u2.tokens[0].tokens ? (u2.tokens[0].raw = c2.raw + u2.tokens[0].raw, u2.tokens[0].text = c2.raw + u2.tokens[0].text, u2.tokens[0].tokens.unshift(c2)) : u2.tokens.unshift({ type: "paragraph", raw: c2.raw, text: c2.raw, tokens: [c2] }) : u2.tokens.unshift(c2);
              }
            }
            if (!i2.loose) {
              let p2 = u2.tokens.filter((g2) => g2.type === "space"), c2 = p2.length > 0 && p2.some((g2) => this.rules.other.anyLine.test(g2.raw));
              i2.loose = c2;
            }
          }
          if (i2.loose) for (let u2 of i2.items) {
            u2.loose = true;
            for (let p2 of u2.tokens) p2.type === "text" && (p2.type = "paragraph");
          }
          return i2;
        }
      }
      html(e) {
        let t2 = this.rules.block.html.exec(e);
        if (t2) return { type: "html", block: true, raw: t2[0], pre: t2[1] === "pre" || t2[1] === "script" || t2[1] === "style", text: t2[0] };
      }
      def(e) {
        let t2 = this.rules.block.def.exec(e);
        if (t2) {
          let n = t2[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = t2[2] ? t2[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i2 = t2[3] ? t2[3].substring(1, t2[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t2[3];
          return { type: "def", tag: n, raw: t2[0], href: r, title: i2 };
        }
      }
      table(e) {
        let t2 = this.rules.block.table.exec(e);
        if (!t2 || !this.rules.other.tableDelimiter.test(t2[2])) return;
        let n = V(t2[1]), r = t2[2].replace(this.rules.other.tableAlignChars, "").split("|"), i2 = t2[3]?.trim() ? t2[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s2 = { type: "table", raw: t2[0], header: [], align: [], rows: [] };
        if (n.length === r.length) {
          for (let a2 of r) this.rules.other.tableAlignRight.test(a2) ? s2.align.push("right") : this.rules.other.tableAlignCenter.test(a2) ? s2.align.push("center") : this.rules.other.tableAlignLeft.test(a2) ? s2.align.push("left") : s2.align.push(null);
          for (let a2 = 0; a2 < n.length; a2++) s2.header.push({ text: n[a2], tokens: this.lexer.inline(n[a2]), header: true, align: s2.align[a2] });
          for (let a2 of i2) s2.rows.push(V(a2, s2.header.length).map((o2, u2) => ({ text: o2, tokens: this.lexer.inline(o2), header: false, align: s2.align[u2] })));
          return s2;
        }
      }
      lheading(e) {
        let t2 = this.rules.block.lheading.exec(e);
        if (t2) return { type: "heading", raw: t2[0], depth: t2[2].charAt(0) === "=" ? 1 : 2, text: t2[1], tokens: this.lexer.inline(t2[1]) };
      }
      paragraph(e) {
        let t2 = this.rules.block.paragraph.exec(e);
        if (t2) {
          let n = t2[1].charAt(t2[1].length - 1) === `
` ? t2[1].slice(0, -1) : t2[1];
          return { type: "paragraph", raw: t2[0], text: n, tokens: this.lexer.inline(n) };
        }
      }
      text(e) {
        let t2 = this.rules.block.text.exec(e);
        if (t2) return { type: "text", raw: t2[0], text: t2[0], tokens: this.lexer.inline(t2[0]) };
      }
      escape(e) {
        let t2 = this.rules.inline.escape.exec(e);
        if (t2) return { type: "escape", raw: t2[0], text: t2[1] };
      }
      tag(e) {
        let t2 = this.rules.inline.tag.exec(e);
        if (t2) return !this.lexer.state.inLink && this.rules.other.startATag.test(t2[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(t2[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t2[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t2[0]) && (this.lexer.state.inRawBlock = false), { type: "html", raw: t2[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: false, text: t2[0] };
      }
      link(e) {
        let t2 = this.rules.inline.link.exec(e);
        if (t2) {
          let n = t2[2].trim();
          if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
            if (!this.rules.other.endAngleBracket.test(n)) return;
            let s2 = z(n.slice(0, -1), "\\");
            if ((n.length - s2.length) % 2 === 0) return;
          } else {
            let s2 = ge(t2[2], "()");
            if (s2 === -2) return;
            if (s2 > -1) {
              let o2 = (t2[0].indexOf("!") === 0 ? 5 : 4) + t2[1].length + s2;
              t2[2] = t2[2].substring(0, s2), t2[0] = t2[0].substring(0, o2).trim(), t2[3] = "";
            }
          }
          let r = t2[2], i2 = "";
          if (this.options.pedantic) {
            let s2 = this.rules.other.pedanticHrefTitle.exec(r);
            s2 && (r = s2[1], i2 = s2[3]);
          } else i2 = t2[3] ? t2[3].slice(1, -1) : "";
          return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? r = r.slice(1) : r = r.slice(1, -1)), fe(t2, { href: r && r.replace(this.rules.inline.anyPunctuation, "$1"), title: i2 && i2.replace(this.rules.inline.anyPunctuation, "$1") }, t2[0], this.lexer, this.rules);
        }
      }
      reflink(e, t2) {
        let n;
        if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
          let r = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i2 = t2[r.toLowerCase()];
          if (!i2) {
            let s2 = n[0].charAt(0);
            return { type: "text", raw: s2, text: s2 };
          }
          return fe(n, i2, n[0], this.lexer, this.rules);
        }
      }
      emStrong(e, t2, n = "") {
        let r = this.rules.inline.emStrongLDelim.exec(e);
        if (!r || r[3] && n.match(this.rules.other.unicodeAlphaNumeric)) return;
        if (!(r[1] || r[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
          let s2 = [...r[0]].length - 1, a2, o2, u2 = s2, p2 = 0, c2 = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
          for (c2.lastIndex = 0, t2 = t2.slice(-1 * e.length + s2); (r = c2.exec(t2)) != null; ) {
            if (a2 = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !a2) continue;
            if (o2 = [...a2].length, r[3] || r[4]) {
              u2 += o2;
              continue;
            } else if ((r[5] || r[6]) && s2 % 3 && !((s2 + o2) % 3)) {
              p2 += o2;
              continue;
            }
            if (u2 -= o2, u2 > 0) continue;
            o2 = Math.min(o2, o2 + u2 + p2);
            let g2 = [...r[0]][0].length, h2 = e.slice(0, s2 + r.index + g2 + o2);
            if (Math.min(s2, o2) % 2) {
              let f2 = h2.slice(1, -1);
              return { type: "em", raw: h2, text: f2, tokens: this.lexer.inlineTokens(f2) };
            }
            let R3 = h2.slice(2, -2);
            return { type: "strong", raw: h2, text: R3, tokens: this.lexer.inlineTokens(R3) };
          }
        }
      }
      codespan(e) {
        let t2 = this.rules.inline.code.exec(e);
        if (t2) {
          let n = t2[2].replace(this.rules.other.newLineCharGlobal, " "), r = this.rules.other.nonSpaceChar.test(n), i2 = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
          return r && i2 && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: t2[0], text: n };
        }
      }
      br(e) {
        let t2 = this.rules.inline.br.exec(e);
        if (t2) return { type: "br", raw: t2[0] };
      }
      del(e) {
        let t2 = this.rules.inline.del.exec(e);
        if (t2) return { type: "del", raw: t2[0], text: t2[2], tokens: this.lexer.inlineTokens(t2[2]) };
      }
      autolink(e) {
        let t2 = this.rules.inline.autolink.exec(e);
        if (t2) {
          let n, r;
          return t2[2] === "@" ? (n = t2[1], r = "mailto:" + n) : (n = t2[1], r = n), { type: "link", raw: t2[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
        }
      }
      url(e) {
        let t2;
        if (t2 = this.rules.inline.url.exec(e)) {
          let n, r;
          if (t2[2] === "@") n = t2[0], r = "mailto:" + n;
          else {
            let i2;
            do
              i2 = t2[0], t2[0] = this.rules.inline._backpedal.exec(t2[0])?.[0] ?? "";
            while (i2 !== t2[0]);
            n = t2[0], t2[1] === "www." ? r = "http://" + t2[0] : r = t2[0];
          }
          return { type: "link", raw: t2[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
        }
      }
      inlineText(e) {
        let t2 = this.rules.inline.text.exec(e);
        if (t2) {
          let n = this.lexer.state.inRawBlock;
          return { type: "text", raw: t2[0], text: t2[0], escaped: n };
        }
      }
    };
    x = class l {
      tokens;
      options;
      state;
      tokenizer;
      inlineQueue;
      constructor(e) {
        this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || T, this.options.tokenizer = this.options.tokenizer || new y(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
        let t2 = { other: m, block: I.normal, inline: M.normal };
        this.options.pedantic ? (t2.block = I.pedantic, t2.inline = M.pedantic) : this.options.gfm && (t2.block = I.gfm, this.options.breaks ? t2.inline = M.breaks : t2.inline = M.gfm), this.tokenizer.rules = t2;
      }
      static get rules() {
        return { block: I, inline: M };
      }
      static lex(e, t2) {
        return new l(t2).lex(e);
      }
      static lexInline(e, t2) {
        return new l(t2).inlineTokens(e);
      }
      lex(e) {
        e = e.replace(m.carriageReturn, `
`), this.blockTokens(e, this.tokens);
        for (let t2 = 0; t2 < this.inlineQueue.length; t2++) {
          let n = this.inlineQueue[t2];
          this.inlineTokens(n.src, n.tokens);
        }
        return this.inlineQueue = [], this.tokens;
      }
      blockTokens(e, t2 = [], n = false) {
        for (this.options.pedantic && (e = e.replace(m.tabCharGlobal, "    ").replace(m.spaceLine, "")); e; ) {
          let r;
          if (this.options.extensions?.block?.some((s2) => (r = s2.call({ lexer: this }, e, t2)) ? (e = e.substring(r.raw.length), t2.push(r), true) : false)) continue;
          if (r = this.tokenizer.space(e)) {
            e = e.substring(r.raw.length);
            let s2 = t2.at(-1);
            r.raw.length === 1 && s2 !== void 0 ? s2.raw += `
` : t2.push(r);
            continue;
          }
          if (r = this.tokenizer.code(e)) {
            e = e.substring(r.raw.length);
            let s2 = t2.at(-1);
            s2?.type === "paragraph" || s2?.type === "text" ? (s2.raw += (s2.raw.endsWith(`
`) ? "" : `
`) + r.raw, s2.text += `
` + r.text, this.inlineQueue.at(-1).src = s2.text) : t2.push(r);
            continue;
          }
          if (r = this.tokenizer.fences(e)) {
            e = e.substring(r.raw.length), t2.push(r);
            continue;
          }
          if (r = this.tokenizer.heading(e)) {
            e = e.substring(r.raw.length), t2.push(r);
            continue;
          }
          if (r = this.tokenizer.hr(e)) {
            e = e.substring(r.raw.length), t2.push(r);
            continue;
          }
          if (r = this.tokenizer.blockquote(e)) {
            e = e.substring(r.raw.length), t2.push(r);
            continue;
          }
          if (r = this.tokenizer.list(e)) {
            e = e.substring(r.raw.length), t2.push(r);
            continue;
          }
          if (r = this.tokenizer.html(e)) {
            e = e.substring(r.raw.length), t2.push(r);
            continue;
          }
          if (r = this.tokenizer.def(e)) {
            e = e.substring(r.raw.length);
            let s2 = t2.at(-1);
            s2?.type === "paragraph" || s2?.type === "text" ? (s2.raw += (s2.raw.endsWith(`
`) ? "" : `
`) + r.raw, s2.text += `
` + r.raw, this.inlineQueue.at(-1).src = s2.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = { href: r.href, title: r.title }, t2.push(r));
            continue;
          }
          if (r = this.tokenizer.table(e)) {
            e = e.substring(r.raw.length), t2.push(r);
            continue;
          }
          if (r = this.tokenizer.lheading(e)) {
            e = e.substring(r.raw.length), t2.push(r);
            continue;
          }
          let i2 = e;
          if (this.options.extensions?.startBlock) {
            let s2 = 1 / 0, a2 = e.slice(1), o2;
            this.options.extensions.startBlock.forEach((u2) => {
              o2 = u2.call({ lexer: this }, a2), typeof o2 == "number" && o2 >= 0 && (s2 = Math.min(s2, o2));
            }), s2 < 1 / 0 && s2 >= 0 && (i2 = e.substring(0, s2 + 1));
          }
          if (this.state.top && (r = this.tokenizer.paragraph(i2))) {
            let s2 = t2.at(-1);
            n && s2?.type === "paragraph" ? (s2.raw += (s2.raw.endsWith(`
`) ? "" : `
`) + r.raw, s2.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s2.text) : t2.push(r), n = i2.length !== e.length, e = e.substring(r.raw.length);
            continue;
          }
          if (r = this.tokenizer.text(e)) {
            e = e.substring(r.raw.length);
            let s2 = t2.at(-1);
            s2?.type === "text" ? (s2.raw += (s2.raw.endsWith(`
`) ? "" : `
`) + r.raw, s2.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s2.text) : t2.push(r);
            continue;
          }
          if (e) {
            let s2 = "Infinite loop on byte: " + e.charCodeAt(0);
            if (this.options.silent) {
              console.error(s2);
              break;
            } else throw new Error(s2);
          }
        }
        return this.state.top = true, t2;
      }
      inline(e, t2 = []) {
        return this.inlineQueue.push({ src: e, tokens: t2 }), t2;
      }
      inlineTokens(e, t2 = []) {
        let n = e, r = null;
        if (this.tokens.links) {
          let o2 = Object.keys(this.tokens.links);
          if (o2.length > 0) for (; (r = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) o2.includes(r[0].slice(r[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
        }
        for (; (r = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, r.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        let i2;
        for (; (r = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) i2 = r[2] ? r[2].length : 0, n = n.slice(0, r.index + i2) + "[" + "a".repeat(r[0].length - i2 - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        n = this.options.hooks?.emStrongMask?.call({ lexer: this }, n) ?? n;
        let s2 = false, a2 = "";
        for (; e; ) {
          s2 || (a2 = ""), s2 = false;
          let o2;
          if (this.options.extensions?.inline?.some((p2) => (o2 = p2.call({ lexer: this }, e, t2)) ? (e = e.substring(o2.raw.length), t2.push(o2), true) : false)) continue;
          if (o2 = this.tokenizer.escape(e)) {
            e = e.substring(o2.raw.length), t2.push(o2);
            continue;
          }
          if (o2 = this.tokenizer.tag(e)) {
            e = e.substring(o2.raw.length), t2.push(o2);
            continue;
          }
          if (o2 = this.tokenizer.link(e)) {
            e = e.substring(o2.raw.length), t2.push(o2);
            continue;
          }
          if (o2 = this.tokenizer.reflink(e, this.tokens.links)) {
            e = e.substring(o2.raw.length);
            let p2 = t2.at(-1);
            o2.type === "text" && p2?.type === "text" ? (p2.raw += o2.raw, p2.text += o2.text) : t2.push(o2);
            continue;
          }
          if (o2 = this.tokenizer.emStrong(e, n, a2)) {
            e = e.substring(o2.raw.length), t2.push(o2);
            continue;
          }
          if (o2 = this.tokenizer.codespan(e)) {
            e = e.substring(o2.raw.length), t2.push(o2);
            continue;
          }
          if (o2 = this.tokenizer.br(e)) {
            e = e.substring(o2.raw.length), t2.push(o2);
            continue;
          }
          if (o2 = this.tokenizer.del(e)) {
            e = e.substring(o2.raw.length), t2.push(o2);
            continue;
          }
          if (o2 = this.tokenizer.autolink(e)) {
            e = e.substring(o2.raw.length), t2.push(o2);
            continue;
          }
          if (!this.state.inLink && (o2 = this.tokenizer.url(e))) {
            e = e.substring(o2.raw.length), t2.push(o2);
            continue;
          }
          let u2 = e;
          if (this.options.extensions?.startInline) {
            let p2 = 1 / 0, c2 = e.slice(1), g2;
            this.options.extensions.startInline.forEach((h2) => {
              g2 = h2.call({ lexer: this }, c2), typeof g2 == "number" && g2 >= 0 && (p2 = Math.min(p2, g2));
            }), p2 < 1 / 0 && p2 >= 0 && (u2 = e.substring(0, p2 + 1));
          }
          if (o2 = this.tokenizer.inlineText(u2)) {
            e = e.substring(o2.raw.length), o2.raw.slice(-1) !== "_" && (a2 = o2.raw.slice(-1)), s2 = true;
            let p2 = t2.at(-1);
            p2?.type === "text" ? (p2.raw += o2.raw, p2.text += o2.text) : t2.push(o2);
            continue;
          }
          if (e) {
            let p2 = "Infinite loop on byte: " + e.charCodeAt(0);
            if (this.options.silent) {
              console.error(p2);
              break;
            } else throw new Error(p2);
          }
        }
        return t2;
      }
    };
    P = class {
      options;
      parser;
      constructor(e) {
        this.options = e || T;
      }
      space(e) {
        return "";
      }
      code({ text: e, lang: t2, escaped: n }) {
        let r = (t2 || "").match(m.notSpaceStart)?.[0], i2 = e.replace(m.endingNewline, "") + `
`;
        return r ? '<pre><code class="language-' + w(r) + '">' + (n ? i2 : w(i2, true)) + `</code></pre>
` : "<pre><code>" + (n ? i2 : w(i2, true)) + `</code></pre>
`;
      }
      blockquote({ tokens: e }) {
        return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
      }
      html({ text: e }) {
        return e;
      }
      def(e) {
        return "";
      }
      heading({ tokens: e, depth: t2 }) {
        return `<h${t2}>${this.parser.parseInline(e)}</h${t2}>
`;
      }
      hr(e) {
        return `<hr>
`;
      }
      list(e) {
        let t2 = e.ordered, n = e.start, r = "";
        for (let a2 = 0; a2 < e.items.length; a2++) {
          let o2 = e.items[a2];
          r += this.listitem(o2);
        }
        let i2 = t2 ? "ol" : "ul", s2 = t2 && n !== 1 ? ' start="' + n + '"' : "";
        return "<" + i2 + s2 + `>
` + r + "</" + i2 + `>
`;
      }
      listitem(e) {
        return `<li>${this.parser.parse(e.tokens)}</li>
`;
      }
      checkbox({ checked: e }) {
        return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox"> ';
      }
      paragraph({ tokens: e }) {
        return `<p>${this.parser.parseInline(e)}</p>
`;
      }
      table(e) {
        let t2 = "", n = "";
        for (let i2 = 0; i2 < e.header.length; i2++) n += this.tablecell(e.header[i2]);
        t2 += this.tablerow({ text: n });
        let r = "";
        for (let i2 = 0; i2 < e.rows.length; i2++) {
          let s2 = e.rows[i2];
          n = "";
          for (let a2 = 0; a2 < s2.length; a2++) n += this.tablecell(s2[a2]);
          r += this.tablerow({ text: n });
        }
        return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + t2 + `</thead>
` + r + `</table>
`;
      }
      tablerow({ text: e }) {
        return `<tr>
${e}</tr>
`;
      }
      tablecell(e) {
        let t2 = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
        return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + t2 + `</${n}>
`;
      }
      strong({ tokens: e }) {
        return `<strong>${this.parser.parseInline(e)}</strong>`;
      }
      em({ tokens: e }) {
        return `<em>${this.parser.parseInline(e)}</em>`;
      }
      codespan({ text: e }) {
        return `<code>${w(e, true)}</code>`;
      }
      br(e) {
        return "<br>";
      }
      del({ tokens: e }) {
        return `<del>${this.parser.parseInline(e)}</del>`;
      }
      link({ href: e, title: t2, tokens: n }) {
        let r = this.parser.parseInline(n), i2 = J(e);
        if (i2 === null) return r;
        e = i2;
        let s2 = '<a href="' + e + '"';
        return t2 && (s2 += ' title="' + w(t2) + '"'), s2 += ">" + r + "</a>", s2;
      }
      image({ href: e, title: t2, text: n, tokens: r }) {
        r && (n = this.parser.parseInline(r, this.parser.textRenderer));
        let i2 = J(e);
        if (i2 === null) return w(n);
        e = i2;
        let s2 = `<img src="${e}" alt="${n}"`;
        return t2 && (s2 += ` title="${w(t2)}"`), s2 += ">", s2;
      }
      text(e) {
        return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : w(e.text);
      }
    };
    $ = class {
      strong({ text: e }) {
        return e;
      }
      em({ text: e }) {
        return e;
      }
      codespan({ text: e }) {
        return e;
      }
      del({ text: e }) {
        return e;
      }
      html({ text: e }) {
        return e;
      }
      text({ text: e }) {
        return e;
      }
      link({ text: e }) {
        return "" + e;
      }
      image({ text: e }) {
        return "" + e;
      }
      br() {
        return "";
      }
      checkbox({ raw: e }) {
        return e;
      }
    };
    b = class l2 {
      options;
      renderer;
      textRenderer;
      constructor(e) {
        this.options = e || T, this.options.renderer = this.options.renderer || new P(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new $();
      }
      static parse(e, t2) {
        return new l2(t2).parse(e);
      }
      static parseInline(e, t2) {
        return new l2(t2).parseInline(e);
      }
      parse(e) {
        let t2 = "";
        for (let n = 0; n < e.length; n++) {
          let r = e[n];
          if (this.options.extensions?.renderers?.[r.type]) {
            let s2 = r, a2 = this.options.extensions.renderers[s2.type].call({ parser: this }, s2);
            if (a2 !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(s2.type)) {
              t2 += a2 || "";
              continue;
            }
          }
          let i2 = r;
          switch (i2.type) {
            case "space": {
              t2 += this.renderer.space(i2);
              break;
            }
            case "hr": {
              t2 += this.renderer.hr(i2);
              break;
            }
            case "heading": {
              t2 += this.renderer.heading(i2);
              break;
            }
            case "code": {
              t2 += this.renderer.code(i2);
              break;
            }
            case "table": {
              t2 += this.renderer.table(i2);
              break;
            }
            case "blockquote": {
              t2 += this.renderer.blockquote(i2);
              break;
            }
            case "list": {
              t2 += this.renderer.list(i2);
              break;
            }
            case "checkbox": {
              t2 += this.renderer.checkbox(i2);
              break;
            }
            case "html": {
              t2 += this.renderer.html(i2);
              break;
            }
            case "def": {
              t2 += this.renderer.def(i2);
              break;
            }
            case "paragraph": {
              t2 += this.renderer.paragraph(i2);
              break;
            }
            case "text": {
              t2 += this.renderer.text(i2);
              break;
            }
            default: {
              let s2 = 'Token with "' + i2.type + '" type was not found.';
              if (this.options.silent) return console.error(s2), "";
              throw new Error(s2);
            }
          }
        }
        return t2;
      }
      parseInline(e, t2 = this.renderer) {
        let n = "";
        for (let r = 0; r < e.length; r++) {
          let i2 = e[r];
          if (this.options.extensions?.renderers?.[i2.type]) {
            let a2 = this.options.extensions.renderers[i2.type].call({ parser: this }, i2);
            if (a2 !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i2.type)) {
              n += a2 || "";
              continue;
            }
          }
          let s2 = i2;
          switch (s2.type) {
            case "escape": {
              n += t2.text(s2);
              break;
            }
            case "html": {
              n += t2.html(s2);
              break;
            }
            case "link": {
              n += t2.link(s2);
              break;
            }
            case "image": {
              n += t2.image(s2);
              break;
            }
            case "checkbox": {
              n += t2.checkbox(s2);
              break;
            }
            case "strong": {
              n += t2.strong(s2);
              break;
            }
            case "em": {
              n += t2.em(s2);
              break;
            }
            case "codespan": {
              n += t2.codespan(s2);
              break;
            }
            case "br": {
              n += t2.br(s2);
              break;
            }
            case "del": {
              n += t2.del(s2);
              break;
            }
            case "text": {
              n += t2.text(s2);
              break;
            }
            default: {
              let a2 = 'Token with "' + s2.type + '" type was not found.';
              if (this.options.silent) return console.error(a2), "";
              throw new Error(a2);
            }
          }
        }
        return n;
      }
    };
    S = class {
      options;
      block;
      constructor(e) {
        this.options = e || T;
      }
      static passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
      static passThroughHooksRespectAsync = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"]);
      preprocess(e) {
        return e;
      }
      postprocess(e) {
        return e;
      }
      processAllTokens(e) {
        return e;
      }
      emStrongMask(e) {
        return e;
      }
      provideLexer() {
        return this.block ? x.lex : x.lexInline;
      }
      provideParser() {
        return this.block ? b.parse : b.parseInline;
      }
    };
    B = class {
      defaults = L();
      options = this.setOptions;
      parse = this.parseMarkdown(true);
      parseInline = this.parseMarkdown(false);
      Parser = b;
      Renderer = P;
      TextRenderer = $;
      Lexer = x;
      Tokenizer = y;
      Hooks = S;
      constructor(...e) {
        this.use(...e);
      }
      walkTokens(e, t2) {
        let n = [];
        for (let r of e) switch (n = n.concat(t2.call(this, r)), r.type) {
          case "table": {
            let i2 = r;
            for (let s2 of i2.header) n = n.concat(this.walkTokens(s2.tokens, t2));
            for (let s2 of i2.rows) for (let a2 of s2) n = n.concat(this.walkTokens(a2.tokens, t2));
            break;
          }
          case "list": {
            let i2 = r;
            n = n.concat(this.walkTokens(i2.items, t2));
            break;
          }
          default: {
            let i2 = r;
            this.defaults.extensions?.childTokens?.[i2.type] ? this.defaults.extensions.childTokens[i2.type].forEach((s2) => {
              let a2 = i2[s2].flat(1 / 0);
              n = n.concat(this.walkTokens(a2, t2));
            }) : i2.tokens && (n = n.concat(this.walkTokens(i2.tokens, t2)));
          }
        }
        return n;
      }
      use(...e) {
        let t2 = this.defaults.extensions || { renderers: {}, childTokens: {} };
        return e.forEach((n) => {
          let r = __spreadValues({}, n);
          if (r.async = this.defaults.async || r.async || false, n.extensions && (n.extensions.forEach((i2) => {
            if (!i2.name) throw new Error("extension name required");
            if ("renderer" in i2) {
              let s2 = t2.renderers[i2.name];
              s2 ? t2.renderers[i2.name] = function(...a2) {
                let o2 = i2.renderer.apply(this, a2);
                return o2 === false && (o2 = s2.apply(this, a2)), o2;
              } : t2.renderers[i2.name] = i2.renderer;
            }
            if ("tokenizer" in i2) {
              if (!i2.level || i2.level !== "block" && i2.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
              let s2 = t2[i2.level];
              s2 ? s2.unshift(i2.tokenizer) : t2[i2.level] = [i2.tokenizer], i2.start && (i2.level === "block" ? t2.startBlock ? t2.startBlock.push(i2.start) : t2.startBlock = [i2.start] : i2.level === "inline" && (t2.startInline ? t2.startInline.push(i2.start) : t2.startInline = [i2.start]));
            }
            "childTokens" in i2 && i2.childTokens && (t2.childTokens[i2.name] = i2.childTokens);
          }), r.extensions = t2), n.renderer) {
            let i2 = this.defaults.renderer || new P(this.defaults);
            for (let s2 in n.renderer) {
              if (!(s2 in i2)) throw new Error(`renderer '${s2}' does not exist`);
              if (["options", "parser"].includes(s2)) continue;
              let a2 = s2, o2 = n.renderer[a2], u2 = i2[a2];
              i2[a2] = (...p2) => {
                let c2 = o2.apply(i2, p2);
                return c2 === false && (c2 = u2.apply(i2, p2)), c2 || "";
              };
            }
            r.renderer = i2;
          }
          if (n.tokenizer) {
            let i2 = this.defaults.tokenizer || new y(this.defaults);
            for (let s2 in n.tokenizer) {
              if (!(s2 in i2)) throw new Error(`tokenizer '${s2}' does not exist`);
              if (["options", "rules", "lexer"].includes(s2)) continue;
              let a2 = s2, o2 = n.tokenizer[a2], u2 = i2[a2];
              i2[a2] = (...p2) => {
                let c2 = o2.apply(i2, p2);
                return c2 === false && (c2 = u2.apply(i2, p2)), c2;
              };
            }
            r.tokenizer = i2;
          }
          if (n.hooks) {
            let i2 = this.defaults.hooks || new S();
            for (let s2 in n.hooks) {
              if (!(s2 in i2)) throw new Error(`hook '${s2}' does not exist`);
              if (["options", "block"].includes(s2)) continue;
              let a2 = s2, o2 = n.hooks[a2], u2 = i2[a2];
              S.passThroughHooks.has(s2) ? i2[a2] = (p2) => {
                if (this.defaults.async && S.passThroughHooksRespectAsync.has(s2)) return (() => __async(this, null, function* () {
                  let g2 = yield o2.call(i2, p2);
                  return u2.call(i2, g2);
                }))();
                let c2 = o2.call(i2, p2);
                return u2.call(i2, c2);
              } : i2[a2] = (...p2) => {
                if (this.defaults.async) return (() => __async(this, null, function* () {
                  let g2 = yield o2.apply(i2, p2);
                  return g2 === false && (g2 = yield u2.apply(i2, p2)), g2;
                }))();
                let c2 = o2.apply(i2, p2);
                return c2 === false && (c2 = u2.apply(i2, p2)), c2;
              };
            }
            r.hooks = i2;
          }
          if (n.walkTokens) {
            let i2 = this.defaults.walkTokens, s2 = n.walkTokens;
            r.walkTokens = function(a2) {
              let o2 = [];
              return o2.push(s2.call(this, a2)), i2 && (o2 = o2.concat(i2.call(this, a2))), o2;
            };
          }
          this.defaults = __spreadValues(__spreadValues({}, this.defaults), r);
        }), this;
      }
      setOptions(e) {
        return this.defaults = __spreadValues(__spreadValues({}, this.defaults), e), this;
      }
      lexer(e, t2) {
        return x.lex(e, t2 ?? this.defaults);
      }
      parser(e, t2) {
        return b.parse(e, t2 ?? this.defaults);
      }
      parseMarkdown(e) {
        return (n, r) => {
          let i2 = __spreadValues({}, r), s2 = __spreadValues(__spreadValues({}, this.defaults), i2), a2 = this.onError(!!s2.silent, !!s2.async);
          if (this.defaults.async === true && i2.async === false) return a2(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
          if (typeof n > "u" || n === null) return a2(new Error("marked(): input parameter is undefined or null"));
          if (typeof n != "string") return a2(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
          if (s2.hooks && (s2.hooks.options = s2, s2.hooks.block = e), s2.async) return (() => __async(this, null, function* () {
            let o2 = s2.hooks ? yield s2.hooks.preprocess(n) : n, p2 = yield (s2.hooks ? yield s2.hooks.provideLexer() : e ? x.lex : x.lexInline)(o2, s2), c2 = s2.hooks ? yield s2.hooks.processAllTokens(p2) : p2;
            s2.walkTokens && (yield Promise.all(this.walkTokens(c2, s2.walkTokens)));
            let h2 = yield (s2.hooks ? yield s2.hooks.provideParser() : e ? b.parse : b.parseInline)(c2, s2);
            return s2.hooks ? yield s2.hooks.postprocess(h2) : h2;
          }))().catch(a2);
          try {
            s2.hooks && (n = s2.hooks.preprocess(n));
            let u2 = (s2.hooks ? s2.hooks.provideLexer() : e ? x.lex : x.lexInline)(n, s2);
            s2.hooks && (u2 = s2.hooks.processAllTokens(u2)), s2.walkTokens && this.walkTokens(u2, s2.walkTokens);
            let c2 = (s2.hooks ? s2.hooks.provideParser() : e ? b.parse : b.parseInline)(u2, s2);
            return s2.hooks && (c2 = s2.hooks.postprocess(c2)), c2;
          } catch (o2) {
            return a2(o2);
          }
        };
      }
      onError(e, t2) {
        return (n) => {
          if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
            let r = "<p>An error occurred:</p><pre>" + w(n.message + "", true) + "</pre>";
            return t2 ? Promise.resolve(r) : r;
          }
          if (t2) return Promise.reject(n);
          throw n;
        };
      }
    };
    _ = new B();
    d.options = d.setOptions = function(l4) {
      return _.setOptions(l4), d.defaults = _.defaults, G(d.defaults), d;
    };
    d.getDefaults = L;
    d.defaults = T;
    d.use = function(...l4) {
      return _.use(...l4), d.defaults = _.defaults, G(d.defaults), d;
    };
    d.walkTokens = function(l4, e) {
      return _.walkTokens(l4, e);
    };
    d.parseInline = _.parseInline;
    d.Parser = b;
    d.parser = b.parse;
    d.Renderer = P;
    d.TextRenderer = $;
    d.Lexer = x;
    d.lexer = x.lex;
    d.Tokenizer = y;
    d.Hooks = S;
    d.parse = d;
    Ht = d.options;
    Zt = d.setOptions;
    Gt = d.use;
    Nt = d.walkTokens;
    Ft = d.parseInline;
    Qt = b.parse;
    Ut = x.lex;
  }
});

// node_modules/@angular/cdk/fesm2022/fake-event-detection.mjs
function isFakeMousedownFromScreenReader(event) {
  return event.buttons === 0 || event.detail === 0;
}
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}
var init_fake_event_detection = __esm({
  "node_modules/@angular/cdk/fesm2022/fake-event-detection.mjs"() {
    "use strict";
  }
});

// node_modules/@angular/cdk/fesm2022/keycodes2.mjs
var SHIFT, CONTROL, ALT, ESCAPE, META, MAC_META;
var init_keycodes2 = __esm({
  "node_modules/@angular/cdk/fesm2022/keycodes2.mjs"() {
    "use strict";
    SHIFT = 16;
    CONTROL = 17;
    ALT = 18;
    ESCAPE = 27;
    META = 91;
    MAC_META = 224;
  }
});

// node_modules/@angular/cdk/fesm2022/shadow-dom.mjs
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
function _getFocusedElementPierceShadowDom() {
  let activeElement = typeof document !== "undefined" && document ? document.activeElement : null;
  while (activeElement && activeElement.shadowRoot) {
    const newActiveElement = activeElement.shadowRoot.activeElement;
    if (newActiveElement === activeElement) {
      break;
    } else {
      activeElement = newActiveElement;
    }
  }
  return activeElement;
}
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}
var shadowDomIsSupported;
var init_shadow_dom = __esm({
  "node_modules/@angular/cdk/fesm2022/shadow-dom.mjs"() {
    "use strict";
  }
});

// node_modules/@angular/cdk/fesm2022/platform2.mjs
var hasV8BreakIterator, Platform;
var init_platform2 = __esm({
  "node_modules/@angular/cdk/fesm2022/platform2.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_common();
    try {
      hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
    } catch {
      hasV8BreakIterator = false;
    }
    Platform = class _Platform {
      _platformId = inject(PLATFORM_ID);
      // We want to use the Angular platform check because if the Document is shimmed
      // without the navigator, the following checks will fail. This is preferred because
      // sometimes the Document may be shimmed without the user's knowledge or intention
      /** Whether the Angular application is being rendered in the browser. */
      isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : typeof document === "object" && !!document;
      /** Whether the current browser is Microsoft Edge. */
      EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
      /** Whether the current rendering engine is Microsoft Trident. */
      TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
      // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.
      /** Whether the current rendering engine is Blink. */
      BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !this.EDGE && !this.TRIDENT;
      // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
      // ensure that Webkit runs standalone and is not used as another engine's base.
      /** Whether the current rendering engine is WebKit. */
      WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
      /** Whether the current platform is Apple iOS. */
      IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
      // It's difficult to detect the plain Gecko engine, because most of the browsers identify
      // them self as Gecko-like browsers and modify the userAgent's according to that.
      // Since we only cover one explicit Firefox case, we can simply check for Firefox
      // instead of having an unstable check for Gecko.
      /** Whether the current browser is Firefox. */
      FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
      /** Whether the current platform is Android. */
      // Trident on mobile adds the android platform to the userAgent to trick detections.
      ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
      // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
      // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
      // Safari browser should also use Webkit as its layout engine.
      /** Whether the current browser is Safari. */
      SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
      constructor() {
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _Platform, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _Platform, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: Platform, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
  }
});

// node_modules/@angular/cdk/fesm2022/passive-listeners.mjs
function supportsPassiveEventListeners() {
  if (supportsPassiveEvents == null && typeof window !== "undefined") {
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get: () => supportsPassiveEvents = true
      }));
    } finally {
      supportsPassiveEvents = supportsPassiveEvents || false;
    }
  }
  return supportsPassiveEvents;
}
function normalizePassiveListenerOptions(options) {
  return supportsPassiveEventListeners() ? options : !!options.capture;
}
var supportsPassiveEvents;
var init_passive_listeners = __esm({
  "node_modules/@angular/cdk/fesm2022/passive-listeners.mjs"() {
    "use strict";
  }
});

// node_modules/@angular/cdk/fesm2022/element.mjs
function coerceNumberProperty(value, fallbackValue = 0) {
  if (_isNumberValue(value)) {
    return Number(value);
  }
  return arguments.length === 2 ? fallbackValue : 0;
}
function _isNumberValue(value) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value));
}
function coerceElement(elementOrRef) {
  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;
}
var init_element = __esm({
  "node_modules/@angular/cdk/fesm2022/element.mjs"() {
    "use strict";
    init_core();
  }
});

// node_modules/@angular/cdk/fesm2022/focus-monitor.mjs
var INPUT_MODALITY_DETECTOR_OPTIONS, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS, TOUCH_BUFFER_MS, modalityEventListenerOptions, InputModalityDetector, FocusMonitorDetectionMode, FOCUS_MONITOR_DEFAULT_OPTIONS, captureEventListenerOptions, FocusMonitor, CdkMonitorFocus;
var init_focus_monitor = __esm({
  "node_modules/@angular/cdk/fesm2022/focus-monitor.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_esm();
    init_operators();
    init_fake_event_detection();
    init_keycodes2();
    init_shadow_dom();
    init_platform2();
    init_passive_listeners();
    init_element();
    INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken("cdk-input-modality-detector-options");
    INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {
      ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT]
    };
    TOUCH_BUFFER_MS = 650;
    modalityEventListenerOptions = {
      passive: true,
      capture: true
    };
    InputModalityDetector = class _InputModalityDetector {
      _platform = inject(Platform);
      _listenerCleanups;
      /** Emits whenever an input modality is detected. */
      modalityDetected;
      /** Emits when the input modality changes. */
      modalityChanged;
      /** The most recently detected input modality. */
      get mostRecentModality() {
        return this._modality.value;
      }
      /**
       * The most recently detected input modality event target. Is null if no input modality has been
       * detected or if the associated event target is null for some unknown reason.
       */
      _mostRecentTarget = null;
      /** The underlying BehaviorSubject that emits whenever an input modality is detected. */
      _modality = new BehaviorSubject(null);
      /** Options for this InputModalityDetector. */
      _options;
      /**
       * The timestamp of the last touch input modality. Used to determine whether mousedown events
       * should be attributed to mouse or touch.
       */
      _lastTouchMs = 0;
      /**
       * Handles keydown events. Must be an arrow function in order to preserve the context when it gets
       * bound.
       */
      _onKeydown = (event) => {
        if (this._options?.ignoreKeys?.some((keyCode) => keyCode === event.keyCode)) {
          return;
        }
        this._modality.next("keyboard");
        this._mostRecentTarget = _getEventTarget(event);
      };
      /**
       * Handles mousedown events. Must be an arrow function in order to preserve the context when it
       * gets bound.
       */
      _onMousedown = (event) => {
        if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {
          return;
        }
        this._modality.next(isFakeMousedownFromScreenReader(event) ? "keyboard" : "mouse");
        this._mostRecentTarget = _getEventTarget(event);
      };
      /**
       * Handles touchstart events. Must be an arrow function in order to preserve the context when it
       * gets bound.
       */
      _onTouchstart = (event) => {
        if (isFakeTouchstartFromScreenReader(event)) {
          this._modality.next("keyboard");
          return;
        }
        this._lastTouchMs = Date.now();
        this._modality.next("touch");
        this._mostRecentTarget = _getEventTarget(event);
      };
      constructor() {
        const ngZone = inject(NgZone);
        const document2 = inject(DOCUMENT);
        const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, { optional: true });
        this._options = __spreadValues(__spreadValues({}, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS), options);
        this.modalityDetected = this._modality.pipe(skip(1));
        this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());
        if (this._platform.isBrowser) {
          const renderer = inject(RendererFactory2).createRenderer(null, null);
          this._listenerCleanups = ngZone.runOutsideAngular(() => {
            return [
              renderer.listen(document2, "keydown", this._onKeydown, modalityEventListenerOptions),
              renderer.listen(document2, "mousedown", this._onMousedown, modalityEventListenerOptions),
              renderer.listen(document2, "touchstart", this._onTouchstart, modalityEventListenerOptions)
            ];
          });
        }
      }
      ngOnDestroy() {
        this._modality.complete();
        this._listenerCleanups?.forEach((cleanup) => cleanup());
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _InputModalityDetector, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _InputModalityDetector, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: InputModalityDetector, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
    (function(FocusMonitorDetectionMode2) {
      FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["IMMEDIATE"] = 0] = "IMMEDIATE";
      FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["EVENTUAL"] = 1] = "EVENTUAL";
    })(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));
    FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken("cdk-focus-monitor-default-options");
    captureEventListenerOptions = normalizePassiveListenerOptions({
      passive: true,
      capture: true
    });
    FocusMonitor = class _FocusMonitor {
      _ngZone = inject(NgZone);
      _platform = inject(Platform);
      _inputModalityDetector = inject(InputModalityDetector);
      /** The focus origin that the next focus event is a result of. */
      _origin = null;
      /** The FocusOrigin of the last focus event tracked by the FocusMonitor. */
      _lastFocusOrigin;
      /** Whether the window has just been focused. */
      _windowFocused = false;
      /** The timeout id of the window focus timeout. */
      _windowFocusTimeoutId;
      /** The timeout id of the origin clearing timeout. */
      _originTimeoutId;
      /**
       * Whether the origin was determined via a touch interaction. Necessary as properly attributing
       * focus events to touch interactions requires special logic.
       */
      _originFromTouchInteraction = false;
      /** Map of elements being monitored to their info. */
      _elementInfo = /* @__PURE__ */ new Map();
      /** The number of elements currently being monitored. */
      _monitoredElementCount = 0;
      /**
       * Keeps track of the root nodes to which we've currently bound a focus/blur handler,
       * as well as the number of monitored elements that they contain. We have to treat focus/blur
       * handlers differently from the rest of the events, because the browser won't emit events
       * to the document when focus moves inside of a shadow root.
       */
      _rootNodeFocusListenerCount = /* @__PURE__ */ new Map();
      /**
       * The specified detection mode, used for attributing the origin of a focus
       * event.
       */
      _detectionMode;
      /**
       * Event listener for `focus` events on the window.
       * Needs to be an arrow function in order to preserve the context when it gets bound.
       */
      _windowFocusListener = () => {
        this._windowFocused = true;
        this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);
      };
      /** Used to reference correct document/window */
      _document = inject(DOCUMENT);
      /** Subject for stopping our InputModalityDetector subscription. */
      _stopInputModalityDetector = new Subject();
      constructor() {
        const options = inject(FOCUS_MONITOR_DEFAULT_OPTIONS, {
          optional: true
        });
        this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;
      }
      /**
       * Event listener for `focus` and 'blur' events on the document.
       * Needs to be an arrow function in order to preserve the context when it gets bound.
       */
      _rootNodeFocusAndBlurListener = (event) => {
        const target = _getEventTarget(event);
        for (let element = target; element; element = element.parentElement) {
          if (event.type === "focus") {
            this._onFocus(event, element);
          } else {
            this._onBlur(event, element);
          }
        }
      };
      monitor(element, checkChildren = false) {
        const nativeElement = coerceElement(element);
        if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {
          return of();
        }
        const rootNode = _getShadowRoot(nativeElement) || this._document;
        const cachedInfo = this._elementInfo.get(nativeElement);
        if (cachedInfo) {
          if (checkChildren) {
            cachedInfo.checkChildren = true;
          }
          return cachedInfo.subject;
        }
        const info = {
          checkChildren,
          subject: new Subject(),
          rootNode
        };
        this._elementInfo.set(nativeElement, info);
        this._registerGlobalListeners(info);
        return info.subject;
      }
      stopMonitoring(element) {
        const nativeElement = coerceElement(element);
        const elementInfo = this._elementInfo.get(nativeElement);
        if (elementInfo) {
          elementInfo.subject.complete();
          this._setClasses(nativeElement);
          this._elementInfo.delete(nativeElement);
          this._removeGlobalListeners(elementInfo);
        }
      }
      focusVia(element, origin, options) {
        const nativeElement = coerceElement(element);
        const focusedElement = this._document.activeElement;
        if (nativeElement === focusedElement) {
          this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));
        } else {
          this._setOrigin(origin);
          if (typeof nativeElement.focus === "function") {
            nativeElement.focus(options);
          }
        }
      }
      ngOnDestroy() {
        this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));
      }
      /** Use defaultView of injected document if available or fallback to global window reference */
      _getWindow() {
        return this._document.defaultView || window;
      }
      _getFocusOrigin(focusEventTarget) {
        if (this._origin) {
          if (this._originFromTouchInteraction) {
            return this._shouldBeAttributedToTouch(focusEventTarget) ? "touch" : "program";
          } else {
            return this._origin;
          }
        }
        if (this._windowFocused && this._lastFocusOrigin) {
          return this._lastFocusOrigin;
        }
        if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {
          return "mouse";
        }
        return "program";
      }
      /**
       * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a
       * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we
       * handle a focus event following a touch interaction, we need to determine whether (1) the focus
       * event was directly caused by the touch interaction or (2) the focus event was caused by a
       * subsequent programmatic focus call triggered by the touch interaction.
       * @param focusEventTarget The target of the focus event under examination.
       */
      _shouldBeAttributedToTouch(focusEventTarget) {
        return this._detectionMode === FocusMonitorDetectionMode.EVENTUAL || !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget);
      }
      /**
       * Sets the focus classes on the element based on the given focus origin.
       * @param element The element to update the classes on.
       * @param origin The focus origin.
       */
      _setClasses(element, origin) {
        element.classList.toggle("cdk-focused", !!origin);
        element.classList.toggle("cdk-touch-focused", origin === "touch");
        element.classList.toggle("cdk-keyboard-focused", origin === "keyboard");
        element.classList.toggle("cdk-mouse-focused", origin === "mouse");
        element.classList.toggle("cdk-program-focused", origin === "program");
      }
      /**
       * Updates the focus origin. If we're using immediate detection mode, we schedule an async
       * function to clear the origin at the end of a timeout. The duration of the timeout depends on
       * the origin being set.
       * @param origin The origin to set.
       * @param isFromInteraction Whether we are setting the origin from an interaction event.
       */
      _setOrigin(origin, isFromInteraction = false) {
        this._ngZone.runOutsideAngular(() => {
          this._origin = origin;
          this._originFromTouchInteraction = origin === "touch" && isFromInteraction;
          if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {
            clearTimeout(this._originTimeoutId);
            const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;
            this._originTimeoutId = setTimeout(() => this._origin = null, ms);
          }
        });
      }
      /**
       * Handles focus events on a registered element.
       * @param event The focus event.
       * @param element The monitored element.
       */
      _onFocus(event, element) {
        const elementInfo = this._elementInfo.get(element);
        const focusEventTarget = _getEventTarget(event);
        if (!elementInfo || !elementInfo.checkChildren && element !== focusEventTarget) {
          return;
        }
        this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);
      }
      /**
       * Handles blur events on a registered element.
       * @param event The blur event.
       * @param element The monitored element.
       */
      _onBlur(event, element) {
        const elementInfo = this._elementInfo.get(element);
        if (!elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget)) {
          return;
        }
        this._setClasses(element);
        this._emitOrigin(elementInfo, null);
      }
      _emitOrigin(info, origin) {
        if (info.subject.observers.length) {
          this._ngZone.run(() => info.subject.next(origin));
        }
      }
      _registerGlobalListeners(elementInfo) {
        if (!this._platform.isBrowser) {
          return;
        }
        const rootNode = elementInfo.rootNode;
        const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;
        if (!rootNodeFocusListeners) {
          this._ngZone.runOutsideAngular(() => {
            rootNode.addEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
            rootNode.addEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
          });
        }
        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);
        if (++this._monitoredElementCount === 1) {
          this._ngZone.runOutsideAngular(() => {
            const window2 = this._getWindow();
            window2.addEventListener("focus", this._windowFocusListener);
          });
          this._inputModalityDetector.modalityDetected.pipe(takeUntil(this._stopInputModalityDetector)).subscribe((modality) => {
            this._setOrigin(
              modality,
              true
              /* isFromInteraction */
            );
          });
        }
      }
      _removeGlobalListeners(elementInfo) {
        const rootNode = elementInfo.rootNode;
        if (this._rootNodeFocusListenerCount.has(rootNode)) {
          const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);
          if (rootNodeFocusListeners > 1) {
            this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);
          } else {
            rootNode.removeEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
            rootNode.removeEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
            this._rootNodeFocusListenerCount.delete(rootNode);
          }
        }
        if (!--this._monitoredElementCount) {
          const window2 = this._getWindow();
          window2.removeEventListener("focus", this._windowFocusListener);
          this._stopInputModalityDetector.next();
          clearTimeout(this._windowFocusTimeoutId);
          clearTimeout(this._originTimeoutId);
        }
      }
      /** Updates all the state on an element once its focus origin has changed. */
      _originChanged(element, origin, elementInfo) {
        this._setClasses(element, origin);
        this._emitOrigin(elementInfo, origin);
        this._lastFocusOrigin = origin;
      }
      /**
       * Collects the `MonitoredElementInfo` of a particular element and
       * all of its ancestors that have enabled `checkChildren`.
       * @param element Element from which to start the search.
       */
      _getClosestElementsInfo(element) {
        const results = [];
        this._elementInfo.forEach((info, currentElement) => {
          if (currentElement === element || info.checkChildren && currentElement.contains(element)) {
            results.push([currentElement, info]);
          }
        });
        return results;
      }
      /**
       * Returns whether an interaction is likely to have come from the user clicking the `label` of
       * an `input` or `textarea` in order to focus it.
       * @param focusEventTarget Target currently receiving focus.
       */
      _isLastInteractionFromInputLabel(focusEventTarget) {
        const { _mostRecentTarget: mostRecentTarget, mostRecentModality } = this._inputModalityDetector;
        if (mostRecentModality !== "mouse" || !mostRecentTarget || mostRecentTarget === focusEventTarget || focusEventTarget.nodeName !== "INPUT" && focusEventTarget.nodeName !== "TEXTAREA" || focusEventTarget.disabled) {
          return false;
        }
        const labels = focusEventTarget.labels;
        if (labels) {
          for (let i2 = 0; i2 < labels.length; i2++) {
            if (labels[i2].contains(mostRecentTarget)) {
              return true;
            }
          }
        }
        return false;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _FocusMonitor, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _FocusMonitor, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: FocusMonitor, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
    CdkMonitorFocus = class _CdkMonitorFocus {
      _elementRef = inject(ElementRef);
      _focusMonitor = inject(FocusMonitor);
      _monitorSubscription;
      _focusOrigin = null;
      cdkFocusChange = new EventEmitter();
      constructor() {
      }
      get focusOrigin() {
        return this._focusOrigin;
      }
      ngAfterViewInit() {
        const element = this._elementRef.nativeElement;
        this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute("cdkMonitorSubtreeFocus")).subscribe((origin) => {
          this._focusOrigin = origin;
          this.cdkFocusChange.emit(origin);
        });
      }
      ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
        if (this._monitorSubscription) {
          this._monitorSubscription.unsubscribe();
        }
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkMonitorFocus, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _CdkMonitorFocus, isStandalone: true, selector: "[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]", outputs: { cdkFocusChange: "cdkFocusChange" }, exportAs: ["cdkMonitorFocus"], ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkMonitorFocus, decorators: [{
      type: Directive,
      args: [{
        selector: "[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]",
        exportAs: "cdkMonitorFocus"
      }]
    }], ctorParameters: () => [], propDecorators: { cdkFocusChange: [{
      type: Output
    }] } });
  }
});

// node_modules/@angular/cdk/fesm2022/style-loader.mjs
var appsWithLoaders, _CdkPrivateStyleLoader;
var init_style_loader = __esm({
  "node_modules/@angular/cdk/fesm2022/style-loader.mjs"() {
    "use strict";
    init_core();
    init_core();
    appsWithLoaders = /* @__PURE__ */ new WeakMap();
    _CdkPrivateStyleLoader = class __CdkPrivateStyleLoader {
      _appRef;
      _injector = inject(Injector);
      _environmentInjector = inject(EnvironmentInjector);
      /**
       * Loads a set of styles.
       * @param loader Component which will be instantiated to load the styles.
       */
      load(loader) {
        const appRef = this._appRef = this._appRef || this._injector.get(ApplicationRef);
        let data = appsWithLoaders.get(appRef);
        if (!data) {
          data = { loaders: /* @__PURE__ */ new Set(), refs: [] };
          appsWithLoaders.set(appRef, data);
          appRef.onDestroy(() => {
            appsWithLoaders.get(appRef)?.refs.forEach((ref) => ref.destroy());
            appsWithLoaders.delete(appRef);
          });
        }
        if (!data.loaders.has(loader)) {
          data.loaders.add(loader);
          data.refs.push(createComponent(loader, { environmentInjector: this._environmentInjector }));
        }
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: __CdkPrivateStyleLoader, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: __CdkPrivateStyleLoader, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkPrivateStyleLoader, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }] });
  }
});

// node_modules/@angular/cdk/fesm2022/private.mjs
var _VisuallyHiddenLoader;
var init_private = __esm({
  "node_modules/@angular/cdk/fesm2022/private.mjs"() {
    "use strict";
    init_style_loader();
    init_core();
    init_core();
    _VisuallyHiddenLoader = class __VisuallyHiddenLoader {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: __VisuallyHiddenLoader, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "20.2.0-next.2", type: __VisuallyHiddenLoader, isStandalone: true, selector: "ng-component", exportAs: ["cdkVisuallyHidden"], ngImport: core_exports, template: "", isInline: true, styles: [".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}\n"], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _VisuallyHiddenLoader, decorators: [{
      type: Component,
      args: [{ exportAs: "cdkVisuallyHidden", encapsulation: ViewEncapsulation.None, template: "", changeDetection: ChangeDetectionStrategy.OnPush, styles: [".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}\n"] }]
    }] });
  }
});

// node_modules/@angular/cdk/fesm2022/array.mjs
function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}
var init_array = __esm({
  "node_modules/@angular/cdk/fesm2022/array.mjs"() {
    "use strict";
  }
});

// node_modules/@angular/cdk/fesm2022/breakpoints-observer.mjs
function createEmptyStyleRule(query, nonce) {
  if (mediaQueriesForWebkitCompatibility.has(query)) {
    return;
  }
  try {
    if (!mediaQueryStyleNode) {
      mediaQueryStyleNode = document.createElement("style");
      if (nonce) {
        mediaQueryStyleNode.setAttribute("nonce", nonce);
      }
      mediaQueryStyleNode.setAttribute("type", "text/css");
      document.head.appendChild(mediaQueryStyleNode);
    }
    if (mediaQueryStyleNode.sheet) {
      mediaQueryStyleNode.sheet.insertRule(`@media ${query} {body{ }}`, 0);
      mediaQueriesForWebkitCompatibility.add(query);
    }
  } catch (e) {
    console.error(e);
  }
}
function noopMatchMedia(query) {
  return {
    matches: query === "all" || query === "",
    media: query,
    addListener: () => {
    },
    removeListener: () => {
    }
  };
}
function splitQueries(queries) {
  return queries.map((query) => query.split(",")).reduce((a1, a2) => a1.concat(a2)).map((query) => query.trim());
}
var mediaQueriesForWebkitCompatibility, mediaQueryStyleNode, MediaMatcher, BreakpointObserver;
var init_breakpoints_observer = __esm({
  "node_modules/@angular/cdk/fesm2022/breakpoints-observer.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_esm();
    init_operators();
    init_platform2();
    init_array();
    mediaQueriesForWebkitCompatibility = /* @__PURE__ */ new Set();
    MediaMatcher = class _MediaMatcher {
      _platform = inject(Platform);
      _nonce = inject(CSP_NONCE, { optional: true });
      /** The internal matchMedia method to return back a MediaQueryList like object. */
      _matchMedia;
      constructor() {
        this._matchMedia = this._platform.isBrowser && window.matchMedia ? (
          // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
          // call it from a different scope.
          window.matchMedia.bind(window)
        ) : noopMatchMedia;
      }
      /**
       * Evaluates the given media query and returns the native MediaQueryList from which results
       * can be retrieved.
       * Confirms the layout engine will trigger for the selector query provided and returns the
       * MediaQueryList for the query provided.
       */
      matchMedia(query) {
        if (this._platform.WEBKIT || this._platform.BLINK) {
          createEmptyStyleRule(query, this._nonce);
        }
        return this._matchMedia(query);
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MediaMatcher, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MediaMatcher, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MediaMatcher, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
    BreakpointObserver = class _BreakpointObserver {
      _mediaMatcher = inject(MediaMatcher);
      _zone = inject(NgZone);
      /**  A map of all media queries currently being listened for. */
      _queries = /* @__PURE__ */ new Map();
      /** A subject for all other observables to takeUntil based on. */
      _destroySubject = new Subject();
      constructor() {
      }
      /** Completes the active subject, signalling to all other observables to complete. */
      ngOnDestroy() {
        this._destroySubject.next();
        this._destroySubject.complete();
      }
      /**
       * Whether one or more media queries match the current viewport size.
       * @param value One or more media queries to check.
       * @returns Whether any of the media queries match.
       */
      isMatched(value) {
        const queries = splitQueries(coerceArray(value));
        return queries.some((mediaQuery) => this._registerQuery(mediaQuery).mql.matches);
      }
      /**
       * Gets an observable of results for the given queries that will emit new results for any changes
       * in matching of the given queries.
       * @param value One or more media queries to check.
       * @returns A stream of matches for the given queries.
       */
      observe(value) {
        const queries = splitQueries(coerceArray(value));
        const observables = queries.map((query) => this._registerQuery(query).observable);
        let stateObservable = combineLatest(observables);
        stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));
        return stateObservable.pipe(map((breakpointStates) => {
          const response = {
            matches: false,
            breakpoints: {}
          };
          breakpointStates.forEach(({ matches, query }) => {
            response.matches = response.matches || matches;
            response.breakpoints[query] = matches;
          });
          return response;
        }));
      }
      /** Registers a specific query to be listened for. */
      _registerQuery(query) {
        if (this._queries.has(query)) {
          return this._queries.get(query);
        }
        const mql = this._mediaMatcher.matchMedia(query);
        const queryObservable = new Observable((observer) => {
          const handler = (e) => this._zone.run(() => observer.next(e));
          mql.addListener(handler);
          return () => {
            mql.removeListener(handler);
          };
        }).pipe(startWith(mql), map(({ matches }) => ({ query, matches })), takeUntil(this._destroySubject));
        const output = { observable: queryObservable, mql };
        this._queries.set(query, output);
        return output;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _BreakpointObserver, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _BreakpointObserver, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: BreakpointObserver, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
  }
});

// node_modules/@angular/cdk/fesm2022/observers.mjs
function shouldIgnoreRecord(record) {
  if (record.type === "characterData" && record.target instanceof Comment) {
    return true;
  }
  if (record.type === "childList") {
    for (let i2 = 0; i2 < record.addedNodes.length; i2++) {
      if (!(record.addedNodes[i2] instanceof Comment)) {
        return false;
      }
    }
    for (let i2 = 0; i2 < record.removedNodes.length; i2++) {
      if (!(record.removedNodes[i2] instanceof Comment)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var MutationObserverFactory, ContentObserver, CdkObserveContent, ObserversModule;
var init_observers = __esm({
  "node_modules/@angular/cdk/fesm2022/observers.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_esm();
    init_operators();
    init_element();
    MutationObserverFactory = class _MutationObserverFactory {
      create(callback) {
        return typeof MutationObserver === "undefined" ? null : new MutationObserver(callback);
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MutationObserverFactory, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MutationObserverFactory, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MutationObserverFactory, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }] });
    ContentObserver = class _ContentObserver {
      _mutationObserverFactory = inject(MutationObserverFactory);
      /** Keeps track of the existing MutationObservers so they can be reused. */
      _observedElements = /* @__PURE__ */ new Map();
      _ngZone = inject(NgZone);
      constructor() {
      }
      ngOnDestroy() {
        this._observedElements.forEach((_3, element) => this._cleanupObserver(element));
      }
      observe(elementOrRef) {
        const element = coerceElement(elementOrRef);
        return new Observable((observer) => {
          const stream = this._observeElement(element);
          const subscription = stream.pipe(map((records) => records.filter((record) => !shouldIgnoreRecord(record))), filter((records) => !!records.length)).subscribe((records) => {
            this._ngZone.run(() => {
              observer.next(records);
            });
          });
          return () => {
            subscription.unsubscribe();
            this._unobserveElement(element);
          };
        });
      }
      /**
       * Observes the given element by using the existing MutationObserver if available, or creating a
       * new one if not.
       */
      _observeElement(element) {
        return this._ngZone.runOutsideAngular(() => {
          if (!this._observedElements.has(element)) {
            const stream = new Subject();
            const observer = this._mutationObserverFactory.create((mutations) => stream.next(mutations));
            if (observer) {
              observer.observe(element, {
                characterData: true,
                childList: true,
                subtree: true
              });
            }
            this._observedElements.set(element, { observer, stream, count: 1 });
          } else {
            this._observedElements.get(element).count++;
          }
          return this._observedElements.get(element).stream;
        });
      }
      /**
       * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
       * observing this element.
       */
      _unobserveElement(element) {
        if (this._observedElements.has(element)) {
          this._observedElements.get(element).count--;
          if (!this._observedElements.get(element).count) {
            this._cleanupObserver(element);
          }
        }
      }
      /** Clean up the underlying MutationObserver for the specified element. */
      _cleanupObserver(element) {
        if (this._observedElements.has(element)) {
          const { observer, stream } = this._observedElements.get(element);
          if (observer) {
            observer.disconnect();
          }
          stream.complete();
          this._observedElements.delete(element);
        }
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ContentObserver, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ContentObserver, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: ContentObserver, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
    CdkObserveContent = class _CdkObserveContent {
      _contentObserver = inject(ContentObserver);
      _elementRef = inject(ElementRef);
      /** Event emitted for each change in the element's content. */
      event = new EventEmitter();
      /**
       * Whether observing content is disabled. This option can be used
       * to disconnect the underlying MutationObserver until it is needed.
       */
      get disabled() {
        return this._disabled;
      }
      set disabled(value) {
        this._disabled = value;
        this._disabled ? this._unsubscribe() : this._subscribe();
      }
      _disabled = false;
      /** Debounce interval for emitting the changes. */
      get debounce() {
        return this._debounce;
      }
      set debounce(value) {
        this._debounce = coerceNumberProperty(value);
        this._subscribe();
      }
      _debounce;
      _currentSubscription = null;
      constructor() {
      }
      ngAfterContentInit() {
        if (!this._currentSubscription && !this.disabled) {
          this._subscribe();
        }
      }
      ngOnDestroy() {
        this._unsubscribe();
      }
      _subscribe() {
        this._unsubscribe();
        const stream = this._contentObserver.observe(this._elementRef);
        this._currentSubscription = (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);
      }
      _unsubscribe() {
        this._currentSubscription?.unsubscribe();
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkObserveContent, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "16.1.0", version: "20.2.0-next.2", type: _CdkObserveContent, isStandalone: true, selector: "[cdkObserveContent]", inputs: { disabled: ["cdkObserveContentDisabled", "disabled", booleanAttribute], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"], ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkObserveContent, decorators: [{
      type: Directive,
      args: [{
        selector: "[cdkObserveContent]",
        exportAs: "cdkObserveContent"
      }]
    }], ctorParameters: () => [], propDecorators: { event: [{
      type: Output,
      args: ["cdkObserveContent"]
    }], disabled: [{
      type: Input,
      args: [{ alias: "cdkObserveContentDisabled", transform: booleanAttribute }]
    }], debounce: [{
      type: Input
    }] } });
    ObserversModule = class _ObserversModule {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ObserversModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ObserversModule, imports: [CdkObserveContent], exports: [CdkObserveContent] });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ObserversModule, providers: [MutationObserverFactory] });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: ObserversModule, decorators: [{
      type: NgModule,
      args: [{
        imports: [CdkObserveContent],
        exports: [CdkObserveContent],
        providers: [MutationObserverFactory]
      }]
    }] });
  }
});

// node_modules/@angular/cdk/fesm2022/a11y-module.mjs
function getFrameElement(window2) {
  try {
    return window2.frameElement;
  } catch {
    return null;
  }
}
function hasGeometry(element) {
  return !!(element.offsetWidth || element.offsetHeight || typeof element.getClientRects === "function" && element.getClientRects().length);
}
function isNativeFormElement(element) {
  let nodeName = element.nodeName.toLowerCase();
  return nodeName === "input" || nodeName === "select" || nodeName === "button" || nodeName === "textarea";
}
function isHiddenInput(element) {
  return isInputElement(element) && element.type == "hidden";
}
function isAnchorWithHref(element) {
  return isAnchorElement(element) && element.hasAttribute("href");
}
function isInputElement(element) {
  return element.nodeName.toLowerCase() == "input";
}
function isAnchorElement(element) {
  return element.nodeName.toLowerCase() == "a";
}
function hasValidTabIndex(element) {
  if (!element.hasAttribute("tabindex") || element.tabIndex === void 0) {
    return false;
  }
  let tabIndex = element.getAttribute("tabindex");
  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
}
function getTabIndexValue(element) {
  if (!hasValidTabIndex(element)) {
    return null;
  }
  const tabIndex = parseInt(element.getAttribute("tabindex") || "", 10);
  return isNaN(tabIndex) ? -1 : tabIndex;
}
function isPotentiallyTabbableIOS(element) {
  let nodeName = element.nodeName.toLowerCase();
  let inputType = nodeName === "input" && element.type;
  return inputType === "text" || inputType === "password" || nodeName === "select" || nodeName === "textarea";
}
function isPotentiallyFocusable(element) {
  if (isHiddenInput(element)) {
    return false;
  }
  return isNativeFormElement(element) || isAnchorWithHref(element) || element.hasAttribute("contenteditable") || hasValidTabIndex(element);
}
function getWindow(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || window;
}
function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {
  return null;
}
var InteractivityChecker, FocusTrap, FocusTrapFactory, CdkTrapFocus, LIVE_ANNOUNCER_ELEMENT_TOKEN, LIVE_ANNOUNCER_DEFAULT_OPTIONS, uniqueIds, LiveAnnouncer, CdkAriaLive, HighContrastMode, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS, HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, HighContrastModeDetector, A11yModule;
var init_a11y_module = __esm({
  "node_modules/@angular/cdk/fesm2022/a11y-module.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_focus_monitor();
    init_platform2();
    init_shadow_dom();
    init_style_loader();
    init_private();
    init_breakpoints_observer();
    init_observers();
    InteractivityChecker = class _InteractivityChecker {
      _platform = inject(Platform);
      constructor() {
      }
      /**
       * Gets whether an element is disabled.
       *
       * @param element Element to be checked.
       * @returns Whether the element is disabled.
       */
      isDisabled(element) {
        return element.hasAttribute("disabled");
      }
      /**
       * Gets whether an element is visible for the purposes of interactivity.
       *
       * This will capture states like `display: none` and `visibility: hidden`, but not things like
       * being clipped by an `overflow: hidden` parent or being outside the viewport.
       *
       * @returns Whether the element is visible.
       */
      isVisible(element) {
        return hasGeometry(element) && getComputedStyle(element).visibility === "visible";
      }
      /**
       * Gets whether an element can be reached via Tab key.
       * Assumes that the element has already been checked with isFocusable.
       *
       * @param element Element to be checked.
       * @returns Whether the element is tabbable.
       */
      isTabbable(element) {
        if (!this._platform.isBrowser) {
          return false;
        }
        const frameElement = getFrameElement(getWindow(element));
        if (frameElement) {
          if (getTabIndexValue(frameElement) === -1) {
            return false;
          }
          if (!this.isVisible(frameElement)) {
            return false;
          }
        }
        let nodeName = element.nodeName.toLowerCase();
        let tabIndexValue = getTabIndexValue(element);
        if (element.hasAttribute("contenteditable")) {
          return tabIndexValue !== -1;
        }
        if (nodeName === "iframe" || nodeName === "object") {
          return false;
        }
        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
          return false;
        }
        if (nodeName === "audio") {
          if (!element.hasAttribute("controls")) {
            return false;
          }
          return tabIndexValue !== -1;
        }
        if (nodeName === "video") {
          if (tabIndexValue === -1) {
            return false;
          }
          if (tabIndexValue !== null) {
            return true;
          }
          return this._platform.FIREFOX || element.hasAttribute("controls");
        }
        return element.tabIndex >= 0;
      }
      /**
       * Gets whether an element can be focused by the user.
       *
       * @param element Element to be checked.
       * @param config The config object with options to customize this method's behavior
       * @returns Whether the element is focusable.
       */
      isFocusable(element, config) {
        return isPotentiallyFocusable(element) && !this.isDisabled(element) && (config?.ignoreVisibility || this.isVisible(element));
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _InteractivityChecker, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _InteractivityChecker, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: InteractivityChecker, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
    FocusTrap = class {
      _element;
      _checker;
      _ngZone;
      _document;
      _injector;
      _startAnchor;
      _endAnchor;
      _hasAttached = false;
      // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.
      startAnchorListener = () => this.focusLastTabbableElement();
      endAnchorListener = () => this.focusFirstTabbableElement();
      /** Whether the focus trap is active. */
      get enabled() {
        return this._enabled;
      }
      set enabled(value) {
        this._enabled = value;
        if (this._startAnchor && this._endAnchor) {
          this._toggleAnchorTabIndex(value, this._startAnchor);
          this._toggleAnchorTabIndex(value, this._endAnchor);
        }
      }
      _enabled = true;
      constructor(_element, _checker, _ngZone, _document, deferAnchors = false, _injector) {
        this._element = _element;
        this._checker = _checker;
        this._ngZone = _ngZone;
        this._document = _document;
        this._injector = _injector;
        if (!deferAnchors) {
          this.attachAnchors();
        }
      }
      /** Destroys the focus trap by cleaning up the anchors. */
      destroy() {
        const startAnchor = this._startAnchor;
        const endAnchor = this._endAnchor;
        if (startAnchor) {
          startAnchor.removeEventListener("focus", this.startAnchorListener);
          startAnchor.remove();
        }
        if (endAnchor) {
          endAnchor.removeEventListener("focus", this.endAnchorListener);
          endAnchor.remove();
        }
        this._startAnchor = this._endAnchor = null;
        this._hasAttached = false;
      }
      /**
       * Inserts the anchors into the DOM. This is usually done automatically
       * in the constructor, but can be deferred for cases like directives with `*ngIf`.
       * @returns Whether the focus trap managed to attach successfully. This may not be the case
       * if the target element isn't currently in the DOM.
       */
      attachAnchors() {
        if (this._hasAttached) {
          return true;
        }
        this._ngZone.runOutsideAngular(() => {
          if (!this._startAnchor) {
            this._startAnchor = this._createAnchor();
            this._startAnchor.addEventListener("focus", this.startAnchorListener);
          }
          if (!this._endAnchor) {
            this._endAnchor = this._createAnchor();
            this._endAnchor.addEventListener("focus", this.endAnchorListener);
          }
        });
        if (this._element.parentNode) {
          this._element.parentNode.insertBefore(this._startAnchor, this._element);
          this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);
          this._hasAttached = true;
        }
        return this._hasAttached;
      }
      /**
       * Waits for the zone to stabilize, then focuses the first tabbable element.
       * @returns Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfully.
       */
      focusInitialElementWhenReady(options) {
        return new Promise((resolve) => {
          this._executeOnStable(() => resolve(this.focusInitialElement(options)));
        });
      }
      /**
       * Waits for the zone to stabilize, then focuses
       * the first tabbable element within the focus trap region.
       * @returns Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfully.
       */
      focusFirstTabbableElementWhenReady(options) {
        return new Promise((resolve) => {
          this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));
        });
      }
      /**
       * Waits for the zone to stabilize, then focuses
       * the last tabbable element within the focus trap region.
       * @returns Returns a promise that resolves with a boolean, depending
       * on whether focus was moved successfully.
       */
      focusLastTabbableElementWhenReady(options) {
        return new Promise((resolve) => {
          this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));
        });
      }
      /**
       * Get the specified boundary element of the trapped region.
       * @param bound The boundary to get (start or end of trapped region).
       * @returns The boundary element.
       */
      _getRegionBoundary(bound) {
        const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], [cdkFocusRegion${bound}], [cdk-focus-${bound}]`);
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          for (let i2 = 0; i2 < markers.length; i2++) {
            if (markers[i2].hasAttribute(`cdk-focus-${bound}`)) {
              console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i2]);
            } else if (markers[i2].hasAttribute(`cdk-focus-region-${bound}`)) {
              console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i2]);
            }
          }
        }
        if (bound == "start") {
          return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);
        }
        return markers.length ? markers[markers.length - 1] : this._getLastTabbableElement(this._element);
      }
      /**
       * Focuses the element that should be focused when the focus trap is initialized.
       * @returns Whether focus was moved successfully.
       */
      focusInitialElement(options) {
        const redirectToElement = this._element.querySelector(`[cdk-focus-initial], [cdkFocusInitial]`);
        if (redirectToElement) {
          if ((typeof ngDevMode === "undefined" || ngDevMode) && redirectToElement.hasAttribute(`cdk-focus-initial`)) {
            console.warn(`Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0`, redirectToElement);
          }
          if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._checker.isFocusable(redirectToElement)) {
            console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);
          }
          if (!this._checker.isFocusable(redirectToElement)) {
            const focusableChild = this._getFirstTabbableElement(redirectToElement);
            focusableChild?.focus(options);
            return !!focusableChild;
          }
          redirectToElement.focus(options);
          return true;
        }
        return this.focusFirstTabbableElement(options);
      }
      /**
       * Focuses the first tabbable element within the focus trap region.
       * @returns Whether focus was moved successfully.
       */
      focusFirstTabbableElement(options) {
        const redirectToElement = this._getRegionBoundary("start");
        if (redirectToElement) {
          redirectToElement.focus(options);
        }
        return !!redirectToElement;
      }
      /**
       * Focuses the last tabbable element within the focus trap region.
       * @returns Whether focus was moved successfully.
       */
      focusLastTabbableElement(options) {
        const redirectToElement = this._getRegionBoundary("end");
        if (redirectToElement) {
          redirectToElement.focus(options);
        }
        return !!redirectToElement;
      }
      /**
       * Checks whether the focus trap has successfully been attached.
       */
      hasAttached() {
        return this._hasAttached;
      }
      /** Get the first tabbable element from a DOM subtree (inclusive). */
      _getFirstTabbableElement(root) {
        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
          return root;
        }
        const children = root.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          const tabbableChild = children[i2].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(children[i2]) : null;
          if (tabbableChild) {
            return tabbableChild;
          }
        }
        return null;
      }
      /** Get the last tabbable element from a DOM subtree (inclusive). */
      _getLastTabbableElement(root) {
        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
          return root;
        }
        const children = root.children;
        for (let i2 = children.length - 1; i2 >= 0; i2--) {
          const tabbableChild = children[i2].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(children[i2]) : null;
          if (tabbableChild) {
            return tabbableChild;
          }
        }
        return null;
      }
      /** Creates an anchor element. */
      _createAnchor() {
        const anchor = this._document.createElement("div");
        this._toggleAnchorTabIndex(this._enabled, anchor);
        anchor.classList.add("cdk-visually-hidden");
        anchor.classList.add("cdk-focus-trap-anchor");
        anchor.setAttribute("aria-hidden", "true");
        return anchor;
      }
      /**
       * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.
       * @param isEnabled Whether the focus trap is enabled.
       * @param anchor Anchor on which to toggle the tabindex.
       */
      _toggleAnchorTabIndex(isEnabled, anchor) {
        isEnabled ? anchor.setAttribute("tabindex", "0") : anchor.removeAttribute("tabindex");
      }
      /**
       * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.
       * @param enabled: Whether the anchors should trap Tab.
       */
      toggleAnchors(enabled) {
        if (this._startAnchor && this._endAnchor) {
          this._toggleAnchorTabIndex(enabled, this._startAnchor);
          this._toggleAnchorTabIndex(enabled, this._endAnchor);
        }
      }
      /** Executes a function when the zone is stable. */
      _executeOnStable(fn) {
        if (this._injector) {
          afterNextRender(fn, { injector: this._injector });
        } else {
          setTimeout(fn);
        }
      }
    };
    FocusTrapFactory = class _FocusTrapFactory {
      _checker = inject(InteractivityChecker);
      _ngZone = inject(NgZone);
      _document = inject(DOCUMENT);
      _injector = inject(Injector);
      constructor() {
        inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
      }
      /**
       * Creates a focus-trapped region around the given element.
       * @param element The element around which focus will be trapped.
       * @param deferCaptureElements Defers the creation of focus-capturing elements to be done
       *     manually by the user.
       * @returns The created focus trap instance.
       */
      create(element, deferCaptureElements = false) {
        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements, this._injector);
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _FocusTrapFactory, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _FocusTrapFactory, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: FocusTrapFactory, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
    CdkTrapFocus = class _CdkTrapFocus {
      _elementRef = inject(ElementRef);
      _focusTrapFactory = inject(FocusTrapFactory);
      /** Underlying FocusTrap instance. */
      focusTrap;
      /** Previously focused element to restore focus to upon destroy when using autoCapture. */
      _previouslyFocusedElement = null;
      /** Whether the focus trap is active. */
      get enabled() {
        return this.focusTrap?.enabled || false;
      }
      set enabled(value) {
        if (this.focusTrap) {
          this.focusTrap.enabled = value;
        }
      }
      /**
       * Whether the directive should automatically move focus into the trapped region upon
       * initialization and return focus to the previous activeElement upon destruction.
       */
      autoCapture;
      constructor() {
        const platform = inject(Platform);
        if (platform.isBrowser) {
          this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
        }
      }
      ngOnDestroy() {
        this.focusTrap?.destroy();
        if (this._previouslyFocusedElement) {
          this._previouslyFocusedElement.focus();
          this._previouslyFocusedElement = null;
        }
      }
      ngAfterContentInit() {
        this.focusTrap?.attachAnchors();
        if (this.autoCapture) {
          this._captureFocus();
        }
      }
      ngDoCheck() {
        if (this.focusTrap && !this.focusTrap.hasAttached()) {
          this.focusTrap.attachAnchors();
        }
      }
      ngOnChanges(changes) {
        const autoCaptureChange = changes["autoCapture"];
        if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture && this.focusTrap?.hasAttached()) {
          this._captureFocus();
        }
      }
      _captureFocus() {
        this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();
        this.focusTrap?.focusInitialElementWhenReady();
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkTrapFocus, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "16.1.0", version: "20.2.0-next.2", type: _CdkTrapFocus, isStandalone: true, selector: "[cdkTrapFocus]", inputs: { enabled: ["cdkTrapFocus", "enabled", booleanAttribute], autoCapture: ["cdkTrapFocusAutoCapture", "autoCapture", booleanAttribute] }, exportAs: ["cdkTrapFocus"], usesOnChanges: true, ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkTrapFocus, decorators: [{
      type: Directive,
      args: [{
        selector: "[cdkTrapFocus]",
        exportAs: "cdkTrapFocus"
      }]
    }], ctorParameters: () => [], propDecorators: { enabled: [{
      type: Input,
      args: [{ alias: "cdkTrapFocus", transform: booleanAttribute }]
    }], autoCapture: [{
      type: Input,
      args: [{ alias: "cdkTrapFocusAutoCapture", transform: booleanAttribute }]
    }] } });
    LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken("liveAnnouncerElement", {
      providedIn: "root",
      factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY
    });
    LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
    uniqueIds = 0;
    LiveAnnouncer = class _LiveAnnouncer {
      _ngZone = inject(NgZone);
      _defaultOptions = inject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, {
        optional: true
      });
      _liveElement;
      _document = inject(DOCUMENT);
      _previousTimeout;
      _currentPromise;
      _currentResolve;
      constructor() {
        const elementToken = inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, { optional: true });
        this._liveElement = elementToken || this._createLiveElement();
      }
      announce(message, ...args) {
        const defaultOptions = this._defaultOptions;
        let politeness;
        let duration;
        if (args.length === 1 && typeof args[0] === "number") {
          duration = args[0];
        } else {
          [politeness, duration] = args;
        }
        this.clear();
        clearTimeout(this._previousTimeout);
        if (!politeness) {
          politeness = defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : "polite";
        }
        if (duration == null && defaultOptions) {
          duration = defaultOptions.duration;
        }
        this._liveElement.setAttribute("aria-live", politeness);
        if (this._liveElement.id) {
          this._exposeAnnouncerToModals(this._liveElement.id);
        }
        return this._ngZone.runOutsideAngular(() => {
          if (!this._currentPromise) {
            this._currentPromise = new Promise((resolve) => this._currentResolve = resolve);
          }
          clearTimeout(this._previousTimeout);
          this._previousTimeout = setTimeout(() => {
            this._liveElement.textContent = message;
            if (typeof duration === "number") {
              this._previousTimeout = setTimeout(() => this.clear(), duration);
            }
            this._currentResolve?.();
            this._currentPromise = this._currentResolve = void 0;
          }, 100);
          return this._currentPromise;
        });
      }
      /**
       * Clears the current text from the announcer element. Can be used to prevent
       * screen readers from reading the text out again while the user is going
       * through the page landmarks.
       */
      clear() {
        if (this._liveElement) {
          this._liveElement.textContent = "";
        }
      }
      ngOnDestroy() {
        clearTimeout(this._previousTimeout);
        this._liveElement?.remove();
        this._liveElement = null;
        this._currentResolve?.();
        this._currentPromise = this._currentResolve = void 0;
      }
      _createLiveElement() {
        const elementClass = "cdk-live-announcer-element";
        const previousElements = this._document.getElementsByClassName(elementClass);
        const liveEl = this._document.createElement("div");
        for (let i2 = 0; i2 < previousElements.length; i2++) {
          previousElements[i2].remove();
        }
        liveEl.classList.add(elementClass);
        liveEl.classList.add("cdk-visually-hidden");
        liveEl.setAttribute("aria-atomic", "true");
        liveEl.setAttribute("aria-live", "polite");
        liveEl.id = `cdk-live-announcer-${uniqueIds++}`;
        this._document.body.appendChild(liveEl);
        return liveEl;
      }
      /**
       * Some browsers won't expose the accessibility node of the live announcer element if there is an
       * `aria-modal` and the live announcer is outside of it. This method works around the issue by
       * pointing the `aria-owns` of all modals to the live announcer element.
       */
      _exposeAnnouncerToModals(id) {
        const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');
        for (let i2 = 0; i2 < modals.length; i2++) {
          const modal = modals[i2];
          const ariaOwns = modal.getAttribute("aria-owns");
          if (!ariaOwns) {
            modal.setAttribute("aria-owns", id);
          } else if (ariaOwns.indexOf(id) === -1) {
            modal.setAttribute("aria-owns", ariaOwns + " " + id);
          }
        }
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _LiveAnnouncer, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _LiveAnnouncer, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: LiveAnnouncer, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
    CdkAriaLive = class _CdkAriaLive {
      _elementRef = inject(ElementRef);
      _liveAnnouncer = inject(LiveAnnouncer);
      _contentObserver = inject(ContentObserver);
      _ngZone = inject(NgZone);
      /** The aria-live politeness level to use when announcing messages. */
      get politeness() {
        return this._politeness;
      }
      set politeness(value) {
        this._politeness = value === "off" || value === "assertive" ? value : "polite";
        if (this._politeness === "off") {
          if (this._subscription) {
            this._subscription.unsubscribe();
            this._subscription = null;
          }
        } else if (!this._subscription) {
          this._subscription = this._ngZone.runOutsideAngular(() => {
            return this._contentObserver.observe(this._elementRef).subscribe(() => {
              const elementText = this._elementRef.nativeElement.textContent;
              if (elementText !== this._previousAnnouncedText) {
                this._liveAnnouncer.announce(elementText, this._politeness, this.duration);
                this._previousAnnouncedText = elementText;
              }
            });
          });
        }
      }
      _politeness = "polite";
      /** Time in milliseconds after which to clear out the announcer element. */
      duration;
      _previousAnnouncedText;
      _subscription;
      constructor() {
        inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
      }
      ngOnDestroy() {
        if (this._subscription) {
          this._subscription.unsubscribe();
        }
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkAriaLive, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _CdkAriaLive, isStandalone: true, selector: "[cdkAriaLive]", inputs: { politeness: ["cdkAriaLive", "politeness"], duration: ["cdkAriaLiveDuration", "duration"] }, exportAs: ["cdkAriaLive"], ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkAriaLive, decorators: [{
      type: Directive,
      args: [{
        selector: "[cdkAriaLive]",
        exportAs: "cdkAriaLive"
      }]
    }], ctorParameters: () => [], propDecorators: { politeness: [{
      type: Input,
      args: ["cdkAriaLive"]
    }], duration: [{
      type: Input,
      args: ["cdkAriaLiveDuration"]
    }] } });
    (function(HighContrastMode2) {
      HighContrastMode2[HighContrastMode2["NONE"] = 0] = "NONE";
      HighContrastMode2[HighContrastMode2["BLACK_ON_WHITE"] = 1] = "BLACK_ON_WHITE";
      HighContrastMode2[HighContrastMode2["WHITE_ON_BLACK"] = 2] = "WHITE_ON_BLACK";
    })(HighContrastMode || (HighContrastMode = {}));
    BLACK_ON_WHITE_CSS_CLASS = "cdk-high-contrast-black-on-white";
    WHITE_ON_BLACK_CSS_CLASS = "cdk-high-contrast-white-on-black";
    HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = "cdk-high-contrast-active";
    HighContrastModeDetector = class _HighContrastModeDetector {
      _platform = inject(Platform);
      /**
       * Figuring out the high contrast mode and adding the body classes can cause
       * some expensive layouts. This flag is used to ensure that we only do it once.
       */
      _hasCheckedHighContrastMode;
      _document = inject(DOCUMENT);
      _breakpointSubscription;
      constructor() {
        this._breakpointSubscription = inject(BreakpointObserver).observe("(forced-colors: active)").subscribe(() => {
          if (this._hasCheckedHighContrastMode) {
            this._hasCheckedHighContrastMode = false;
            this._applyBodyHighContrastModeCssClasses();
          }
        });
      }
      /** Gets the current high-contrast-mode for the page. */
      getHighContrastMode() {
        if (!this._platform.isBrowser) {
          return HighContrastMode.NONE;
        }
        const testElement = this._document.createElement("div");
        testElement.style.backgroundColor = "rgb(1,2,3)";
        testElement.style.position = "absolute";
        this._document.body.appendChild(testElement);
        const documentWindow = this._document.defaultView || window;
        const computedStyle = documentWindow && documentWindow.getComputedStyle ? documentWindow.getComputedStyle(testElement) : null;
        const computedColor = (computedStyle && computedStyle.backgroundColor || "").replace(/ /g, "");
        testElement.remove();
        switch (computedColor) {
          // Pre Windows 11 dark theme.
          case "rgb(0,0,0)":
          // Windows 11 dark themes.
          case "rgb(45,50,54)":
          case "rgb(32,32,32)":
            return HighContrastMode.WHITE_ON_BLACK;
          // Pre Windows 11 light theme.
          case "rgb(255,255,255)":
          // Windows 11 light theme.
          case "rgb(255,250,239)":
            return HighContrastMode.BLACK_ON_WHITE;
        }
        return HighContrastMode.NONE;
      }
      ngOnDestroy() {
        this._breakpointSubscription.unsubscribe();
      }
      /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */
      _applyBodyHighContrastModeCssClasses() {
        if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {
          const bodyClasses = this._document.body.classList;
          bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
          this._hasCheckedHighContrastMode = true;
          const mode = this.getHighContrastMode();
          if (mode === HighContrastMode.BLACK_ON_WHITE) {
            bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);
          } else if (mode === HighContrastMode.WHITE_ON_BLACK) {
            bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
          }
        }
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _HighContrastModeDetector, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _HighContrastModeDetector, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: HighContrastModeDetector, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
    A11yModule = class _A11yModule {
      constructor() {
        inject(HighContrastModeDetector)._applyBodyHighContrastModeCssClasses();
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _A11yModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _A11yModule, imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus], exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus] });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _A11yModule, imports: [ObserversModule] });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: A11yModule, decorators: [{
      type: NgModule,
      args: [{
        imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
        exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
      }]
    }], ctorParameters: () => [] });
  }
});

// node_modules/@angular/cdk/fesm2022/keycodes.mjs
function hasModifierKey(event, ...modifiers) {
  if (modifiers.length) {
    return modifiers.some((modifier) => event[modifier]);
  }
  return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;
}
var init_keycodes = __esm({
  "node_modules/@angular/cdk/fesm2022/keycodes.mjs"() {
    "use strict";
    init_keycodes2();
  }
});

// node_modules/@angular/cdk/fesm2022/a11y.mjs
function addAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  if (ids.some((existingId) => existingId.trim() === id)) {
    return;
  }
  ids.push(id);
  el.setAttribute(attr, ids.join(ID_DELIMITER));
}
function removeAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  const filteredIds = ids.filter((val) => val !== id);
  if (filteredIds.length) {
    el.setAttribute(attr, filteredIds.join(ID_DELIMITER));
  } else {
    el.removeAttribute(attr);
  }
}
function getAriaReferenceIds(el, attr) {
  const attrValue = el.getAttribute(attr);
  return attrValue?.match(/\S+/g) ?? [];
}
function getKey(message, role) {
  return typeof message === "string" ? `${role || ""}/${message}` : message;
}
function setMessageId(element, serviceId) {
  if (!element.id) {
    element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;
  }
}
var ID_DELIMITER, CDK_DESCRIBEDBY_ID_PREFIX, CDK_DESCRIBEDBY_HOST_ATTRIBUTE, nextId, AriaDescriber, ConfigurableFocusTrap, EventListenerFocusTrapInertStrategy, FOCUS_TRAP_INERT_STRATEGY, FocusTrapManager, ConfigurableFocusTrapFactory;
var init_a11y = __esm({
  "node_modules/@angular/cdk/fesm2022/a11y.mjs"() {
    "use strict";
    init_focus_monitor();
    init_a11y_module();
    init_a11y_module();
    init_core();
    init_core();
    init_platform2();
    init_style_loader();
    init_private();
    init_fake_event_detection();
    ID_DELIMITER = " ";
    CDK_DESCRIBEDBY_ID_PREFIX = "cdk-describedby-message";
    CDK_DESCRIBEDBY_HOST_ATTRIBUTE = "cdk-describedby-host";
    nextId = 0;
    AriaDescriber = class _AriaDescriber {
      _platform = inject(Platform);
      _document = inject(DOCUMENT);
      /** Map of all registered message elements that have been placed into the document. */
      _messageRegistry = /* @__PURE__ */ new Map();
      /** Container for all registered messages. */
      _messagesContainer = null;
      /** Unique ID for the service. */
      _id = `${nextId++}`;
      constructor() {
        inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
        this._id = inject(APP_ID) + "-" + nextId++;
      }
      describe(hostElement, message, role) {
        if (!this._canBeDescribed(hostElement, message)) {
          return;
        }
        const key = getKey(message, role);
        if (typeof message !== "string") {
          setMessageId(message, this._id);
          this._messageRegistry.set(key, { messageElement: message, referenceCount: 0 });
        } else if (!this._messageRegistry.has(key)) {
          this._createMessageElement(message, role);
        }
        if (!this._isElementDescribedByMessage(hostElement, key)) {
          this._addMessageReference(hostElement, key);
        }
      }
      removeDescription(hostElement, message, role) {
        if (!message || !this._isElementNode(hostElement)) {
          return;
        }
        const key = getKey(message, role);
        if (this._isElementDescribedByMessage(hostElement, key)) {
          this._removeMessageReference(hostElement, key);
        }
        if (typeof message === "string") {
          const registeredMessage = this._messageRegistry.get(key);
          if (registeredMessage && registeredMessage.referenceCount === 0) {
            this._deleteMessageElement(key);
          }
        }
        if (this._messagesContainer?.childNodes.length === 0) {
          this._messagesContainer.remove();
          this._messagesContainer = null;
        }
      }
      /** Unregisters all created message elements and removes the message container. */
      ngOnDestroy() {
        const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}="${this._id}"]`);
        for (let i2 = 0; i2 < describedElements.length; i2++) {
          this._removeCdkDescribedByReferenceIds(describedElements[i2]);
          describedElements[i2].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
        }
        this._messagesContainer?.remove();
        this._messagesContainer = null;
        this._messageRegistry.clear();
      }
      /**
       * Creates a new element in the visually hidden message container element with the message
       * as its content and adds it to the message registry.
       */
      _createMessageElement(message, role) {
        const messageElement = this._document.createElement("div");
        setMessageId(messageElement, this._id);
        messageElement.textContent = message;
        if (role) {
          messageElement.setAttribute("role", role);
        }
        this._createMessagesContainer();
        this._messagesContainer.appendChild(messageElement);
        this._messageRegistry.set(getKey(message, role), { messageElement, referenceCount: 0 });
      }
      /** Deletes the message element from the global messages container. */
      _deleteMessageElement(key) {
        this._messageRegistry.get(key)?.messageElement?.remove();
        this._messageRegistry.delete(key);
      }
      /** Creates the global container for all aria-describedby messages. */
      _createMessagesContainer() {
        if (this._messagesContainer) {
          return;
        }
        const containerClassName = "cdk-describedby-message-container";
        const serverContainers = this._document.querySelectorAll(`.${containerClassName}[platform="server"]`);
        for (let i2 = 0; i2 < serverContainers.length; i2++) {
          serverContainers[i2].remove();
        }
        const messagesContainer = this._document.createElement("div");
        messagesContainer.style.visibility = "hidden";
        messagesContainer.classList.add(containerClassName);
        messagesContainer.classList.add("cdk-visually-hidden");
        if (!this._platform.isBrowser) {
          messagesContainer.setAttribute("platform", "server");
        }
        this._document.body.appendChild(messagesContainer);
        this._messagesContainer = messagesContainer;
      }
      /** Removes all cdk-describedby messages that are hosted through the element. */
      _removeCdkDescribedByReferenceIds(element) {
        const originalReferenceIds = getAriaReferenceIds(element, "aria-describedby").filter((id) => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);
        element.setAttribute("aria-describedby", originalReferenceIds.join(" "));
      }
      /**
       * Adds a message reference to the element using aria-describedby and increments the registered
       * message's reference count.
       */
      _addMessageReference(element, key) {
        const registeredMessage = this._messageRegistry.get(key);
        addAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);
        registeredMessage.referenceCount++;
      }
      /**
       * Removes a message reference from the element using aria-describedby
       * and decrements the registered message's reference count.
       */
      _removeMessageReference(element, key) {
        const registeredMessage = this._messageRegistry.get(key);
        registeredMessage.referenceCount--;
        removeAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
      }
      /** Returns true if the element has been described by the provided message ID. */
      _isElementDescribedByMessage(element, key) {
        const referenceIds = getAriaReferenceIds(element, "aria-describedby");
        const registeredMessage = this._messageRegistry.get(key);
        const messageId = registeredMessage && registeredMessage.messageElement.id;
        return !!messageId && referenceIds.indexOf(messageId) != -1;
      }
      /** Determines whether a message can be described on a particular element. */
      _canBeDescribed(element, message) {
        if (!this._isElementNode(element)) {
          return false;
        }
        if (message && typeof message === "object") {
          return true;
        }
        const trimmedMessage = message == null ? "" : `${message}`.trim();
        const ariaLabel = element.getAttribute("aria-label");
        return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;
      }
      /** Checks whether a node is an Element node. */
      _isElementNode(element) {
        return element.nodeType === this._document.ELEMENT_NODE;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _AriaDescriber, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _AriaDescriber, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: AriaDescriber, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
    ConfigurableFocusTrap = class extends FocusTrap {
      _focusTrapManager;
      _inertStrategy;
      /** Whether the FocusTrap is enabled. */
      get enabled() {
        return this._enabled;
      }
      set enabled(value) {
        this._enabled = value;
        if (this._enabled) {
          this._focusTrapManager.register(this);
        } else {
          this._focusTrapManager.deregister(this);
        }
      }
      constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config, injector) {
        super(_element, _checker, _ngZone, _document, config.defer, injector);
        this._focusTrapManager = _focusTrapManager;
        this._inertStrategy = _inertStrategy;
        this._focusTrapManager.register(this);
      }
      /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */
      destroy() {
        this._focusTrapManager.deregister(this);
        super.destroy();
      }
      /** @docs-private Implemented as part of ManagedFocusTrap. */
      _enable() {
        this._inertStrategy.preventFocus(this);
        this.toggleAnchors(true);
      }
      /** @docs-private Implemented as part of ManagedFocusTrap. */
      _disable() {
        this._inertStrategy.allowFocus(this);
        this.toggleAnchors(false);
      }
    };
    EventListenerFocusTrapInertStrategy = class {
      /** Focus event handler. */
      _listener = null;
      /** Adds a document event listener that keeps focus inside the FocusTrap. */
      preventFocus(focusTrap) {
        if (this._listener) {
          focusTrap._document.removeEventListener("focus", this._listener, true);
        }
        this._listener = (e) => this._trapFocus(focusTrap, e);
        focusTrap._ngZone.runOutsideAngular(() => {
          focusTrap._document.addEventListener("focus", this._listener, true);
        });
      }
      /** Removes the event listener added in preventFocus. */
      allowFocus(focusTrap) {
        if (!this._listener) {
          return;
        }
        focusTrap._document.removeEventListener("focus", this._listener, true);
        this._listener = null;
      }
      /**
       * Refocuses the first element in the FocusTrap if the focus event target was outside
       * the FocusTrap.
       *
       * This is an event listener callback. The event listener is added in runOutsideAngular,
       * so all this code runs outside Angular as well.
       */
      _trapFocus(focusTrap, event) {
        const target = event.target;
        const focusTrapRoot = focusTrap._element;
        if (target && !focusTrapRoot.contains(target) && !target.closest?.("div.cdk-overlay-pane")) {
          setTimeout(() => {
            if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {
              focusTrap.focusFirstTabbableElement();
            }
          });
        }
      }
    };
    FOCUS_TRAP_INERT_STRATEGY = new InjectionToken("FOCUS_TRAP_INERT_STRATEGY");
    FocusTrapManager = class _FocusTrapManager {
      // A stack of the FocusTraps on the page. Only the FocusTrap at the
      // top of the stack is active.
      _focusTrapStack = [];
      /**
       * Disables the FocusTrap at the top of the stack, and then pushes
       * the new FocusTrap onto the stack.
       */
      register(focusTrap) {
        this._focusTrapStack = this._focusTrapStack.filter((ft2) => ft2 !== focusTrap);
        let stack = this._focusTrapStack;
        if (stack.length) {
          stack[stack.length - 1]._disable();
        }
        stack.push(focusTrap);
        focusTrap._enable();
      }
      /**
       * Removes the FocusTrap from the stack, and activates the
       * FocusTrap that is the new top of the stack.
       */
      deregister(focusTrap) {
        focusTrap._disable();
        const stack = this._focusTrapStack;
        const i2 = stack.indexOf(focusTrap);
        if (i2 !== -1) {
          stack.splice(i2, 1);
          if (stack.length) {
            stack[stack.length - 1]._enable();
          }
        }
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _FocusTrapManager, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _FocusTrapManager, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: FocusTrapManager, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }] });
    ConfigurableFocusTrapFactory = class _ConfigurableFocusTrapFactory {
      _checker = inject(InteractivityChecker);
      _ngZone = inject(NgZone);
      _focusTrapManager = inject(FocusTrapManager);
      _document = inject(DOCUMENT);
      _inertStrategy;
      _injector = inject(Injector);
      constructor() {
        const inertStrategy = inject(FOCUS_TRAP_INERT_STRATEGY, { optional: true });
        this._inertStrategy = inertStrategy || new EventListenerFocusTrapInertStrategy();
      }
      create(element, config = { defer: false }) {
        let configObject;
        if (typeof config === "boolean") {
          configObject = { defer: config };
        } else {
          configObject = config;
        }
        return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject, this._injector);
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ConfigurableFocusTrapFactory, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ConfigurableFocusTrapFactory, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: ConfigurableFocusTrapFactory, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
  }
});

// node_modules/@angular/cdk/fesm2022/directionality.mjs
function DIR_DOCUMENT_FACTORY() {
  return inject(DOCUMENT);
}
function _resolveDirectionality(rawValue) {
  const value = rawValue?.toLowerCase() || "";
  if (value === "auto" && typeof navigator !== "undefined" && navigator?.language) {
    return RTL_LOCALE_PATTERN.test(navigator.language) ? "rtl" : "ltr";
  }
  return value === "rtl" ? "rtl" : "ltr";
}
var DIR_DOCUMENT, RTL_LOCALE_PATTERN, Directionality;
var init_directionality = __esm({
  "node_modules/@angular/cdk/fesm2022/directionality.mjs"() {
    "use strict";
    init_core();
    init_core();
    DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
      providedIn: "root",
      factory: DIR_DOCUMENT_FACTORY
    });
    RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
    Directionality = class _Directionality {
      /** The current 'ltr' or 'rtl' value. */
      get value() {
        return this.valueSignal();
      }
      /**
       * The current 'ltr' or 'rtl' value.
       */
      valueSignal = signal("ltr", ...ngDevMode ? [{ debugName: "valueSignal" }] : []);
      /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */
      change = new EventEmitter();
      constructor() {
        const _document = inject(DIR_DOCUMENT, { optional: true });
        if (_document) {
          const bodyDir = _document.body ? _document.body.dir : null;
          const htmlDir = _document.documentElement ? _document.documentElement.dir : null;
          this.valueSignal.set(_resolveDirectionality(bodyDir || htmlDir || "ltr"));
        }
      }
      ngOnDestroy() {
        this.change.complete();
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _Directionality, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _Directionality, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: Directionality, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
  }
});

// node_modules/@angular/cdk/fesm2022/bidi.mjs
var Dir, BidiModule;
var init_bidi = __esm({
  "node_modules/@angular/cdk/fesm2022/bidi.mjs"() {
    "use strict";
    init_directionality();
    init_core();
    init_core();
    Dir = class _Dir {
      /** Whether the `value` has been set to its initial value. */
      _isInitialized = false;
      /** Direction as passed in by the consumer. */
      _rawDir;
      /** Event emitted when the direction changes. */
      change = new EventEmitter();
      /** @docs-private */
      get dir() {
        return this.valueSignal();
      }
      set dir(value) {
        const previousValue = this.valueSignal();
        this.valueSignal.set(_resolveDirectionality(value));
        this._rawDir = value;
        if (previousValue !== this.valueSignal() && this._isInitialized) {
          this.change.emit(this.valueSignal());
        }
      }
      /** Current layout direction of the element. */
      get value() {
        return this.dir;
      }
      valueSignal = signal("ltr", ...ngDevMode ? [{ debugName: "valueSignal" }] : []);
      /** Initialize once default value has been set. */
      ngAfterContentInit() {
        this._isInitialized = true;
      }
      ngOnDestroy() {
        this.change.complete();
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _Dir, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _Dir, isStandalone: true, selector: "[dir]", inputs: { dir: "dir" }, outputs: { change: "dirChange" }, host: { properties: { "attr.dir": "_rawDir" } }, providers: [{ provide: Directionality, useExisting: _Dir }], exportAs: ["dir"], ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: Dir, decorators: [{
      type: Directive,
      args: [{
        selector: "[dir]",
        providers: [{ provide: Directionality, useExisting: Dir }],
        host: { "[attr.dir]": "_rawDir" },
        exportAs: "dir"
      }]
    }], propDecorators: { change: [{
      type: Output,
      args: ["dirChange"]
    }], dir: [{
      type: Input
    }] } });
    BidiModule = class _BidiModule {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _BidiModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _BidiModule, imports: [Dir], exports: [Dir] });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _BidiModule });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: BidiModule, decorators: [{
      type: NgModule,
      args: [{
        imports: [Dir],
        exports: [Dir]
      }]
    }] });
  }
});

// node_modules/@angular/cdk/fesm2022/coercion.mjs
function coerceBooleanProperty(value) {
  return value != null && `${value}` !== "false";
}
var init_coercion = __esm({
  "node_modules/@angular/cdk/fesm2022/coercion.mjs"() {
    "use strict";
    init_element();
  }
});

// node_modules/@angular/cdk/fesm2022/scrolling2.mjs
function supportsScrollBehavior() {
  if (scrollBehaviorSupported == null) {
    if (typeof document !== "object" || !document || typeof Element !== "function" || !Element) {
      scrollBehaviorSupported = false;
      return scrollBehaviorSupported;
    }
    if (document.documentElement?.style && "scrollBehavior" in document.documentElement.style) {
      scrollBehaviorSupported = true;
    } else {
      const scrollToFunction = Element.prototype.scrollTo;
      if (scrollToFunction) {
        scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
      } else {
        scrollBehaviorSupported = false;
      }
    }
  }
  return scrollBehaviorSupported;
}
function getRtlScrollAxisType() {
  if (typeof document !== "object" || !document) {
    return RtlScrollAxisType.NORMAL;
  }
  if (rtlScrollAxisType == null) {
    const scrollContainer = document.createElement("div");
    const containerStyle = scrollContainer.style;
    scrollContainer.dir = "rtl";
    containerStyle.width = "1px";
    containerStyle.overflow = "auto";
    containerStyle.visibility = "hidden";
    containerStyle.pointerEvents = "none";
    containerStyle.position = "absolute";
    const content = document.createElement("div");
    const contentStyle = content.style;
    contentStyle.width = "2px";
    contentStyle.height = "1px";
    scrollContainer.appendChild(content);
    document.body.appendChild(scrollContainer);
    rtlScrollAxisType = RtlScrollAxisType.NORMAL;
    if (scrollContainer.scrollLeft === 0) {
      scrollContainer.scrollLeft = 1;
      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;
    }
    scrollContainer.remove();
  }
  return rtlScrollAxisType;
}
var RtlScrollAxisType, rtlScrollAxisType, scrollBehaviorSupported;
var init_scrolling2 = __esm({
  "node_modules/@angular/cdk/fesm2022/scrolling2.mjs"() {
    "use strict";
    (function(RtlScrollAxisType2) {
      RtlScrollAxisType2[RtlScrollAxisType2["NORMAL"] = 0] = "NORMAL";
      RtlScrollAxisType2[RtlScrollAxisType2["NEGATED"] = 1] = "NEGATED";
      RtlScrollAxisType2[RtlScrollAxisType2["INVERTED"] = 2] = "INVERTED";
    })(RtlScrollAxisType || (RtlScrollAxisType = {}));
  }
});

// node_modules/@angular/cdk/fesm2022/platform.mjs
var PlatformModule;
var init_platform = __esm({
  "node_modules/@angular/cdk/fesm2022/platform.mjs"() {
    "use strict";
    init_platform2();
    init_core();
    init_core();
    init_passive_listeners();
    init_shadow_dom();
    PlatformModule = class _PlatformModule {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _PlatformModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _PlatformModule });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _PlatformModule });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: PlatformModule, decorators: [{
      type: NgModule,
      args: [{}]
    }] });
  }
});

// node_modules/@angular/cdk/fesm2022/data-source.mjs
function isDataSource(value) {
  return value && typeof value.connect === "function" && !(value instanceof ConnectableObservable);
}
var DataSource;
var init_data_source = __esm({
  "node_modules/@angular/cdk/fesm2022/data-source.mjs"() {
    "use strict";
    init_esm();
    DataSource = class {
    };
  }
});

// node_modules/@angular/cdk/fesm2022/recycle-view-repeater-strategy.mjs
var ArrayDataSource, _ViewRepeaterOperation, _VIEW_REPEATER_STRATEGY, _RecycleViewRepeaterStrategy;
var init_recycle_view_repeater_strategy = __esm({
  "node_modules/@angular/cdk/fesm2022/recycle-view-repeater-strategy.mjs"() {
    "use strict";
    init_esm();
    init_data_source();
    init_core();
    ArrayDataSource = class extends DataSource {
      _data;
      constructor(_data) {
        super();
        this._data = _data;
      }
      connect() {
        return isObservable(this._data) ? this._data : of(this._data);
      }
      disconnect() {
      }
    };
    (function(_ViewRepeaterOperation2) {
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["REPLACED"] = 0] = "REPLACED";
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["INSERTED"] = 1] = "INSERTED";
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["MOVED"] = 2] = "MOVED";
      _ViewRepeaterOperation2[_ViewRepeaterOperation2["REMOVED"] = 3] = "REMOVED";
    })(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));
    _VIEW_REPEATER_STRATEGY = new InjectionToken("_ViewRepeater");
    _RecycleViewRepeaterStrategy = class {
      /**
       * The size of the cache used to store unused views.
       * Setting the cache size to `0` will disable caching. Defaults to 20 views.
       */
      viewCacheSize = 20;
      /**
       * View cache that stores embedded view instances that have been previously stamped out,
       * but don't are not currently rendered. The view repeater will reuse these views rather than
       * creating brand new ones.
       *
       * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.
       */
      _viewCache = [];
      /** Apply changes to the DOM. */
      applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
          let view;
          let operation;
          if (record.previousIndex == null) {
            const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);
            view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
            operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;
          } else if (currentIndex == null) {
            this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
            operation = _ViewRepeaterOperation.REMOVED;
          } else {
            view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
            operation = _ViewRepeaterOperation.MOVED;
          }
          if (itemViewChanged) {
            itemViewChanged({
              context: view?.context,
              operation,
              record
            });
          }
        });
      }
      detach() {
        for (const view of this._viewCache) {
          view.destroy();
        }
        this._viewCache = [];
      }
      /**
       * Inserts a view for a new item, either from the cache or by creating a new
       * one. Returns `undefined` if the item was inserted into a cached view.
       */
      _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
        if (cachedView) {
          cachedView.context.$implicit = value;
          return void 0;
        }
        const viewArgs = viewArgsFactory();
        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
      }
      /** Detaches the view at the given index and inserts into the view cache. */
      _detachAndCacheView(index, viewContainerRef) {
        const detachedView = viewContainerRef.detach(index);
        this._maybeCacheView(detachedView, viewContainerRef);
      }
      /** Moves view at the previous index to the current index. */
      _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
        const view = viewContainerRef.get(adjustedPreviousIndex);
        viewContainerRef.move(view, currentIndex);
        view.context.$implicit = value;
        return view;
      }
      /**
       * Cache the given detached view. If the cache is full, the view will be
       * destroyed.
       */
      _maybeCacheView(view, viewContainerRef) {
        if (this._viewCache.length < this.viewCacheSize) {
          this._viewCache.push(view);
        } else {
          const index = viewContainerRef.indexOf(view);
          if (index === -1) {
            view.destroy();
          } else {
            viewContainerRef.remove(index);
          }
        }
      }
      /** Inserts a recycled view from the cache at the given index. */
      _insertViewFromCache(index, viewContainerRef) {
        const cachedView = this._viewCache.pop();
        if (cachedView) {
          viewContainerRef.insert(cachedView, index);
        }
        return cachedView || null;
      }
    };
  }
});

// node_modules/@angular/cdk/fesm2022/scrolling.mjs
function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
  return fixedSizeDir._scrollStrategy;
}
function rangesEqual(r1, r2) {
  return r1.start == r2.start && r1.end == r2.end;
}
function getOffset(orientation, direction, node) {
  const el = node;
  if (!el.getBoundingClientRect) {
    return 0;
  }
  const rect = el.getBoundingClientRect();
  if (orientation === "horizontal") {
    return direction === "start" ? rect.left : rect.right;
  }
  return direction === "start" ? rect.top : rect.bottom;
}
var VIRTUAL_SCROLL_STRATEGY, FixedSizeVirtualScrollStrategy, CdkFixedSizeVirtualScroll, DEFAULT_SCROLL_TIME, ScrollDispatcher, CdkScrollable, DEFAULT_RESIZE_TIME, ViewportRuler, VIRTUAL_SCROLLABLE, CdkVirtualScrollable, SCROLL_SCHEDULER, CdkVirtualScrollViewport, CdkVirtualForOf, CdkVirtualScrollableElement, CdkVirtualScrollableWindow, CdkScrollableModule, ScrollingModule;
var init_scrolling = __esm({
  "node_modules/@angular/cdk/fesm2022/scrolling.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_esm();
    init_operators();
    init_element();
    init_platform2();
    init_directionality();
    init_scrolling2();
    init_bidi();
    init_recycle_view_repeater_strategy();
    init_data_source();
    VIRTUAL_SCROLL_STRATEGY = new InjectionToken("VIRTUAL_SCROLL_STRATEGY");
    FixedSizeVirtualScrollStrategy = class {
      _scrolledIndexChange = new Subject();
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());
      /** The attached viewport. */
      _viewport = null;
      /** The size of the items in the virtually scrolling list. */
      _itemSize;
      /** The minimum amount of buffer rendered beyond the viewport (in pixels). */
      _minBufferPx;
      /** The number of buffer items to render beyond the edge of the viewport (in pixels). */
      _maxBufferPx;
      /**
       * @param itemSize The size of the items in the virtually scrolling list.
       * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
       * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
       */
      constructor(itemSize, minBufferPx, maxBufferPx) {
        this._itemSize = itemSize;
        this._minBufferPx = minBufferPx;
        this._maxBufferPx = maxBufferPx;
      }
      /**
       * Attaches this scroll strategy to a viewport.
       * @param viewport The viewport to attach this strategy to.
       */
      attach(viewport) {
        this._viewport = viewport;
        this._updateTotalContentSize();
        this._updateRenderedRange();
      }
      /** Detaches this scroll strategy from the currently attached viewport. */
      detach() {
        this._scrolledIndexChange.complete();
        this._viewport = null;
      }
      /**
       * Update the item size and buffer size.
       * @param itemSize The size of the items in the virtually scrolling list.
       * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
       * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
       */
      updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
        if (maxBufferPx < minBufferPx && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error("CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx");
        }
        this._itemSize = itemSize;
        this._minBufferPx = minBufferPx;
        this._maxBufferPx = maxBufferPx;
        this._updateTotalContentSize();
        this._updateRenderedRange();
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onContentScrolled() {
        this._updateRenderedRange();
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onDataLengthChanged() {
        this._updateTotalContentSize();
        this._updateRenderedRange();
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onContentRendered() {
      }
      /** @docs-private Implemented as part of VirtualScrollStrategy. */
      onRenderedOffsetChanged() {
      }
      /**
       * Scroll to the offset for the given index.
       * @param index The index of the element to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling.
       */
      scrollToIndex(index, behavior) {
        if (this._viewport) {
          this._viewport.scrollToOffset(index * this._itemSize, behavior);
        }
      }
      /** Update the viewport's total content size. */
      _updateTotalContentSize() {
        if (!this._viewport) {
          return;
        }
        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
      }
      /** Update the viewport's rendered range. */
      _updateRenderedRange() {
        if (!this._viewport) {
          return;
        }
        const renderedRange = this._viewport.getRenderedRange();
        const newRange = { start: renderedRange.start, end: renderedRange.end };
        const viewportSize = this._viewport.getViewportSize();
        const dataLength = this._viewport.getDataLength();
        let scrollOffset = this._viewport.measureScrollOffset();
        let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
        if (newRange.end > dataLength) {
          const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
          const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
          if (firstVisibleIndex != newVisibleIndex) {
            firstVisibleIndex = newVisibleIndex;
            scrollOffset = newVisibleIndex * this._itemSize;
            newRange.start = Math.floor(firstVisibleIndex);
          }
          newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
        }
        const startBuffer = scrollOffset - newRange.start * this._itemSize;
        if (startBuffer < this._minBufferPx && newRange.start != 0) {
          const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
          newRange.start = Math.max(0, newRange.start - expandStart);
          newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
        } else {
          const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
          if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
            const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
            if (expandEnd > 0) {
              newRange.end = Math.min(dataLength, newRange.end + expandEnd);
              newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
            }
          }
        }
        this._viewport.setRenderedRange(newRange);
        this._viewport.setRenderedContentOffset(Math.round(this._itemSize * newRange.start));
        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
      }
    };
    CdkFixedSizeVirtualScroll = class _CdkFixedSizeVirtualScroll {
      /** The size of the items in the list (in pixels). */
      get itemSize() {
        return this._itemSize;
      }
      set itemSize(value) {
        this._itemSize = coerceNumberProperty(value);
      }
      _itemSize = 20;
      /**
       * The minimum amount of buffer rendered beyond the viewport (in pixels).
       * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
       */
      get minBufferPx() {
        return this._minBufferPx;
      }
      set minBufferPx(value) {
        this._minBufferPx = coerceNumberProperty(value);
      }
      _minBufferPx = 100;
      /**
       * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
       */
      get maxBufferPx() {
        return this._maxBufferPx;
      }
      set maxBufferPx(value) {
        this._maxBufferPx = coerceNumberProperty(value);
      }
      _maxBufferPx = 200;
      /** The scroll strategy used by this directive. */
      _scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
      ngOnChanges() {
        this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkFixedSizeVirtualScroll, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _CdkFixedSizeVirtualScroll, isStandalone: true, selector: "cdk-virtual-scroll-viewport[itemSize]", inputs: { itemSize: "itemSize", minBufferPx: "minBufferPx", maxBufferPx: "maxBufferPx" }, providers: [
        {
          provide: VIRTUAL_SCROLL_STRATEGY,
          useFactory: _fixedSizeVirtualScrollStrategyFactory,
          deps: [forwardRef(() => _CdkFixedSizeVirtualScroll)]
        }
      ], usesOnChanges: true, ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkFixedSizeVirtualScroll, decorators: [{
      type: Directive,
      args: [{
        selector: "cdk-virtual-scroll-viewport[itemSize]",
        providers: [
          {
            provide: VIRTUAL_SCROLL_STRATEGY,
            useFactory: _fixedSizeVirtualScrollStrategyFactory,
            deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]
          }
        ]
      }]
    }], propDecorators: { itemSize: [{
      type: Input
    }], minBufferPx: [{
      type: Input
    }], maxBufferPx: [{
      type: Input
    }] } });
    DEFAULT_SCROLL_TIME = 20;
    ScrollDispatcher = class _ScrollDispatcher {
      _ngZone = inject(NgZone);
      _platform = inject(Platform);
      _renderer = inject(RendererFactory2).createRenderer(null, null);
      _cleanupGlobalListener;
      constructor() {
      }
      /** Subject for notifying that a registered scrollable reference element has been scrolled. */
      _scrolled = new Subject();
      /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */
      _scrolledCount = 0;
      /**
       * Map of all the scrollable references that are registered with the service and their
       * scroll event subscriptions.
       */
      scrollContainers = /* @__PURE__ */ new Map();
      /**
       * Registers a scrollable instance with the service and listens for its scrolled events. When the
       * scrollable is scrolled, the service emits the event to its scrolled observable.
       * @param scrollable Scrollable instance to be registered.
       */
      register(scrollable) {
        if (!this.scrollContainers.has(scrollable)) {
          this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
        }
      }
      /**
       * De-registers a Scrollable reference and unsubscribes from its scroll event observable.
       * @param scrollable Scrollable instance to be deregistered.
       */
      deregister(scrollable) {
        const scrollableReference = this.scrollContainers.get(scrollable);
        if (scrollableReference) {
          scrollableReference.unsubscribe();
          this.scrollContainers.delete(scrollable);
        }
      }
      /**
       * Returns an observable that emits an event whenever any of the registered Scrollable
       * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
       * to override the default "throttle" time.
       *
       * **Note:** in order to avoid hitting change detection for every scroll event,
       * all of the events emitted from this stream will be run outside the Angular zone.
       * If you need to update any data bindings as a result of a scroll event, you have
       * to run the callback using `NgZone.run`.
       */
      scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
        if (!this._platform.isBrowser) {
          return of();
        }
        return new Observable((observer) => {
          if (!this._cleanupGlobalListener) {
            this._cleanupGlobalListener = this._ngZone.runOutsideAngular(() => this._renderer.listen("document", "scroll", () => this._scrolled.next()));
          }
          const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
          this._scrolledCount++;
          return () => {
            subscription.unsubscribe();
            this._scrolledCount--;
            if (!this._scrolledCount) {
              this._cleanupGlobalListener?.();
              this._cleanupGlobalListener = void 0;
            }
          };
        });
      }
      ngOnDestroy() {
        this._cleanupGlobalListener?.();
        this._cleanupGlobalListener = void 0;
        this.scrollContainers.forEach((_3, container) => this.deregister(container));
        this._scrolled.complete();
      }
      /**
       * Returns an observable that emits whenever any of the
       * scrollable ancestors of an element are scrolled.
       * @param elementOrElementRef Element whose ancestors to listen for.
       * @param auditTimeInMs Time to throttle the scroll events.
       */
      ancestorScrolled(elementOrElementRef, auditTimeInMs) {
        const ancestors = this.getAncestorScrollContainers(elementOrElementRef);
        return this.scrolled(auditTimeInMs).pipe(filter((target) => !target || ancestors.indexOf(target) > -1));
      }
      /** Returns all registered Scrollables that contain the provided element. */
      getAncestorScrollContainers(elementOrElementRef) {
        const scrollingContainers = [];
        this.scrollContainers.forEach((_subscription, scrollable) => {
          if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {
            scrollingContainers.push(scrollable);
          }
        });
        return scrollingContainers;
      }
      /** Returns true if the element is contained within the provided Scrollable. */
      _scrollableContainsElement(scrollable, elementOrElementRef) {
        let element = coerceElement(elementOrElementRef);
        let scrollableElement = scrollable.getElementRef().nativeElement;
        do {
          if (element == scrollableElement) {
            return true;
          }
        } while (element = element.parentElement);
        return false;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ScrollDispatcher, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ScrollDispatcher, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: ScrollDispatcher, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
    CdkScrollable = class _CdkScrollable {
      elementRef = inject(ElementRef);
      scrollDispatcher = inject(ScrollDispatcher);
      ngZone = inject(NgZone);
      dir = inject(Directionality, { optional: true });
      _scrollElement = this.elementRef.nativeElement;
      _destroyed = new Subject();
      _renderer = inject(Renderer2);
      _cleanupScroll;
      _elementScrolled = new Subject();
      constructor() {
      }
      ngOnInit() {
        this._cleanupScroll = this.ngZone.runOutsideAngular(() => this._renderer.listen(this._scrollElement, "scroll", (event) => this._elementScrolled.next(event)));
        this.scrollDispatcher.register(this);
      }
      ngOnDestroy() {
        this._cleanupScroll?.();
        this._elementScrolled.complete();
        this.scrollDispatcher.deregister(this);
        this._destroyed.next();
        this._destroyed.complete();
      }
      /** Returns observable that emits when a scroll event is fired on the host element. */
      elementScrolled() {
        return this._elementScrolled;
      }
      /** Gets the ElementRef for the viewport. */
      getElementRef() {
        return this.elementRef;
      }
      /**
       * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
       * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param options specified the offsets to scroll to.
       */
      scrollTo(options) {
        const el = this.elementRef.nativeElement;
        const isRtl = this.dir && this.dir.value == "rtl";
        if (options.left == null) {
          options.left = isRtl ? options.end : options.start;
        }
        if (options.right == null) {
          options.right = isRtl ? options.start : options.end;
        }
        if (options.bottom != null) {
          options.top = el.scrollHeight - el.clientHeight - options.bottom;
        }
        if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {
          if (options.left != null) {
            options.right = el.scrollWidth - el.clientWidth - options.left;
          }
          if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
            options.left = options.right;
          } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
            options.left = options.right ? -options.right : options.right;
          }
        } else {
          if (options.right != null) {
            options.left = el.scrollWidth - el.clientWidth - options.right;
          }
        }
        this._applyScrollToOptions(options);
      }
      _applyScrollToOptions(options) {
        const el = this.elementRef.nativeElement;
        if (supportsScrollBehavior()) {
          el.scrollTo(options);
        } else {
          if (options.top != null) {
            el.scrollTop = options.top;
          }
          if (options.left != null) {
            el.scrollLeft = options.left;
          }
        }
      }
      /**
       * Measures the scroll offset relative to the specified edge of the viewport. This method can be
       * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
       * about what scrollLeft means in RTL. The values returned by this method are normalized such that
       * left and right always refer to the left and right side of the scrolling container irrespective
       * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
       * in an RTL context.
       * @param from The edge to measure from.
       */
      measureScrollOffset(from) {
        const LEFT = "left";
        const RIGHT = "right";
        const el = this.elementRef.nativeElement;
        if (from == "top") {
          return el.scrollTop;
        }
        if (from == "bottom") {
          return el.scrollHeight - el.clientHeight - el.scrollTop;
        }
        const isRtl = this.dir && this.dir.value == "rtl";
        if (from == "start") {
          from = isRtl ? RIGHT : LEFT;
        } else if (from == "end") {
          from = isRtl ? LEFT : RIGHT;
        }
        if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
          if (from == LEFT) {
            return el.scrollWidth - el.clientWidth - el.scrollLeft;
          } else {
            return el.scrollLeft;
          }
        } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
          if (from == LEFT) {
            return el.scrollLeft + el.scrollWidth - el.clientWidth;
          } else {
            return -el.scrollLeft;
          }
        } else {
          if (from == LEFT) {
            return el.scrollLeft;
          } else {
            return el.scrollWidth - el.clientWidth - el.scrollLeft;
          }
        }
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkScrollable, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _CdkScrollable, isStandalone: true, selector: "[cdk-scrollable], [cdkScrollable]", ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkScrollable, decorators: [{
      type: Directive,
      args: [{
        selector: "[cdk-scrollable], [cdkScrollable]"
      }]
    }], ctorParameters: () => [] });
    DEFAULT_RESIZE_TIME = 20;
    ViewportRuler = class _ViewportRuler {
      _platform = inject(Platform);
      _listeners;
      /** Cached viewport dimensions. */
      _viewportSize;
      /** Stream of viewport change events. */
      _change = new Subject();
      /** Used to reference correct document/window */
      _document = inject(DOCUMENT);
      constructor() {
        const ngZone = inject(NgZone);
        const renderer = inject(RendererFactory2).createRenderer(null, null);
        ngZone.runOutsideAngular(() => {
          if (this._platform.isBrowser) {
            const changeListener = (event) => this._change.next(event);
            this._listeners = [
              renderer.listen("window", "resize", changeListener),
              renderer.listen("window", "orientationchange", changeListener)
            ];
          }
          this.change().subscribe(() => this._viewportSize = null);
        });
      }
      ngOnDestroy() {
        this._listeners?.forEach((cleanup) => cleanup());
        this._change.complete();
      }
      /** Returns the viewport's width and height. */
      getViewportSize() {
        if (!this._viewportSize) {
          this._updateViewportSize();
        }
        const output = { width: this._viewportSize.width, height: this._viewportSize.height };
        if (!this._platform.isBrowser) {
          this._viewportSize = null;
        }
        return output;
      }
      /** Gets a DOMRect for the viewport's bounds. */
      getViewportRect() {
        const scrollPosition = this.getViewportScrollPosition();
        const { width, height } = this.getViewportSize();
        return {
          top: scrollPosition.top,
          left: scrollPosition.left,
          bottom: scrollPosition.top + height,
          right: scrollPosition.left + width,
          height,
          width
        };
      }
      /** Gets the (top, left) scroll position of the viewport. */
      getViewportScrollPosition() {
        if (!this._platform.isBrowser) {
          return { top: 0, left: 0 };
        }
        const document2 = this._document;
        const window2 = this._getWindow();
        const documentElement = document2.documentElement;
        const documentRect = documentElement.getBoundingClientRect();
        const top = -documentRect.top || document2.body.scrollTop || window2.scrollY || documentElement.scrollTop || 0;
        const left = -documentRect.left || document2.body.scrollLeft || window2.scrollX || documentElement.scrollLeft || 0;
        return { top, left };
      }
      /**
       * Returns a stream that emits whenever the size of the viewport changes.
       * This stream emits outside of the Angular zone.
       * @param throttleTime Time in milliseconds to throttle the stream.
       */
      change(throttleTime = DEFAULT_RESIZE_TIME) {
        return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;
      }
      /** Use defaultView of injected document if available or fallback to global window reference */
      _getWindow() {
        return this._document.defaultView || window;
      }
      /** Updates the cached viewport size. */
      _updateViewportSize() {
        const window2 = this._getWindow();
        this._viewportSize = this._platform.isBrowser ? { width: window2.innerWidth, height: window2.innerHeight } : { width: 0, height: 0 };
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ViewportRuler, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ViewportRuler, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: ViewportRuler, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
    VIRTUAL_SCROLLABLE = new InjectionToken("VIRTUAL_SCROLLABLE");
    CdkVirtualScrollable = class _CdkVirtualScrollable extends CdkScrollable {
      constructor() {
        super();
      }
      /**
       * Measure the viewport size for the provided orientation.
       *
       * @param orientation The orientation to measure the size from.
       */
      measureViewportSize(orientation) {
        const viewportEl = this.elementRef.nativeElement;
        return orientation === "horizontal" ? viewportEl.clientWidth : viewportEl.clientHeight;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkVirtualScrollable, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _CdkVirtualScrollable, isStandalone: true, usesInheritance: true, ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkVirtualScrollable, decorators: [{
      type: Directive
    }], ctorParameters: () => [] });
    SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
    CdkVirtualScrollViewport = class _CdkVirtualScrollViewport extends CdkVirtualScrollable {
      elementRef = inject(ElementRef);
      _changeDetectorRef = inject(ChangeDetectorRef);
      _scrollStrategy = inject(VIRTUAL_SCROLL_STRATEGY, {
        optional: true
      });
      scrollable = inject(VIRTUAL_SCROLLABLE, { optional: true });
      _platform = inject(Platform);
      /** Emits when the viewport is detached from a CdkVirtualForOf. */
      _detachedSubject = new Subject();
      /** Emits when the rendered range changes. */
      _renderedRangeSubject = new Subject();
      /** The direction the viewport scrolls. */
      get orientation() {
        return this._orientation;
      }
      set orientation(orientation) {
        if (this._orientation !== orientation) {
          this._orientation = orientation;
          this._calculateSpacerSize();
        }
      }
      _orientation = "vertical";
      /**
       * Whether rendered items should persist in the DOM after scrolling out of view. By default, items
       * will be removed.
       */
      appendOnly = false;
      // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll
      // strategy lazily (i.e. only if the user is actually listening to the events). We do this because
      // depending on how the strategy calculates the scrolled index, it may come at a cost to
      // performance.
      /** Emits when the index of the first element visible in the viewport changes. */
      scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe((index) => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));
      /** The element that wraps the rendered content. */
      _contentWrapper;
      /** A stream that emits whenever the rendered range changes. */
      renderedRangeStream = this._renderedRangeSubject;
      /**
       * The total size of all content (in pixels), including content that is not currently rendered.
       */
      _totalContentSize = 0;
      /** A string representing the `style.width` property value to be used for the spacer element. */
      _totalContentWidth = signal("", ...ngDevMode ? [{ debugName: "_totalContentWidth" }] : []);
      /** A string representing the `style.height` property value to be used for the spacer element. */
      _totalContentHeight = signal("", ...ngDevMode ? [{ debugName: "_totalContentHeight" }] : []);
      /**
       * The CSS transform applied to the rendered subset of items so that they appear within the bounds
       * of the visible viewport.
       */
      _renderedContentTransform;
      /** The currently rendered range of indices. */
      _renderedRange = { start: 0, end: 0 };
      /** The length of the data bound to this viewport (in number of items). */
      _dataLength = 0;
      /** The size of the viewport (in pixels). */
      _viewportSize = 0;
      /** the currently attached CdkVirtualScrollRepeater. */
      _forOf;
      /** The last rendered content offset that was set. */
      _renderedContentOffset = 0;
      /**
       * Whether the last rendered content offset was to the end of the content (and therefore needs to
       * be rewritten as an offset to the start of the content).
       */
      _renderedContentOffsetNeedsRewrite = false;
      _changeDetectionNeeded = signal(false, ...ngDevMode ? [{ debugName: "_changeDetectionNeeded" }] : []);
      /** A list of functions to run after the next change detection cycle. */
      _runAfterChangeDetection = [];
      /** Subscription to changes in the viewport size. */
      _viewportChanges = Subscription.EMPTY;
      _injector = inject(Injector);
      _isDestroyed = false;
      constructor() {
        super();
        const viewportRuler = inject(ViewportRuler);
        if (!this._scrollStrategy && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
        }
        this._viewportChanges = viewportRuler.change().subscribe(() => {
          this.checkViewportSize();
        });
        if (!this.scrollable) {
          this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable");
          this.scrollable = this;
        }
        const ref = effect(() => {
          if (this._changeDetectionNeeded()) {
            this._doChangeDetection();
          }
        }, ...ngDevMode ? [{ debugName: "ref", injector: inject(ApplicationRef).injector }] : [
          // Using ApplicationRef injector is important here because we want this to be a root
          // effect that runs before change detection of any application views (since we're depending on markForCheck marking parents dirty)
          { injector: inject(ApplicationRef).injector }
        ]);
        inject(DestroyRef).onDestroy(() => void ref.destroy());
      }
      ngOnInit() {
        if (!this._platform.isBrowser) {
          return;
        }
        if (this.scrollable === this) {
          super.ngOnInit();
        }
        this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
          this._measureViewportSize();
          this._scrollStrategy.attach(this);
          this.scrollable.elementScrolled().pipe(
            // Start off with a fake scroll event so we properly detect our initial position.
            startWith(null),
            // Collect multiple events into one until the next animation frame. This way if
            // there are multiple scroll events in the same frame we only need to recheck
            // our layout once.
            auditTime(0, SCROLL_SCHEDULER),
            // Usually `elementScrolled` is completed when the scrollable is destroyed, but
            // that may not be the case if a `CdkVirtualScrollableElement` is used so we have
            // to unsubscribe here just in case.
            takeUntil(this._destroyed)
          ).subscribe(() => this._scrollStrategy.onContentScrolled());
          this._markChangeDetectionNeeded();
        }));
      }
      ngOnDestroy() {
        this.detach();
        this._scrollStrategy.detach();
        this._renderedRangeSubject.complete();
        this._detachedSubject.complete();
        this._viewportChanges.unsubscribe();
        this._isDestroyed = true;
        super.ngOnDestroy();
      }
      /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */
      attach(forOf) {
        if (this._forOf && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error("CdkVirtualScrollViewport is already attached.");
        }
        this.ngZone.runOutsideAngular(() => {
          this._forOf = forOf;
          this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((data) => {
            const newLength = data.length;
            if (newLength !== this._dataLength) {
              this._dataLength = newLength;
              this._scrollStrategy.onDataLengthChanged();
            }
            this._doChangeDetection();
          });
        });
      }
      /** Detaches the current `CdkVirtualForOf`. */
      detach() {
        this._forOf = null;
        this._detachedSubject.next();
      }
      /** Gets the length of the data bound to this viewport (in number of items). */
      getDataLength() {
        return this._dataLength;
      }
      /** Gets the size of the viewport (in pixels). */
      getViewportSize() {
        return this._viewportSize;
      }
      // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
      // cycle happens. I'm being careful to only call it after the render cycle is complete and before
      // setting it to something else, but its error prone and should probably be split into
      // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
      /** Get the current rendered range of items. */
      getRenderedRange() {
        return this._renderedRange;
      }
      measureBoundingClientRectWithScrollOffset(from) {
        return this.getElementRef().nativeElement.getBoundingClientRect()[from];
      }
      /**
       * Sets the total size of all content (in pixels), including content that is not currently
       * rendered.
       */
      setTotalContentSize(size) {
        if (this._totalContentSize !== size) {
          this._totalContentSize = size;
          this._calculateSpacerSize();
          this._markChangeDetectionNeeded();
        }
      }
      /** Sets the currently rendered range of indices. */
      setRenderedRange(range) {
        if (!rangesEqual(this._renderedRange, range)) {
          if (this.appendOnly) {
            range = { start: 0, end: Math.max(this._renderedRange.end, range.end) };
          }
          this._renderedRangeSubject.next(this._renderedRange = range);
          this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());
        }
      }
      /**
       * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
       */
      getOffsetToRenderedContentStart() {
        return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
      }
      /**
       * Sets the offset from the start of the viewport to either the start or end of the rendered data
       * (in pixels).
       */
      setRenderedContentOffset(offset, to = "to-start") {
        offset = this.appendOnly && to === "to-start" ? 0 : offset;
        const isRtl = this.dir && this.dir.value == "rtl";
        const isHorizontal = this.orientation == "horizontal";
        const axis = isHorizontal ? "X" : "Y";
        const axisDirection = isHorizontal && isRtl ? -1 : 1;
        let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;
        this._renderedContentOffset = offset;
        if (to === "to-end") {
          transform += ` translate${axis}(-100%)`;
          this._renderedContentOffsetNeedsRewrite = true;
        }
        if (this._renderedContentTransform != transform) {
          this._renderedContentTransform = transform;
          this._markChangeDetectionNeeded(() => {
            if (this._renderedContentOffsetNeedsRewrite) {
              this._renderedContentOffset -= this.measureRenderedContentSize();
              this._renderedContentOffsetNeedsRewrite = false;
              this.setRenderedContentOffset(this._renderedContentOffset);
            } else {
              this._scrollStrategy.onRenderedOffsetChanged();
            }
          });
        }
      }
      /**
       * Scrolls to the given offset from the start of the viewport. Please note that this is not always
       * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
       * direction, this would be the equivalent of setting a fictional `scrollRight` property.
       * @param offset The offset to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       */
      scrollToOffset(offset, behavior = "auto") {
        const options = { behavior };
        if (this.orientation === "horizontal") {
          options.start = offset;
        } else {
          options.top = offset;
        }
        this.scrollable.scrollTo(options);
      }
      /**
       * Scrolls to the offset for the given index.
       * @param index The index of the element to scroll to.
       * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
       */
      scrollToIndex(index, behavior = "auto") {
        this._scrollStrategy.scrollToIndex(index, behavior);
      }
      /**
       * Gets the current scroll offset from the start of the scrollable (in pixels).
       * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
       *     in horizontal mode.
       */
      measureScrollOffset(from) {
        let measureScrollOffset;
        if (this.scrollable == this) {
          measureScrollOffset = (_from) => super.measureScrollOffset(_from);
        } else {
          measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);
        }
        return Math.max(0, measureScrollOffset(from ?? (this.orientation === "horizontal" ? "start" : "top")) - this.measureViewportOffset());
      }
      /**
       * Measures the offset of the viewport from the scrolling container
       * @param from The edge to measure from.
       */
      measureViewportOffset(from) {
        let fromRect;
        const LEFT = "left";
        const RIGHT = "right";
        const isRtl = this.dir?.value == "rtl";
        if (from == "start") {
          fromRect = isRtl ? RIGHT : LEFT;
        } else if (from == "end") {
          fromRect = isRtl ? LEFT : RIGHT;
        } else if (from) {
          fromRect = from;
        } else {
          fromRect = this.orientation === "horizontal" ? "left" : "top";
        }
        const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);
        const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];
        return viewportClientRect - scrollerClientRect;
      }
      /** Measure the combined size of all of the rendered items. */
      measureRenderedContentSize() {
        const contentEl = this._contentWrapper.nativeElement;
        return this.orientation === "horizontal" ? contentEl.offsetWidth : contentEl.offsetHeight;
      }
      /**
       * Measure the total combined size of the given range. Throws if the range includes items that are
       * not rendered.
       */
      measureRangeSize(range) {
        if (!this._forOf) {
          return 0;
        }
        return this._forOf.measureRangeSize(range, this.orientation);
      }
      /** Update the viewport dimensions and re-render. */
      checkViewportSize() {
        this._measureViewportSize();
        this._scrollStrategy.onDataLengthChanged();
      }
      /** Measure the viewport size. */
      _measureViewportSize() {
        this._viewportSize = this.scrollable.measureViewportSize(this.orientation);
      }
      /** Queue up change detection to run. */
      _markChangeDetectionNeeded(runAfter) {
        if (runAfter) {
          this._runAfterChangeDetection.push(runAfter);
        }
        if (untracked(this._changeDetectionNeeded)) {
          return;
        }
        this.ngZone.runOutsideAngular(() => {
          Promise.resolve().then(() => {
            this.ngZone.run(() => {
              this._changeDetectionNeeded.set(true);
            });
          });
        });
      }
      /** Run change detection. */
      _doChangeDetection() {
        if (this._isDestroyed) {
          return;
        }
        this.ngZone.run(() => {
          this._changeDetectorRef.markForCheck();
          this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
          afterNextRender(() => {
            this._changeDetectionNeeded.set(false);
            const runAfterChangeDetection = this._runAfterChangeDetection;
            this._runAfterChangeDetection = [];
            for (const fn of runAfterChangeDetection) {
              fn();
            }
          }, { injector: this._injector });
        });
      }
      /** Calculates the `style.width` and `style.height` for the spacer element. */
      _calculateSpacerSize() {
        this._totalContentHeight.set(this.orientation === "horizontal" ? "" : `${this._totalContentSize}px`);
        this._totalContentWidth.set(this.orientation === "horizontal" ? `${this._totalContentSize}px` : "");
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkVirtualScrollViewport, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "16.1.0", version: "20.2.0-next.2", type: _CdkVirtualScrollViewport, isStandalone: true, selector: "cdk-virtual-scroll-viewport", inputs: { orientation: "orientation", appendOnly: ["appendOnly", "appendOnly", booleanAttribute] }, outputs: { scrolledIndexChange: "scrolledIndexChange" }, host: { properties: { "class.cdk-virtual-scroll-orientation-horizontal": 'orientation === "horizontal"', "class.cdk-virtual-scroll-orientation-vertical": 'orientation !== "horizontal"' }, classAttribute: "cdk-virtual-scroll-viewport" }, providers: [
        {
          provide: CdkScrollable,
          useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
          deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], _CdkVirtualScrollViewport]
        }
      ], viewQueries: [{ propertyName: "_contentWrapper", first: true, predicate: ["contentWrapper"], descendants: true, static: true }], usesInheritance: true, ngImport: core_exports, template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth()" [style.height]="_totalContentHeight()"></div>\n', styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkVirtualScrollViewport, decorators: [{
      type: Component,
      args: [{ selector: "cdk-virtual-scroll-viewport", host: {
        "class": "cdk-virtual-scroll-viewport",
        "[class.cdk-virtual-scroll-orientation-horizontal]": 'orientation === "horizontal"',
        "[class.cdk-virtual-scroll-orientation-vertical]": 'orientation !== "horizontal"'
      }, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, providers: [
        {
          provide: CdkScrollable,
          useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
          deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]
        }
      ], template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth()" [style.height]="_totalContentHeight()"></div>\n', styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\n"] }]
    }], ctorParameters: () => [], propDecorators: { orientation: [{
      type: Input
    }], appendOnly: [{
      type: Input,
      args: [{ transform: booleanAttribute }]
    }], scrolledIndexChange: [{
      type: Output
    }], _contentWrapper: [{
      type: ViewChild,
      args: ["contentWrapper", { static: true }]
    }] } });
    CdkVirtualForOf = class _CdkVirtualForOf {
      _viewContainerRef = inject(ViewContainerRef);
      _template = inject(TemplateRef);
      _differs = inject(IterableDiffers);
      _viewRepeater = inject(_VIEW_REPEATER_STRATEGY);
      _viewport = inject(CdkVirtualScrollViewport, { skipSelf: true });
      /** Emits when the rendered view of the data changes. */
      viewChange = new Subject();
      /** Subject that emits when a new DataSource instance is given. */
      _dataSourceChanges = new Subject();
      /** The DataSource to display. */
      get cdkVirtualForOf() {
        return this._cdkVirtualForOf;
      }
      set cdkVirtualForOf(value) {
        this._cdkVirtualForOf = value;
        if (isDataSource(value)) {
          this._dataSourceChanges.next(value);
        } else {
          this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));
        }
      }
      _cdkVirtualForOf;
      /**
       * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
       * the item and produces a value to be used as the item's identity when tracking changes.
       */
      get cdkVirtualForTrackBy() {
        return this._cdkVirtualForTrackBy;
      }
      set cdkVirtualForTrackBy(fn) {
        this._needsUpdate = true;
        this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : void 0;
      }
      _cdkVirtualForTrackBy;
      /** The template used to stamp out new elements. */
      set cdkVirtualForTemplate(value) {
        if (value) {
          this._needsUpdate = true;
          this._template = value;
        }
      }
      /**
       * The size of the cache used to store templates that are not being used for re-use later.
       * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
       */
      get cdkVirtualForTemplateCacheSize() {
        return this._viewRepeater.viewCacheSize;
      }
      set cdkVirtualForTemplateCacheSize(size) {
        this._viewRepeater.viewCacheSize = coerceNumberProperty(size);
      }
      /** Emits whenever the data in the current DataSource changes. */
      dataStream = this._dataSourceChanges.pipe(
        // Start off with null `DataSource`.
        startWith(null),
        // Bundle up the previous and current data sources so we can work with both.
        pairwise(),
        // Use `_changeDataSource` to disconnect from the previous data source and connect to the
        // new one, passing back a stream of data changes which we run through `switchMap` to give
        // us a data stream that emits the latest data from whatever the current `DataSource` is.
        switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),
        // Replay the last emitted data when someone subscribes.
        shareReplay(1)
      );
      /** The differ used to calculate changes to the data. */
      _differ = null;
      /** The most recent data emitted from the DataSource. */
      _data;
      /** The currently rendered items. */
      _renderedItems;
      /** The currently rendered range of indices. */
      _renderedRange;
      /** Whether the rendered data should be updated during the next ngDoCheck cycle. */
      _needsUpdate = false;
      _destroyed = new Subject();
      constructor() {
        const ngZone = inject(NgZone);
        this.dataStream.subscribe((data) => {
          this._data = data;
          this._onRenderedDataChange();
        });
        this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((range) => {
          this._renderedRange = range;
          if (this.viewChange.observers.length) {
            ngZone.run(() => this.viewChange.next(this._renderedRange));
          }
          this._onRenderedDataChange();
        });
        this._viewport.attach(this);
      }
      /**
       * Measures the combined size (width for horizontal orientation, height for vertical) of all items
       * in the specified range. Throws an error if the range includes items that are not currently
       * rendered.
       */
      measureRangeSize(range, orientation) {
        if (range.start >= range.end) {
          return 0;
        }
        if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) && (typeof ngDevMode === "undefined" || ngDevMode)) {
          throw Error(`Error: attempted to measure an item that isn't rendered.`);
        }
        const renderedStartIndex = range.start - this._renderedRange.start;
        const rangeLen = range.end - range.start;
        let firstNode;
        let lastNode;
        for (let i2 = 0; i2 < rangeLen; i2++) {
          const view = this._viewContainerRef.get(i2 + renderedStartIndex);
          if (view && view.rootNodes.length) {
            firstNode = lastNode = view.rootNodes[0];
            break;
          }
        }
        for (let i2 = rangeLen - 1; i2 > -1; i2--) {
          const view = this._viewContainerRef.get(i2 + renderedStartIndex);
          if (view && view.rootNodes.length) {
            lastNode = view.rootNodes[view.rootNodes.length - 1];
            break;
          }
        }
        return firstNode && lastNode ? getOffset(orientation, "end", lastNode) - getOffset(orientation, "start", firstNode) : 0;
      }
      ngDoCheck() {
        if (this._differ && this._needsUpdate) {
          const changes = this._differ.diff(this._renderedItems);
          if (!changes) {
            this._updateContext();
          } else {
            this._applyChanges(changes);
          }
          this._needsUpdate = false;
        }
      }
      ngOnDestroy() {
        this._viewport.detach();
        this._dataSourceChanges.next(void 0);
        this._dataSourceChanges.complete();
        this.viewChange.complete();
        this._destroyed.next();
        this._destroyed.complete();
        this._viewRepeater.detach();
      }
      /** React to scroll state changes in the viewport. */
      _onRenderedDataChange() {
        if (!this._renderedRange) {
          return;
        }
        this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
        if (!this._differ) {
          this._differ = this._differs.find(this._renderedItems).create((index, item) => {
            return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;
          });
        }
        this._needsUpdate = true;
      }
      /** Swap out one `DataSource` for another. */
      _changeDataSource(oldDs, newDs) {
        if (oldDs) {
          oldDs.disconnect(this);
        }
        this._needsUpdate = true;
        return newDs ? newDs.connect(this) : of();
      }
      /** Update the `CdkVirtualForOfContext` for all views. */
      _updateContext() {
        const count = this._data.length;
        let i2 = this._viewContainerRef.length;
        while (i2--) {
          const view = this._viewContainerRef.get(i2);
          view.context.index = this._renderedRange.start + i2;
          view.context.count = count;
          this._updateComputedContextProperties(view.context);
          view.detectChanges();
        }
      }
      /** Apply changes to the DOM. */
      _applyChanges(changes) {
        this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);
        changes.forEachIdentityChange((record) => {
          const view = this._viewContainerRef.get(record.currentIndex);
          view.context.$implicit = record.item;
        });
        const count = this._data.length;
        let i2 = this._viewContainerRef.length;
        while (i2--) {
          const view = this._viewContainerRef.get(i2);
          view.context.index = this._renderedRange.start + i2;
          view.context.count = count;
          this._updateComputedContextProperties(view.context);
        }
      }
      /** Update the computed properties on the `CdkVirtualForOfContext`. */
      _updateComputedContextProperties(context) {
        context.first = context.index === 0;
        context.last = context.index === context.count - 1;
        context.even = context.index % 2 === 0;
        context.odd = !context.even;
      }
      _getEmbeddedViewArgs(record, index) {
        return {
          templateRef: this._template,
          context: {
            $implicit: record.item,
            // It's guaranteed that the iterable is not "undefined" or "null" because we only
            // generate views for elements if the "cdkVirtualForOf" iterable has elements.
            cdkVirtualForOf: this._cdkVirtualForOf,
            index: -1,
            count: -1,
            first: false,
            last: false,
            odd: false,
            even: false
          },
          index
        };
      }
      static ngTemplateContextGuard(directive, context) {
        return true;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkVirtualForOf, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _CdkVirtualForOf, isStandalone: true, selector: "[cdkVirtualFor][cdkVirtualForOf]", inputs: { cdkVirtualForOf: "cdkVirtualForOf", cdkVirtualForTrackBy: "cdkVirtualForTrackBy", cdkVirtualForTemplate: "cdkVirtualForTemplate", cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize" }, providers: [{ provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy }], ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkVirtualForOf, decorators: [{
      type: Directive,
      args: [{
        selector: "[cdkVirtualFor][cdkVirtualForOf]",
        providers: [{ provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy }]
      }]
    }], ctorParameters: () => [], propDecorators: { cdkVirtualForOf: [{
      type: Input
    }], cdkVirtualForTrackBy: [{
      type: Input
    }], cdkVirtualForTemplate: [{
      type: Input
    }], cdkVirtualForTemplateCacheSize: [{
      type: Input
    }] } });
    CdkVirtualScrollableElement = class _CdkVirtualScrollableElement extends CdkVirtualScrollable {
      constructor() {
        super();
      }
      measureBoundingClientRectWithScrollOffset(from) {
        return this.getElementRef().nativeElement.getBoundingClientRect()[from] - this.measureScrollOffset(from);
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkVirtualScrollableElement, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _CdkVirtualScrollableElement, isStandalone: true, selector: "[cdkVirtualScrollingElement]", host: { classAttribute: "cdk-virtual-scrollable" }, providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: _CdkVirtualScrollableElement }], usesInheritance: true, ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkVirtualScrollableElement, decorators: [{
      type: Directive,
      args: [{
        selector: "[cdkVirtualScrollingElement]",
        providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableElement }],
        host: {
          "class": "cdk-virtual-scrollable"
        }
      }]
    }], ctorParameters: () => [] });
    CdkVirtualScrollableWindow = class _CdkVirtualScrollableWindow extends CdkVirtualScrollable {
      constructor() {
        super();
        const document2 = inject(DOCUMENT);
        this.elementRef = new ElementRef(document2.documentElement);
        this._scrollElement = document2;
      }
      measureBoundingClientRectWithScrollOffset(from) {
        return this.getElementRef().nativeElement.getBoundingClientRect()[from];
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkVirtualScrollableWindow, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _CdkVirtualScrollableWindow, isStandalone: true, selector: "cdk-virtual-scroll-viewport[scrollWindow]", providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: _CdkVirtualScrollableWindow }], usesInheritance: true, ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkVirtualScrollableWindow, decorators: [{
      type: Directive,
      args: [{
        selector: "cdk-virtual-scroll-viewport[scrollWindow]",
        providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableWindow }]
      }]
    }], ctorParameters: () => [] });
    CdkScrollableModule = class _CdkScrollableModule {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkScrollableModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkScrollableModule, imports: [CdkScrollable], exports: [CdkScrollable] });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _CdkScrollableModule });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: CdkScrollableModule, decorators: [{
      type: NgModule,
      args: [{
        exports: [CdkScrollable],
        imports: [CdkScrollable]
      }]
    }] });
    ScrollingModule = class _ScrollingModule {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ScrollingModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ScrollingModule, imports: [
        BidiModule,
        CdkScrollableModule,
        CdkVirtualScrollViewport,
        CdkFixedSizeVirtualScroll,
        CdkVirtualForOf,
        CdkVirtualScrollableWindow,
        CdkVirtualScrollableElement
      ], exports: [
        BidiModule,
        CdkScrollableModule,
        CdkFixedSizeVirtualScroll,
        CdkVirtualForOf,
        CdkVirtualScrollViewport,
        CdkVirtualScrollableWindow,
        CdkVirtualScrollableElement
      ] });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _ScrollingModule, imports: [
        BidiModule,
        CdkScrollableModule,
        BidiModule,
        CdkScrollableModule
      ] });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: ScrollingModule, decorators: [{
      type: NgModule,
      args: [{
        imports: [
          BidiModule,
          CdkScrollableModule,
          CdkVirtualScrollViewport,
          CdkFixedSizeVirtualScroll,
          CdkVirtualForOf,
          CdkVirtualScrollableWindow,
          CdkVirtualScrollableElement
        ],
        exports: [
          BidiModule,
          CdkScrollableModule,
          CdkFixedSizeVirtualScroll,
          CdkVirtualForOf,
          CdkVirtualScrollViewport,
          CdkVirtualScrollableWindow,
          CdkVirtualScrollableElement
        ]
      }]
    }] });
  }
});

// node_modules/@angular/cdk/fesm2022/layout.mjs
var LayoutModule;
var init_layout = __esm({
  "node_modules/@angular/cdk/fesm2022/layout.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_breakpoints_observer();
    LayoutModule = class _LayoutModule {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _LayoutModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _LayoutModule });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _LayoutModule });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: LayoutModule, decorators: [{
      type: NgModule,
      args: [{}]
    }] });
  }
});

// node_modules/@angular/material/fesm2022/animation.mjs
function _getAnimationsState() {
  if (inject(MATERIAL_ANIMATIONS, { optional: true })?.animationsDisabled || inject(ANIMATION_MODULE_TYPE, { optional: true }) === "NoopAnimations") {
    return "di-disabled";
  }
  reducedMotion ??= inject(MediaMatcher).matchMedia("(prefers-reduced-motion)").matches;
  return reducedMotion ? "reduced-motion" : "enabled";
}
function _animationsDisabled() {
  return _getAnimationsState() !== "enabled";
}
var MATERIAL_ANIMATIONS, reducedMotion;
var init_animation = __esm({
  "node_modules/@angular/material/fesm2022/animation.mjs"() {
    "use strict";
    init_layout();
    init_core();
    MATERIAL_ANIMATIONS = new InjectionToken("MATERIAL_ANIMATIONS");
    reducedMotion = null;
  }
});

// node_modules/@angular/material/fesm2022/common-module.mjs
var MATERIAL_SANITY_CHECKS, MatCommonModule;
var init_common_module = __esm({
  "node_modules/@angular/material/fesm2022/common-module.mjs"() {
    "use strict";
    init_a11y();
    init_bidi();
    init_core();
    init_core();
    MATERIAL_SANITY_CHECKS = new InjectionToken("mat-sanity-checks", {
      providedIn: "root",
      factory: () => true
    });
    MatCommonModule = class _MatCommonModule {
      constructor() {
        inject(HighContrastModeDetector)._applyBodyHighContrastModeCssClasses();
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatCommonModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatCommonModule, imports: [BidiModule], exports: [BidiModule] });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatCommonModule, imports: [BidiModule, BidiModule] });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatCommonModule, decorators: [{
      type: NgModule,
      args: [{
        imports: [BidiModule],
        exports: [BidiModule]
      }]
    }], ctorParameters: () => [] });
  }
});

// node_modules/@angular/material/fesm2022/sidenav.mjs
function throwMatDuplicatedDrawerError(position) {
  throw Error(`A drawer was already declared for 'position="${position}"'`);
}
function MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY() {
  return false;
}
var MAT_DRAWER_DEFAULT_AUTOSIZE, MAT_DRAWER_CONTAINER, MatDrawerContent, MatDrawer, MatDrawerContainer, MatSidenavContent, MatSidenav, MatSidenavContainer, MatSidenavModule;
var init_sidenav = __esm({
  "node_modules/@angular/material/fesm2022/sidenav.mjs"() {
    "use strict";
    init_a11y();
    init_bidi();
    init_coercion();
    init_keycodes();
    init_platform();
    init_scrolling();
    init_core();
    init_core();
    init_esm();
    init_operators();
    init_animation();
    init_common_module();
    MAT_DRAWER_DEFAULT_AUTOSIZE = new InjectionToken("MAT_DRAWER_DEFAULT_AUTOSIZE", {
      providedIn: "root",
      factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY
    });
    MAT_DRAWER_CONTAINER = new InjectionToken("MAT_DRAWER_CONTAINER");
    MatDrawerContent = class _MatDrawerContent extends CdkScrollable {
      _platform = inject(Platform);
      _changeDetectorRef = inject(ChangeDetectorRef);
      _container = inject(MatDrawerContainer);
      constructor() {
        const elementRef = inject(ElementRef);
        const scrollDispatcher = inject(ScrollDispatcher);
        const ngZone = inject(NgZone);
        super(elementRef, scrollDispatcher, ngZone);
      }
      ngAfterContentInit() {
        this._container._contentMarginChanges.subscribe(() => {
          this._changeDetectorRef.markForCheck();
        });
      }
      /** Determines whether the content element should be hidden from the user. */
      _shouldBeHidden() {
        if (this._platform.isBrowser) {
          return false;
        }
        const { start, end } = this._container;
        return start != null && start.mode !== "over" && start.opened || end != null && end.mode !== "over" && end.opened;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatDrawerContent, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _MatDrawerContent, isStandalone: true, selector: "mat-drawer-content", host: { properties: { "style.margin-left.px": "_container._contentMargins.left", "style.margin-right.px": "_container._contentMargins.right", "class.mat-drawer-content-hidden": "_shouldBeHidden()" }, classAttribute: "mat-drawer-content" }, providers: [
        {
          provide: CdkScrollable,
          useExisting: _MatDrawerContent
        }
      ], usesInheritance: true, ngImport: core_exports, template: "<ng-content></ng-content>", isInline: true, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatDrawerContent, decorators: [{
      type: Component,
      args: [{
        selector: "mat-drawer-content",
        template: "<ng-content></ng-content>",
        host: {
          "class": "mat-drawer-content",
          "[style.margin-left.px]": "_container._contentMargins.left",
          "[style.margin-right.px]": "_container._contentMargins.right",
          "[class.mat-drawer-content-hidden]": "_shouldBeHidden()"
        },
        changeDetection: ChangeDetectionStrategy.OnPush,
        encapsulation: ViewEncapsulation.None,
        providers: [
          {
            provide: CdkScrollable,
            useExisting: MatDrawerContent
          }
        ]
      }]
    }], ctorParameters: () => [] });
    MatDrawer = class _MatDrawer {
      _elementRef = inject(ElementRef);
      _focusTrapFactory = inject(FocusTrapFactory);
      _focusMonitor = inject(FocusMonitor);
      _platform = inject(Platform);
      _ngZone = inject(NgZone);
      _renderer = inject(Renderer2);
      _interactivityChecker = inject(InteractivityChecker);
      _doc = inject(DOCUMENT);
      _container = inject(MAT_DRAWER_CONTAINER, { optional: true });
      _focusTrap = null;
      _elementFocusedBeforeDrawerWasOpened = null;
      _eventCleanups;
      /** Whether the view of the component has been attached. */
      _isAttached;
      /** Anchor node used to restore the drawer to its initial position. */
      _anchor;
      /** The side that the drawer is attached to. */
      get position() {
        return this._position;
      }
      set position(value) {
        value = value === "end" ? "end" : "start";
        if (value !== this._position) {
          if (this._isAttached) {
            this._updatePositionInParent(value);
          }
          this._position = value;
          this.onPositionChanged.emit();
        }
      }
      _position = "start";
      /** Mode of the drawer; one of 'over', 'push' or 'side'. */
      get mode() {
        return this._mode;
      }
      set mode(value) {
        this._mode = value;
        this._updateFocusTrapState();
        this._modeChanged.next();
      }
      _mode = "over";
      /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */
      get disableClose() {
        return this._disableClose;
      }
      set disableClose(value) {
        this._disableClose = coerceBooleanProperty(value);
      }
      _disableClose = false;
      /**
       * Whether the drawer should focus the first focusable element automatically when opened.
       * Defaults to false in when `mode` is set to `side`, otherwise defaults to `true`. If explicitly
       * enabled, focus will be moved into the sidenav in `side` mode as well.
       * @breaking-change 14.0.0 Remove boolean option from autoFocus. Use string or AutoFocusTarget
       * instead.
       */
      get autoFocus() {
        const value = this._autoFocus;
        if (value == null) {
          if (this.mode === "side") {
            return "dialog";
          } else {
            return "first-tabbable";
          }
        }
        return value;
      }
      set autoFocus(value) {
        if (value === "true" || value === "false" || value == null) {
          value = coerceBooleanProperty(value);
        }
        this._autoFocus = value;
      }
      _autoFocus;
      /**
       * Whether the drawer is opened. We overload this because we trigger an event when it
       * starts or end.
       */
      get opened() {
        return this._opened();
      }
      set opened(value) {
        this.toggle(coerceBooleanProperty(value));
      }
      _opened = signal(false, ...ngDevMode ? [{ debugName: "_opened" }] : []);
      /** How the sidenav was opened (keypress, mouse click etc.) */
      _openedVia;
      /** Emits whenever the drawer has started animating. */
      _animationStarted = new Subject();
      /** Emits whenever the drawer is done animating. */
      _animationEnd = new Subject();
      /** Event emitted when the drawer open state is changed. */
      openedChange = (
        // Note this has to be async in order to avoid some issues with two-bindings (see #8872).
        new EventEmitter(
          /* isAsync */
          true
        )
      );
      /** Event emitted when the drawer has been opened. */
      _openedStream = this.openedChange.pipe(filter((o2) => o2), map(() => {
      }));
      /** Event emitted when the drawer has started opening. */
      openedStart = this._animationStarted.pipe(filter(() => this.opened), mapTo(void 0));
      /** Event emitted when the drawer has been closed. */
      _closedStream = this.openedChange.pipe(filter((o2) => !o2), map(() => {
      }));
      /** Event emitted when the drawer has started closing. */
      closedStart = this._animationStarted.pipe(filter(() => !this.opened), mapTo(void 0));
      /** Emits when the component is destroyed. */
      _destroyed = new Subject();
      /** Event emitted when the drawer's position changes. */
      // tslint:disable-next-line:no-output-on-prefix
      onPositionChanged = new EventEmitter();
      /** Reference to the inner element that contains all the content. */
      _content;
      /**
       * An observable that emits when the drawer mode changes. This is used by the drawer container to
       * to know when to when the mode changes so it can adapt the margins on the content.
       */
      _modeChanged = new Subject();
      _injector = inject(Injector);
      _changeDetectorRef = inject(ChangeDetectorRef);
      constructor() {
        this.openedChange.pipe(takeUntil(this._destroyed)).subscribe((opened) => {
          if (opened) {
            this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement;
            this._takeFocus();
          } else if (this._isFocusWithinDrawer()) {
            this._restoreFocus(this._openedVia || "program");
          }
        });
        this._ngZone.runOutsideAngular(() => {
          const element = this._elementRef.nativeElement;
          fromEvent(element, "keydown").pipe(filter((event) => {
            return event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event);
          }), takeUntil(this._destroyed)).subscribe((event) => this._ngZone.run(() => {
            this.close();
            event.stopPropagation();
            event.preventDefault();
          }));
          this._eventCleanups = [
            this._renderer.listen(element, "transitionrun", this._handleTransitionEvent),
            this._renderer.listen(element, "transitionend", this._handleTransitionEvent),
            this._renderer.listen(element, "transitioncancel", this._handleTransitionEvent)
          ];
        });
        this._animationEnd.subscribe(() => {
          this.openedChange.emit(this.opened);
        });
      }
      /**
       * Focuses the provided element. If the element is not focusable, it will add a tabIndex
       * attribute to forcefully focus it. The attribute is removed after focus is moved.
       * @param element The element to focus.
       */
      _forceFocus(element, options) {
        if (!this._interactivityChecker.isFocusable(element)) {
          element.tabIndex = -1;
          this._ngZone.runOutsideAngular(() => {
            const callback = () => {
              cleanupBlur();
              cleanupMousedown();
              element.removeAttribute("tabindex");
            };
            const cleanupBlur = this._renderer.listen(element, "blur", callback);
            const cleanupMousedown = this._renderer.listen(element, "mousedown", callback);
          });
        }
        element.focus(options);
      }
      /**
       * Focuses the first element that matches the given selector within the focus trap.
       * @param selector The CSS selector for the element to set focus to.
       */
      _focusByCssSelector(selector, options) {
        let elementToFocus = this._elementRef.nativeElement.querySelector(selector);
        if (elementToFocus) {
          this._forceFocus(elementToFocus, options);
        }
      }
      /**
       * Moves focus into the drawer. Note that this works even if
       * the focus trap is disabled in `side` mode.
       */
      _takeFocus() {
        if (!this._focusTrap) {
          return;
        }
        const element = this._elementRef.nativeElement;
        switch (this.autoFocus) {
          case false:
          case "dialog":
            return;
          case true:
          case "first-tabbable":
            afterNextRender(() => {
              const hasMovedFocus = this._focusTrap.focusInitialElement();
              if (!hasMovedFocus && typeof element.focus === "function") {
                element.focus();
              }
            }, { injector: this._injector });
            break;
          case "first-heading":
            this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');
            break;
          default:
            this._focusByCssSelector(this.autoFocus);
            break;
        }
      }
      /**
       * Restores focus to the element that was originally focused when the drawer opened.
       * If no element was focused at that time, the focus will be restored to the drawer.
       */
      _restoreFocus(focusOrigin) {
        if (this.autoFocus === "dialog") {
          return;
        }
        if (this._elementFocusedBeforeDrawerWasOpened) {
          this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, focusOrigin);
        } else {
          this._elementRef.nativeElement.blur();
        }
        this._elementFocusedBeforeDrawerWasOpened = null;
      }
      /** Whether focus is currently within the drawer. */
      _isFocusWithinDrawer() {
        const activeEl = this._doc.activeElement;
        return !!activeEl && this._elementRef.nativeElement.contains(activeEl);
      }
      ngAfterViewInit() {
        this._isAttached = true;
        if (this._position === "end") {
          this._updatePositionInParent("end");
        }
        if (this._platform.isBrowser) {
          this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);
          this._updateFocusTrapState();
        }
      }
      ngOnDestroy() {
        this._eventCleanups.forEach((cleanup) => cleanup());
        this._focusTrap?.destroy();
        this._anchor?.remove();
        this._anchor = null;
        this._animationStarted.complete();
        this._animationEnd.complete();
        this._modeChanged.complete();
        this._destroyed.next();
        this._destroyed.complete();
      }
      /**
       * Open the drawer.
       * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
       * Used for focus management after the sidenav is closed.
       */
      open(openedVia) {
        return this.toggle(true, openedVia);
      }
      /** Close the drawer. */
      close() {
        return this.toggle(false);
      }
      /** Closes the drawer with context that the backdrop was clicked. */
      _closeViaBackdropClick() {
        return this._setOpen(
          /* isOpen */
          false,
          /* restoreFocus */
          true,
          "mouse"
        );
      }
      /**
       * Toggle this drawer.
       * @param isOpen Whether the drawer should be open.
       * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.
       * Used for focus management after the sidenav is closed.
       */
      toggle(isOpen = !this.opened, openedVia) {
        if (isOpen && openedVia) {
          this._openedVia = openedVia;
        }
        const result = this._setOpen(
          isOpen,
          /* restoreFocus */
          !isOpen && this._isFocusWithinDrawer(),
          this._openedVia || "program"
        );
        if (!isOpen) {
          this._openedVia = null;
        }
        return result;
      }
      /**
       * Toggles the opened state of the drawer.
       * @param isOpen Whether the drawer should open or close.
       * @param restoreFocus Whether focus should be restored on close.
       * @param focusOrigin Origin to use when restoring focus.
       */
      _setOpen(isOpen, restoreFocus, focusOrigin) {
        if (isOpen === this.opened) {
          return Promise.resolve(isOpen ? "open" : "close");
        }
        this._opened.set(isOpen);
        if (this._container?._transitionsEnabled) {
          this._setIsAnimating(true);
        } else {
          setTimeout(() => {
            this._animationStarted.next();
            this._animationEnd.next();
          });
        }
        this._elementRef.nativeElement.classList.toggle("mat-drawer-opened", isOpen);
        if (!isOpen && restoreFocus) {
          this._restoreFocus(focusOrigin);
        }
        this._changeDetectorRef.markForCheck();
        this._updateFocusTrapState();
        return new Promise((resolve) => {
          this.openedChange.pipe(take(1)).subscribe((open2) => resolve(open2 ? "open" : "close"));
        });
      }
      /** Toggles whether the drawer is currently animating. */
      _setIsAnimating(isAnimating) {
        this._elementRef.nativeElement.classList.toggle("mat-drawer-animating", isAnimating);
      }
      _getWidth() {
        return this._elementRef.nativeElement.offsetWidth || 0;
      }
      /** Updates the enabled state of the focus trap. */
      _updateFocusTrapState() {
        if (this._focusTrap) {
          this._focusTrap.enabled = !!this._container?.hasBackdrop && this.opened;
        }
      }
      /**
       * Updates the position of the drawer in the DOM. We need to move the element around ourselves
       * when it's in the `end` position so that it comes after the content and the visual order
       * matches the tab order. We also need to be able to move it back to `start` if the sidenav
       * started off as `end` and was changed to `start`.
       */
      _updatePositionInParent(newPosition) {
        if (!this._platform.isBrowser) {
          return;
        }
        const element = this._elementRef.nativeElement;
        const parent = element.parentNode;
        if (newPosition === "end") {
          if (!this._anchor) {
            this._anchor = this._doc.createComment("mat-drawer-anchor");
            parent.insertBefore(this._anchor, element);
          }
          parent.appendChild(element);
        } else if (this._anchor) {
          this._anchor.parentNode.insertBefore(element, this._anchor);
        }
      }
      /** Event handler for animation events. */
      _handleTransitionEvent = (event) => {
        const element = this._elementRef.nativeElement;
        if (event.target === element) {
          this._ngZone.run(() => {
            if (event.type === "transitionrun") {
              this._animationStarted.next(event);
            } else {
              if (event.type === "transitionend") {
                this._setIsAnimating(false);
              }
              this._animationEnd.next(event);
            }
          });
        }
      };
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatDrawer, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _MatDrawer, isStandalone: true, selector: "mat-drawer", inputs: { position: "position", mode: "mode", disableClose: "disableClose", autoFocus: "autoFocus", opened: "opened" }, outputs: { openedChange: "openedChange", _openedStream: "opened", openedStart: "openedStart", _closedStream: "closed", closedStart: "closedStart", onPositionChanged: "positionChanged" }, host: { properties: { "attr.align": "null", "class.mat-drawer-end": 'position === "end"', "class.mat-drawer-over": 'mode === "over"', "class.mat-drawer-push": 'mode === "push"', "class.mat-drawer-side": 'mode === "side"', "style.visibility": '(!_container && !opened) ? "hidden" : null', "attr.tabIndex": '(mode !== "side") ? "-1" : null' }, classAttribute: "mat-drawer" }, viewQueries: [{ propertyName: "_content", first: true, predicate: ["content"], descendants: true }], exportAs: ["matDrawer"], ngImport: core_exports, template: '<div class="mat-drawer-inner-container" cdkScrollable #content>\r\n  <ng-content></ng-content>\r\n</div>\r\n', dependencies: [{ kind: "directive", type: CdkScrollable, selector: "[cdk-scrollable], [cdkScrollable]" }], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatDrawer, decorators: [{
      type: Component,
      args: [{ selector: "mat-drawer", exportAs: "matDrawer", host: {
        "class": "mat-drawer",
        // must prevent the browser from aligning text based on value
        "[attr.align]": "null",
        "[class.mat-drawer-end]": 'position === "end"',
        "[class.mat-drawer-over]": 'mode === "over"',
        "[class.mat-drawer-push]": 'mode === "push"',
        "[class.mat-drawer-side]": 'mode === "side"',
        // The styles that render the sidenav off-screen come from the drawer container. Prior to #30235
        // this was also done by the animations module which some internal tests seem to depend on.
        // Simulate it by toggling the `hidden` attribute instead.
        "[style.visibility]": '(!_container && !opened) ? "hidden" : null',
        // The sidenav container should not be focused on when used in side mode. See b/286459024 for
        // reference. Updates tabIndex of drawer/container to default to null if in side mode.
        "[attr.tabIndex]": '(mode !== "side") ? "-1" : null'
      }, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, imports: [CdkScrollable], template: '<div class="mat-drawer-inner-container" cdkScrollable #content>\r\n  <ng-content></ng-content>\r\n</div>\r\n' }]
    }], ctorParameters: () => [], propDecorators: { position: [{
      type: Input
    }], mode: [{
      type: Input
    }], disableClose: [{
      type: Input
    }], autoFocus: [{
      type: Input
    }], opened: [{
      type: Input
    }], openedChange: [{
      type: Output
    }], _openedStream: [{
      type: Output,
      args: ["opened"]
    }], openedStart: [{
      type: Output
    }], _closedStream: [{
      type: Output,
      args: ["closed"]
    }], closedStart: [{
      type: Output
    }], onPositionChanged: [{
      type: Output,
      args: ["positionChanged"]
    }], _content: [{
      type: ViewChild,
      args: ["content"]
    }] } });
    MatDrawerContainer = class _MatDrawerContainer {
      _dir = inject(Directionality, { optional: true });
      _element = inject(ElementRef);
      _ngZone = inject(NgZone);
      _changeDetectorRef = inject(ChangeDetectorRef);
      _animationDisabled = _animationsDisabled();
      _transitionsEnabled = false;
      /** All drawers in the container. Includes drawers from inside nested containers. */
      _allDrawers;
      /** Drawers that belong to this container. */
      _drawers = new QueryList();
      _content;
      _userContent;
      /** The drawer child with the `start` position. */
      get start() {
        return this._start;
      }
      /** The drawer child with the `end` position. */
      get end() {
        return this._end;
      }
      /**
       * Whether to automatically resize the container whenever
       * the size of any of its drawers changes.
       *
       * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring
       * the drawers on every change detection cycle. Can be configured globally via the
       * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.
       */
      get autosize() {
        return this._autosize;
      }
      set autosize(value) {
        this._autosize = coerceBooleanProperty(value);
      }
      _autosize = inject(MAT_DRAWER_DEFAULT_AUTOSIZE);
      /**
       * Whether the drawer container should have a backdrop while one of the sidenavs is open.
       * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`
       * mode as well.
       */
      get hasBackdrop() {
        return this._drawerHasBackdrop(this._start) || this._drawerHasBackdrop(this._end);
      }
      set hasBackdrop(value) {
        this._backdropOverride = value == null ? null : coerceBooleanProperty(value);
      }
      _backdropOverride;
      /** Event emitted when the drawer backdrop is clicked. */
      backdropClick = new EventEmitter();
      /** The drawer at the start/end position, independent of direction. */
      _start;
      _end;
      /**
       * The drawer at the left/right. When direction changes, these will change as well.
       * They're used as aliases for the above to set the left/right style properly.
       * In LTR, _left == _start and _right == _end.
       * In RTL, _left == _end and _right == _start.
       */
      _left;
      _right;
      /** Emits when the component is destroyed. */
      _destroyed = new Subject();
      /** Emits on every ngDoCheck. Used for debouncing reflows. */
      _doCheckSubject = new Subject();
      /**
       * Margins to be applied to the content. These are used to push / shrink the drawer content when a
       * drawer is open. We use margin rather than transform even for push mode because transform breaks
       * fixed position elements inside of the transformed element.
       */
      _contentMargins = { left: null, right: null };
      _contentMarginChanges = new Subject();
      /** Reference to the CdkScrollable instance that wraps the scrollable content. */
      get scrollable() {
        return this._userContent || this._content;
      }
      _injector = inject(Injector);
      constructor() {
        const platform = inject(Platform);
        const viewportRuler = inject(ViewportRuler);
        this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => {
          this._validateDrawers();
          this.updateContentMargins();
        });
        viewportRuler.change().pipe(takeUntil(this._destroyed)).subscribe(() => this.updateContentMargins());
        if (!this._animationDisabled && platform.isBrowser) {
          this._ngZone.runOutsideAngular(() => {
            setTimeout(() => {
              this._element.nativeElement.classList.add("mat-drawer-transition");
              this._transitionsEnabled = true;
            }, 200);
          });
        }
      }
      ngAfterContentInit() {
        this._allDrawers.changes.pipe(startWith(this._allDrawers), takeUntil(this._destroyed)).subscribe((drawer) => {
          this._drawers.reset(drawer.filter((item) => !item._container || item._container === this));
          this._drawers.notifyOnChanges();
        });
        this._drawers.changes.pipe(startWith(null)).subscribe(() => {
          this._validateDrawers();
          this._drawers.forEach((drawer) => {
            this._watchDrawerToggle(drawer);
            this._watchDrawerPosition(drawer);
            this._watchDrawerMode(drawer);
          });
          if (!this._drawers.length || this._isDrawerOpen(this._start) || this._isDrawerOpen(this._end)) {
            this.updateContentMargins();
          }
          this._changeDetectorRef.markForCheck();
        });
        this._ngZone.runOutsideAngular(() => {
          this._doCheckSubject.pipe(
            debounceTime(10),
            // Arbitrary debounce time, less than a frame at 60fps
            takeUntil(this._destroyed)
          ).subscribe(() => this.updateContentMargins());
        });
      }
      ngOnDestroy() {
        this._contentMarginChanges.complete();
        this._doCheckSubject.complete();
        this._drawers.destroy();
        this._destroyed.next();
        this._destroyed.complete();
      }
      /** Calls `open` of both start and end drawers */
      open() {
        this._drawers.forEach((drawer) => drawer.open());
      }
      /** Calls `close` of both start and end drawers */
      close() {
        this._drawers.forEach((drawer) => drawer.close());
      }
      /**
       * Recalculates and updates the inline styles for the content. Note that this should be used
       * sparingly, because it causes a reflow.
       */
      updateContentMargins() {
        let left = 0;
        let right = 0;
        if (this._left && this._left.opened) {
          if (this._left.mode == "side") {
            left += this._left._getWidth();
          } else if (this._left.mode == "push") {
            const width = this._left._getWidth();
            left += width;
            right -= width;
          }
        }
        if (this._right && this._right.opened) {
          if (this._right.mode == "side") {
            right += this._right._getWidth();
          } else if (this._right.mode == "push") {
            const width = this._right._getWidth();
            right += width;
            left -= width;
          }
        }
        left = left || null;
        right = right || null;
        if (left !== this._contentMargins.left || right !== this._contentMargins.right) {
          this._contentMargins = { left, right };
          this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins));
        }
      }
      ngDoCheck() {
        if (this._autosize && this._isPushed()) {
          this._ngZone.runOutsideAngular(() => this._doCheckSubject.next());
        }
      }
      /**
       * Subscribes to drawer events in order to set a class on the main container element when the
       * drawer is open and the backdrop is visible. This ensures any overflow on the container element
       * is properly hidden.
       */
      _watchDrawerToggle(drawer) {
        drawer._animationStarted.pipe(takeUntil(this._drawers.changes)).subscribe(() => {
          this.updateContentMargins();
          this._changeDetectorRef.markForCheck();
        });
        if (drawer.mode !== "side") {
          drawer.openedChange.pipe(takeUntil(this._drawers.changes)).subscribe(() => this._setContainerClass(drawer.opened));
        }
      }
      /**
       * Subscribes to drawer onPositionChanged event in order to
       * re-validate drawers when the position changes.
       */
      _watchDrawerPosition(drawer) {
        drawer.onPositionChanged.pipe(takeUntil(this._drawers.changes)).subscribe(() => {
          afterNextRender({ read: () => this._validateDrawers() }, { injector: this._injector });
        });
      }
      /** Subscribes to changes in drawer mode so we can run change detection. */
      _watchDrawerMode(drawer) {
        drawer._modeChanged.pipe(takeUntil(merge(this._drawers.changes, this._destroyed))).subscribe(() => {
          this.updateContentMargins();
          this._changeDetectorRef.markForCheck();
        });
      }
      /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */
      _setContainerClass(isAdd) {
        const classList = this._element.nativeElement.classList;
        const className = "mat-drawer-container-has-open";
        if (isAdd) {
          classList.add(className);
        } else {
          classList.remove(className);
        }
      }
      /** Validate the state of the drawer children components. */
      _validateDrawers() {
        this._start = this._end = null;
        this._drawers.forEach((drawer) => {
          if (drawer.position == "end") {
            if (this._end != null && (typeof ngDevMode === "undefined" || ngDevMode)) {
              throwMatDuplicatedDrawerError("end");
            }
            this._end = drawer;
          } else {
            if (this._start != null && (typeof ngDevMode === "undefined" || ngDevMode)) {
              throwMatDuplicatedDrawerError("start");
            }
            this._start = drawer;
          }
        });
        this._right = this._left = null;
        if (this._dir && this._dir.value === "rtl") {
          this._left = this._end;
          this._right = this._start;
        } else {
          this._left = this._start;
          this._right = this._end;
        }
      }
      /** Whether the container is being pushed to the side by one of the drawers. */
      _isPushed() {
        return this._isDrawerOpen(this._start) && this._start.mode != "over" || this._isDrawerOpen(this._end) && this._end.mode != "over";
      }
      _onBackdropClicked() {
        this.backdropClick.emit();
        this._closeModalDrawersViaBackdrop();
      }
      _closeModalDrawersViaBackdrop() {
        [this._start, this._end].filter((drawer) => drawer && !drawer.disableClose && this._drawerHasBackdrop(drawer)).forEach((drawer) => drawer._closeViaBackdropClick());
      }
      _isShowingBackdrop() {
        return this._isDrawerOpen(this._start) && this._drawerHasBackdrop(this._start) || this._isDrawerOpen(this._end) && this._drawerHasBackdrop(this._end);
      }
      _isDrawerOpen(drawer) {
        return drawer != null && drawer.opened;
      }
      // Whether argument drawer should have a backdrop when it opens
      _drawerHasBackdrop(drawer) {
        if (this._backdropOverride == null) {
          return !!drawer && drawer.mode !== "side";
        }
        return this._backdropOverride;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatDrawerContainer, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "17.0.0", version: "20.2.0-next.2", type: _MatDrawerContainer, isStandalone: true, selector: "mat-drawer-container", inputs: { autosize: "autosize", hasBackdrop: "hasBackdrop" }, outputs: { backdropClick: "backdropClick" }, host: { properties: { "class.mat-drawer-container-explicit-backdrop": "_backdropOverride" }, classAttribute: "mat-drawer-container" }, providers: [
        {
          provide: MAT_DRAWER_CONTAINER,
          useExisting: _MatDrawerContainer
        }
      ], queries: [{ propertyName: "_content", first: true, predicate: MatDrawerContent, descendants: true }, { propertyName: "_allDrawers", predicate: MatDrawer, descendants: true }], viewQueries: [{ propertyName: "_userContent", first: true, predicate: MatDrawerContent, descendants: true }], exportAs: ["matDrawerContainer"], ngImport: core_exports, template: '@if (hasBackdrop) {\n  <div class="mat-drawer-backdrop" (click)="_onBackdropClicked()"\n       [class.mat-drawer-shown]="_isShowingBackdrop()"></div>\n}\n\n<ng-content select="mat-drawer"></ng-content>\n\n<ng-content select="mat-drawer-content">\n</ng-content>\n\n@if (!_content) {\n  <mat-drawer-content>\n    <ng-content></ng-content>\n  </mat-drawer-content>\n}\n', styles: [".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color, var(--mat-sys-on-background));background-color:var(--mat-sidenav-content-background-color, var(--mat-sys-background));box-sizing:border-box;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color, color-mix(in srgb, var(--mat-sys-neutral-variant20) 40%, transparent))}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(forced-colors: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-content.mat-drawer-content-hidden{opacity:0}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;color:var(--mat-sidenav-container-text-color, var(--mat-sys-on-surface-variant));box-shadow:var(--mat-sidenav-container-elevation-shadow, none);background-color:var(--mat-sidenav-container-background-color, var(--mat-sys-surface));border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));width:var(--mat-sidenav-container-width, 360px);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(forced-colors: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(forced-colors: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-transition .mat-drawer{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating){visibility:hidden;box-shadow:none}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating) .mat-drawer-inner-container{display:none}.mat-drawer.mat-drawer-opened.mat-drawer-opened{transform:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto}.mat-sidenav-fixed{position:fixed}\n"], dependencies: [{ kind: "component", type: MatDrawerContent, selector: "mat-drawer-content" }], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatDrawerContainer, decorators: [{
      type: Component,
      args: [{ selector: "mat-drawer-container", exportAs: "matDrawerContainer", host: {
        "class": "mat-drawer-container",
        "[class.mat-drawer-container-explicit-backdrop]": "_backdropOverride"
      }, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, providers: [
        {
          provide: MAT_DRAWER_CONTAINER,
          useExisting: MatDrawerContainer
        }
      ], imports: [MatDrawerContent], template: '@if (hasBackdrop) {\n  <div class="mat-drawer-backdrop" (click)="_onBackdropClicked()"\n       [class.mat-drawer-shown]="_isShowingBackdrop()"></div>\n}\n\n<ng-content select="mat-drawer"></ng-content>\n\n<ng-content select="mat-drawer-content">\n</ng-content>\n\n@if (!_content) {\n  <mat-drawer-content>\n    <ng-content></ng-content>\n  </mat-drawer-content>\n}\n', styles: [".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color, var(--mat-sys-on-background));background-color:var(--mat-sidenav-content-background-color, var(--mat-sys-background));box-sizing:border-box;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color, color-mix(in srgb, var(--mat-sys-neutral-variant20) 40%, transparent))}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(forced-colors: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-content.mat-drawer-content-hidden{opacity:0}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;color:var(--mat-sidenav-container-text-color, var(--mat-sys-on-surface-variant));box-shadow:var(--mat-sidenav-container-elevation-shadow, none);background-color:var(--mat-sidenav-container-background-color, var(--mat-sys-surface));border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));width:var(--mat-sidenav-container-width, 360px);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(forced-colors: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(forced-colors: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-transition .mat-drawer{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating){visibility:hidden;box-shadow:none}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating) .mat-drawer-inner-container{display:none}.mat-drawer.mat-drawer-opened.mat-drawer-opened{transform:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto}.mat-sidenav-fixed{position:fixed}\n"] }]
    }], ctorParameters: () => [], propDecorators: { _allDrawers: [{
      type: ContentChildren,
      args: [MatDrawer, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }], _content: [{
      type: ContentChild,
      args: [MatDrawerContent]
    }], _userContent: [{
      type: ViewChild,
      args: [MatDrawerContent]
    }], autosize: [{
      type: Input
    }], hasBackdrop: [{
      type: Input
    }], backdropClick: [{
      type: Output
    }] } });
    MatSidenavContent = class _MatSidenavContent extends MatDrawerContent {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatSidenavContent, deps: null, target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _MatSidenavContent, isStandalone: true, selector: "mat-sidenav-content", host: { classAttribute: "mat-drawer-content mat-sidenav-content" }, providers: [
        {
          provide: CdkScrollable,
          useExisting: _MatSidenavContent
        }
      ], usesInheritance: true, ngImport: core_exports, template: "<ng-content></ng-content>", isInline: true, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatSidenavContent, decorators: [{
      type: Component,
      args: [{
        selector: "mat-sidenav-content",
        template: "<ng-content></ng-content>",
        host: {
          "class": "mat-drawer-content mat-sidenav-content"
        },
        changeDetection: ChangeDetectionStrategy.OnPush,
        encapsulation: ViewEncapsulation.None,
        providers: [
          {
            provide: CdkScrollable,
            useExisting: MatSidenavContent
          }
        ]
      }]
    }] });
    MatSidenav = class _MatSidenav extends MatDrawer {
      /** Whether the sidenav is fixed in the viewport. */
      get fixedInViewport() {
        return this._fixedInViewport;
      }
      set fixedInViewport(value) {
        this._fixedInViewport = coerceBooleanProperty(value);
      }
      _fixedInViewport = false;
      /**
       * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed
       * mode.
       */
      get fixedTopGap() {
        return this._fixedTopGap;
      }
      set fixedTopGap(value) {
        this._fixedTopGap = coerceNumberProperty(value);
      }
      _fixedTopGap = 0;
      /**
       * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in
       * fixed mode.
       */
      get fixedBottomGap() {
        return this._fixedBottomGap;
      }
      set fixedBottomGap(value) {
        this._fixedBottomGap = coerceNumberProperty(value);
      }
      _fixedBottomGap = 0;
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatSidenav, deps: null, target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _MatSidenav, isStandalone: true, selector: "mat-sidenav", inputs: { fixedInViewport: "fixedInViewport", fixedTopGap: "fixedTopGap", fixedBottomGap: "fixedBottomGap" }, host: { properties: { "attr.tabIndex": '(mode !== "side") ? "-1" : null', "attr.align": "null", "class.mat-drawer-end": 'position === "end"', "class.mat-drawer-over": 'mode === "over"', "class.mat-drawer-push": 'mode === "push"', "class.mat-drawer-side": 'mode === "side"', "class.mat-sidenav-fixed": "fixedInViewport", "style.top.px": "fixedInViewport ? fixedTopGap : null", "style.bottom.px": "fixedInViewport ? fixedBottomGap : null" }, classAttribute: "mat-drawer mat-sidenav" }, providers: [{ provide: MatDrawer, useExisting: _MatSidenav }], exportAs: ["matSidenav"], usesInheritance: true, ngImport: core_exports, template: '<div class="mat-drawer-inner-container" cdkScrollable #content>\r\n  <ng-content></ng-content>\r\n</div>\r\n', dependencies: [{ kind: "directive", type: CdkScrollable, selector: "[cdk-scrollable], [cdkScrollable]" }], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatSidenav, decorators: [{
      type: Component,
      args: [{ selector: "mat-sidenav", exportAs: "matSidenav", host: {
        "class": "mat-drawer mat-sidenav",
        // The sidenav container should not be focused on when used in side mode. See b/286459024 for
        // reference. Updates tabIndex of drawer/container to default to null if in side mode.
        "[attr.tabIndex]": '(mode !== "side") ? "-1" : null',
        // must prevent the browser from aligning text based on value
        "[attr.align]": "null",
        "[class.mat-drawer-end]": 'position === "end"',
        "[class.mat-drawer-over]": 'mode === "over"',
        "[class.mat-drawer-push]": 'mode === "push"',
        "[class.mat-drawer-side]": 'mode === "side"',
        "[class.mat-sidenav-fixed]": "fixedInViewport",
        "[style.top.px]": "fixedInViewport ? fixedTopGap : null",
        "[style.bottom.px]": "fixedInViewport ? fixedBottomGap : null"
      }, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, imports: [CdkScrollable], providers: [{ provide: MatDrawer, useExisting: MatSidenav }], template: '<div class="mat-drawer-inner-container" cdkScrollable #content>\r\n  <ng-content></ng-content>\r\n</div>\r\n' }]
    }], propDecorators: { fixedInViewport: [{
      type: Input
    }], fixedTopGap: [{
      type: Input
    }], fixedBottomGap: [{
      type: Input
    }] } });
    MatSidenavContainer = class _MatSidenavContainer extends MatDrawerContainer {
      _allDrawers = void 0;
      // We need an initializer here to avoid a TS error.
      _content = void 0;
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatSidenavContainer, deps: null, target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "17.0.0", version: "20.2.0-next.2", type: _MatSidenavContainer, isStandalone: true, selector: "mat-sidenav-container", host: { properties: { "class.mat-drawer-container-explicit-backdrop": "_backdropOverride" }, classAttribute: "mat-drawer-container mat-sidenav-container" }, providers: [
        {
          provide: MAT_DRAWER_CONTAINER,
          useExisting: _MatSidenavContainer
        },
        {
          provide: MatDrawerContainer,
          useExisting: _MatSidenavContainer
        }
      ], queries: [{ propertyName: "_content", first: true, predicate: MatSidenavContent, descendants: true }, { propertyName: "_allDrawers", predicate: MatSidenav, descendants: true }], exportAs: ["matSidenavContainer"], usesInheritance: true, ngImport: core_exports, template: '@if (hasBackdrop) {\n  <div class="mat-drawer-backdrop" (click)="_onBackdropClicked()"\n       [class.mat-drawer-shown]="_isShowingBackdrop()"></div>\n}\n\n<ng-content select="mat-sidenav"></ng-content>\n\n<ng-content select="mat-sidenav-content">\n</ng-content>\n\n@if (!_content) {\n  <mat-sidenav-content>\n    <ng-content></ng-content>\n  </mat-sidenav-content>\n}\n', styles: [".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color, var(--mat-sys-on-background));background-color:var(--mat-sidenav-content-background-color, var(--mat-sys-background));box-sizing:border-box;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color, color-mix(in srgb, var(--mat-sys-neutral-variant20) 40%, transparent))}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(forced-colors: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-content.mat-drawer-content-hidden{opacity:0}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;color:var(--mat-sidenav-container-text-color, var(--mat-sys-on-surface-variant));box-shadow:var(--mat-sidenav-container-elevation-shadow, none);background-color:var(--mat-sidenav-container-background-color, var(--mat-sys-surface));border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));width:var(--mat-sidenav-container-width, 360px);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(forced-colors: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(forced-colors: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-transition .mat-drawer{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating){visibility:hidden;box-shadow:none}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating) .mat-drawer-inner-container{display:none}.mat-drawer.mat-drawer-opened.mat-drawer-opened{transform:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto}.mat-sidenav-fixed{position:fixed}\n"], dependencies: [{ kind: "component", type: MatSidenavContent, selector: "mat-sidenav-content" }], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatSidenavContainer, decorators: [{
      type: Component,
      args: [{ selector: "mat-sidenav-container", exportAs: "matSidenavContainer", host: {
        "class": "mat-drawer-container mat-sidenav-container",
        "[class.mat-drawer-container-explicit-backdrop]": "_backdropOverride"
      }, changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, providers: [
        {
          provide: MAT_DRAWER_CONTAINER,
          useExisting: MatSidenavContainer
        },
        {
          provide: MatDrawerContainer,
          useExisting: MatSidenavContainer
        }
      ], imports: [MatSidenavContent], template: '@if (hasBackdrop) {\n  <div class="mat-drawer-backdrop" (click)="_onBackdropClicked()"\n       [class.mat-drawer-shown]="_isShowingBackdrop()"></div>\n}\n\n<ng-content select="mat-sidenav"></ng-content>\n\n<ng-content select="mat-sidenav-content">\n</ng-content>\n\n@if (!_content) {\n  <mat-sidenav-content>\n    <ng-content></ng-content>\n  </mat-sidenav-content>\n}\n', styles: [".mat-drawer-container{position:relative;z-index:1;color:var(--mat-sidenav-content-text-color, var(--mat-sys-on-background));background-color:var(--mat-sidenav-content-background-color, var(--mat-sys-background));box-sizing:border-box;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible;background-color:var(--mat-sidenav-scrim-color, color-mix(in srgb, var(--mat-sys-neutral-variant20) 40%, transparent))}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}@media(forced-colors: active){.mat-drawer-backdrop{opacity:.5}}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-content.mat-drawer-content-hidden{opacity:0}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;color:var(--mat-sidenav-container-text-color, var(--mat-sys-on-surface-variant));box-shadow:var(--mat-sidenav-container-elevation-shadow, none);background-color:var(--mat-sidenav-container-background-color, var(--mat-sys-surface));border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));width:var(--mat-sidenav-container-width, 360px);display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}@media(forced-colors: active){.mat-drawer,[dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}}@media(forced-colors: active){[dir=rtl] .mat-drawer,.mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0);border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .mat-drawer{border-top-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-left-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-right-radius:0;border-bottom-right-radius:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{border-top-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-bottom-right-radius:var(--mat-sidenav-container-shape, var(--mat-sys-corner-large));border-top-left-radius:0;border-bottom-left-radius:0;left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-transition .mat-drawer{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating){visibility:hidden;box-shadow:none}.mat-drawer:not(.mat-drawer-opened):not(.mat-drawer-animating) .mat-drawer-inner-container{display:none}.mat-drawer.mat-drawer-opened.mat-drawer-opened{transform:none}.mat-drawer-side{box-shadow:none;border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid}.mat-drawer-side.mat-drawer-end{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side{border-left-color:var(--mat-sidenav-container-divider-color, transparent);border-left-width:1px;border-left-style:solid;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-right-color:var(--mat-sidenav-container-divider-color, transparent);border-right-width:1px;border-right-style:solid;border-left:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto}.mat-sidenav-fixed{position:fixed}\n"] }]
    }], propDecorators: { _allDrawers: [{
      type: ContentChildren,
      args: [MatSidenav, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }], _content: [{
      type: ContentChild,
      args: [MatSidenavContent]
    }] } });
    MatSidenavModule = class _MatSidenavModule {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatSidenavModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatSidenavModule, imports: [
        MatCommonModule,
        CdkScrollableModule,
        MatDrawer,
        MatDrawerContainer,
        MatDrawerContent,
        MatSidenav,
        MatSidenavContainer,
        MatSidenavContent
      ], exports: [
        CdkScrollableModule,
        MatCommonModule,
        MatDrawer,
        MatDrawerContainer,
        MatDrawerContent,
        MatSidenav,
        MatSidenavContainer,
        MatSidenavContent
      ] });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatSidenavModule, imports: [
        MatCommonModule,
        CdkScrollableModule,
        CdkScrollableModule,
        MatCommonModule
      ] });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatSidenavModule, decorators: [{
      type: NgModule,
      args: [{
        imports: [
          MatCommonModule,
          CdkScrollableModule,
          MatDrawer,
          MatDrawerContainer,
          MatDrawerContent,
          MatSidenav,
          MatSidenavContainer,
          MatSidenavContent
        ],
        exports: [
          CdkScrollableModule,
          MatCommonModule,
          MatDrawer,
          MatDrawerContainer,
          MatDrawerContent,
          MatSidenav,
          MatSidenavContainer,
          MatSidenavContent
        ]
      }]
    }] });
  }
});

// node_modules/@angular/material/fesm2022/ripple.mjs
function distanceToFurthestCorner(x3, y3, rect) {
  const distX = Math.max(Math.abs(x3 - rect.left), Math.abs(x3 - rect.right));
  const distY = Math.max(Math.abs(y3 - rect.top), Math.abs(y3 - rect.bottom));
  return Math.sqrt(distX * distX + distY * distY);
}
var RippleState, RippleRef, passiveCapturingEventOptions$1, RippleEventManager, defaultRippleAnimationConfig, ignoreMouseEventsTimeout, passiveCapturingEventOptions, pointerDownEvents, pointerUpEvents, _MatRippleStylesLoader, RippleRenderer, MAT_RIPPLE_GLOBAL_OPTIONS, MatRipple;
var init_ripple = __esm({
  "node_modules/@angular/material/fesm2022/ripple.mjs"() {
    "use strict";
    init_platform();
    init_core();
    init_core();
    init_a11y();
    init_coercion();
    init_private();
    init_animation();
    (function(RippleState2) {
      RippleState2[RippleState2["FADING_IN"] = 0] = "FADING_IN";
      RippleState2[RippleState2["VISIBLE"] = 1] = "VISIBLE";
      RippleState2[RippleState2["FADING_OUT"] = 2] = "FADING_OUT";
      RippleState2[RippleState2["HIDDEN"] = 3] = "HIDDEN";
    })(RippleState || (RippleState = {}));
    RippleRef = class {
      _renderer;
      element;
      config;
      _animationForciblyDisabledThroughCss;
      /** Current state of the ripple. */
      state = RippleState.HIDDEN;
      constructor(_renderer, element, config, _animationForciblyDisabledThroughCss = false) {
        this._renderer = _renderer;
        this.element = element;
        this.config = config;
        this._animationForciblyDisabledThroughCss = _animationForciblyDisabledThroughCss;
      }
      /** Fades out the ripple element. */
      fadeOut() {
        this._renderer.fadeOutRipple(this);
      }
    };
    passiveCapturingEventOptions$1 = normalizePassiveListenerOptions({
      passive: true,
      capture: true
    });
    RippleEventManager = class {
      _events = /* @__PURE__ */ new Map();
      /** Adds an event handler. */
      addHandler(ngZone, name, element, handler) {
        const handlersForEvent = this._events.get(name);
        if (handlersForEvent) {
          const handlersForElement = handlersForEvent.get(element);
          if (handlersForElement) {
            handlersForElement.add(handler);
          } else {
            handlersForEvent.set(element, /* @__PURE__ */ new Set([handler]));
          }
        } else {
          this._events.set(name, /* @__PURE__ */ new Map([[element, /* @__PURE__ */ new Set([handler])]]));
          ngZone.runOutsideAngular(() => {
            document.addEventListener(name, this._delegateEventHandler, passiveCapturingEventOptions$1);
          });
        }
      }
      /** Removes an event handler. */
      removeHandler(name, element, handler) {
        const handlersForEvent = this._events.get(name);
        if (!handlersForEvent) {
          return;
        }
        const handlersForElement = handlersForEvent.get(element);
        if (!handlersForElement) {
          return;
        }
        handlersForElement.delete(handler);
        if (handlersForElement.size === 0) {
          handlersForEvent.delete(element);
        }
        if (handlersForEvent.size === 0) {
          this._events.delete(name);
          document.removeEventListener(name, this._delegateEventHandler, passiveCapturingEventOptions$1);
        }
      }
      /** Event handler that is bound and which dispatches the events to the different targets. */
      _delegateEventHandler = (event) => {
        const target = _getEventTarget(event);
        if (target) {
          this._events.get(event.type)?.forEach((handlers, element) => {
            if (element === target || element.contains(target)) {
              handlers.forEach((handler) => handler.handleEvent(event));
            }
          });
        }
      };
    };
    defaultRippleAnimationConfig = {
      enterDuration: 225,
      exitDuration: 150
    };
    ignoreMouseEventsTimeout = 800;
    passiveCapturingEventOptions = normalizePassiveListenerOptions({
      passive: true,
      capture: true
    });
    pointerDownEvents = ["mousedown", "touchstart"];
    pointerUpEvents = ["mouseup", "mouseleave", "touchend", "touchcancel"];
    _MatRippleStylesLoader = class __MatRippleStylesLoader {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: __MatRippleStylesLoader, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "20.2.0-next.2", type: __MatRippleStylesLoader, isStandalone: true, selector: "ng-component", host: { attributes: { "mat-ripple-style-loader": "" } }, ngImport: core_exports, template: "", isInline: true, styles: [".mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale3d(0, 0, 0);background-color:var(--mat-ripple-color, color-mix(in srgb, var(--mat-sys-on-surface) 10%, transparent))}@media(forced-colors: active){.mat-ripple-element{display:none}}.cdk-drag-preview .mat-ripple-element,.cdk-drag-placeholder .mat-ripple-element{display:none}\n"], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatRippleStylesLoader, decorators: [{
      type: Component,
      args: [{ template: "", changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None, host: { "mat-ripple-style-loader": "" }, styles: [".mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale3d(0, 0, 0);background-color:var(--mat-ripple-color, color-mix(in srgb, var(--mat-sys-on-surface) 10%, transparent))}@media(forced-colors: active){.mat-ripple-element{display:none}}.cdk-drag-preview .mat-ripple-element,.cdk-drag-placeholder .mat-ripple-element{display:none}\n"] }]
    }] });
    RippleRenderer = class _RippleRenderer {
      _target;
      _ngZone;
      _platform;
      /** Element where the ripples are being added to. */
      _containerElement;
      /** Element which triggers the ripple elements on mouse events. */
      _triggerElement;
      /** Whether the pointer is currently down or not. */
      _isPointerDown = false;
      /**
       * Map of currently active ripple references.
       * The ripple reference is mapped to its element event listeners.
       * The reason why `| null` is used is that event listeners are added only
       * when the condition is truthy (see the `_startFadeOutTransition` method).
       */
      _activeRipples = /* @__PURE__ */ new Map();
      /** Latest non-persistent ripple that was triggered. */
      _mostRecentTransientRipple;
      /** Time in milliseconds when the last touchstart event happened. */
      _lastTouchStartEvent;
      /** Whether pointer-up event listeners have been registered. */
      _pointerUpEventsRegistered = false;
      /**
       * Cached dimensions of the ripple container. Set when the first
       * ripple is shown and cleared once no more ripples are visible.
       */
      _containerRect;
      static _eventManager = new RippleEventManager();
      constructor(_target, _ngZone, elementOrElementRef, _platform, injector) {
        this._target = _target;
        this._ngZone = _ngZone;
        this._platform = _platform;
        if (_platform.isBrowser) {
          this._containerElement = coerceElement(elementOrElementRef);
        }
        if (injector) {
          injector.get(_CdkPrivateStyleLoader).load(_MatRippleStylesLoader);
        }
      }
      /**
       * Fades in a ripple at the given coordinates.
       * @param x Coordinate within the element, along the X axis at which to start the ripple.
       * @param y Coordinate within the element, along the Y axis at which to start the ripple.
       * @param config Extra ripple options.
       */
      fadeInRipple(x3, y3, config = {}) {
        const containerRect = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect();
        const animationConfig = __spreadValues(__spreadValues({}, defaultRippleAnimationConfig), config.animation);
        if (config.centered) {
          x3 = containerRect.left + containerRect.width / 2;
          y3 = containerRect.top + containerRect.height / 2;
        }
        const radius = config.radius || distanceToFurthestCorner(x3, y3, containerRect);
        const offsetX = x3 - containerRect.left;
        const offsetY = y3 - containerRect.top;
        const enterDuration = animationConfig.enterDuration;
        const ripple = document.createElement("div");
        ripple.classList.add("mat-ripple-element");
        ripple.style.left = `${offsetX - radius}px`;
        ripple.style.top = `${offsetY - radius}px`;
        ripple.style.height = `${radius * 2}px`;
        ripple.style.width = `${radius * 2}px`;
        if (config.color != null) {
          ripple.style.backgroundColor = config.color;
        }
        ripple.style.transitionDuration = `${enterDuration}ms`;
        this._containerElement.appendChild(ripple);
        const computedStyles = window.getComputedStyle(ripple);
        const userTransitionProperty = computedStyles.transitionProperty;
        const userTransitionDuration = computedStyles.transitionDuration;
        const animationForciblyDisabledThroughCss = userTransitionProperty === "none" || // Note: The canonical unit for serialized CSS `<time>` properties is seconds. Additionally
        // some browsers expand the duration for every property (in our case `opacity` and `transform`).
        userTransitionDuration === "0s" || userTransitionDuration === "0s, 0s" || // If the container is 0x0, it's likely `display: none`.
        containerRect.width === 0 && containerRect.height === 0;
        const rippleRef = new RippleRef(this, ripple, config, animationForciblyDisabledThroughCss);
        ripple.style.transform = "scale3d(1, 1, 1)";
        rippleRef.state = RippleState.FADING_IN;
        if (!config.persistent) {
          this._mostRecentTransientRipple = rippleRef;
        }
        let eventListeners = null;
        if (!animationForciblyDisabledThroughCss && (enterDuration || animationConfig.exitDuration)) {
          this._ngZone.runOutsideAngular(() => {
            const onTransitionEnd = () => {
              if (eventListeners) {
                eventListeners.fallbackTimer = null;
              }
              clearTimeout(fallbackTimer);
              this._finishRippleTransition(rippleRef);
            };
            const onTransitionCancel = () => this._destroyRipple(rippleRef);
            const fallbackTimer = setTimeout(onTransitionCancel, enterDuration + 100);
            ripple.addEventListener("transitionend", onTransitionEnd);
            ripple.addEventListener("transitioncancel", onTransitionCancel);
            eventListeners = { onTransitionEnd, onTransitionCancel, fallbackTimer };
          });
        }
        this._activeRipples.set(rippleRef, eventListeners);
        if (animationForciblyDisabledThroughCss || !enterDuration) {
          this._finishRippleTransition(rippleRef);
        }
        return rippleRef;
      }
      /** Fades out a ripple reference. */
      fadeOutRipple(rippleRef) {
        if (rippleRef.state === RippleState.FADING_OUT || rippleRef.state === RippleState.HIDDEN) {
          return;
        }
        const rippleEl = rippleRef.element;
        const animationConfig = __spreadValues(__spreadValues({}, defaultRippleAnimationConfig), rippleRef.config.animation);
        rippleEl.style.transitionDuration = `${animationConfig.exitDuration}ms`;
        rippleEl.style.opacity = "0";
        rippleRef.state = RippleState.FADING_OUT;
        if (rippleRef._animationForciblyDisabledThroughCss || !animationConfig.exitDuration) {
          this._finishRippleTransition(rippleRef);
        }
      }
      /** Fades out all currently active ripples. */
      fadeOutAll() {
        this._getActiveRipples().forEach((ripple) => ripple.fadeOut());
      }
      /** Fades out all currently active non-persistent ripples. */
      fadeOutAllNonPersistent() {
        this._getActiveRipples().forEach((ripple) => {
          if (!ripple.config.persistent) {
            ripple.fadeOut();
          }
        });
      }
      /** Sets up the trigger event listeners */
      setupTriggerEvents(elementOrElementRef) {
        const element = coerceElement(elementOrElementRef);
        if (!this._platform.isBrowser || !element || element === this._triggerElement) {
          return;
        }
        this._removeTriggerEvents();
        this._triggerElement = element;
        pointerDownEvents.forEach((type) => {
          _RippleRenderer._eventManager.addHandler(this._ngZone, type, element, this);
        });
      }
      /**
       * Handles all registered events.
       * @docs-private
       */
      handleEvent(event) {
        if (event.type === "mousedown") {
          this._onMousedown(event);
        } else if (event.type === "touchstart") {
          this._onTouchStart(event);
        } else {
          this._onPointerUp();
        }
        if (!this._pointerUpEventsRegistered) {
          this._ngZone.runOutsideAngular(() => {
            pointerUpEvents.forEach((type) => {
              this._triggerElement.addEventListener(type, this, passiveCapturingEventOptions);
            });
          });
          this._pointerUpEventsRegistered = true;
        }
      }
      /** Method that will be called if the fade-in or fade-in transition completed. */
      _finishRippleTransition(rippleRef) {
        if (rippleRef.state === RippleState.FADING_IN) {
          this._startFadeOutTransition(rippleRef);
        } else if (rippleRef.state === RippleState.FADING_OUT) {
          this._destroyRipple(rippleRef);
        }
      }
      /**
       * Starts the fade-out transition of the given ripple if it's not persistent and the pointer
       * is not held down anymore.
       */
      _startFadeOutTransition(rippleRef) {
        const isMostRecentTransientRipple = rippleRef === this._mostRecentTransientRipple;
        const { persistent } = rippleRef.config;
        rippleRef.state = RippleState.VISIBLE;
        if (!persistent && (!isMostRecentTransientRipple || !this._isPointerDown)) {
          rippleRef.fadeOut();
        }
      }
      /** Destroys the given ripple by removing it from the DOM and updating its state. */
      _destroyRipple(rippleRef) {
        const eventListeners = this._activeRipples.get(rippleRef) ?? null;
        this._activeRipples.delete(rippleRef);
        if (!this._activeRipples.size) {
          this._containerRect = null;
        }
        if (rippleRef === this._mostRecentTransientRipple) {
          this._mostRecentTransientRipple = null;
        }
        rippleRef.state = RippleState.HIDDEN;
        if (eventListeners !== null) {
          rippleRef.element.removeEventListener("transitionend", eventListeners.onTransitionEnd);
          rippleRef.element.removeEventListener("transitioncancel", eventListeners.onTransitionCancel);
          if (eventListeners.fallbackTimer !== null) {
            clearTimeout(eventListeners.fallbackTimer);
          }
        }
        rippleRef.element.remove();
      }
      /** Function being called whenever the trigger is being pressed using mouse. */
      _onMousedown(event) {
        const isFakeMousedown = isFakeMousedownFromScreenReader(event);
        const isSyntheticEvent = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + ignoreMouseEventsTimeout;
        if (!this._target.rippleDisabled && !isFakeMousedown && !isSyntheticEvent) {
          this._isPointerDown = true;
          this.fadeInRipple(event.clientX, event.clientY, this._target.rippleConfig);
        }
      }
      /** Function being called whenever the trigger is being pressed using touch. */
      _onTouchStart(event) {
        if (!this._target.rippleDisabled && !isFakeTouchstartFromScreenReader(event)) {
          this._lastTouchStartEvent = Date.now();
          this._isPointerDown = true;
          const touches = event.changedTouches;
          if (touches) {
            for (let i2 = 0; i2 < touches.length; i2++) {
              this.fadeInRipple(touches[i2].clientX, touches[i2].clientY, this._target.rippleConfig);
            }
          }
        }
      }
      /** Function being called whenever the trigger is being released. */
      _onPointerUp() {
        if (!this._isPointerDown) {
          return;
        }
        this._isPointerDown = false;
        this._getActiveRipples().forEach((ripple) => {
          const isVisible = ripple.state === RippleState.VISIBLE || ripple.config.terminateOnPointerUp && ripple.state === RippleState.FADING_IN;
          if (!ripple.config.persistent && isVisible) {
            ripple.fadeOut();
          }
        });
      }
      _getActiveRipples() {
        return Array.from(this._activeRipples.keys());
      }
      /** Removes previously registered event listeners from the trigger element. */
      _removeTriggerEvents() {
        const trigger = this._triggerElement;
        if (trigger) {
          pointerDownEvents.forEach((type) => _RippleRenderer._eventManager.removeHandler(type, trigger, this));
          if (this._pointerUpEventsRegistered) {
            pointerUpEvents.forEach((type) => trigger.removeEventListener(type, this, passiveCapturingEventOptions));
            this._pointerUpEventsRegistered = false;
          }
        }
      }
    };
    MAT_RIPPLE_GLOBAL_OPTIONS = new InjectionToken("mat-ripple-global-options");
    MatRipple = class _MatRipple {
      _elementRef = inject(ElementRef);
      _animationsDisabled = _animationsDisabled();
      /** Custom color for all ripples. */
      color;
      /** Whether the ripples should be visible outside the component's bounds. */
      unbounded;
      /**
       * Whether the ripple always originates from the center of the host element's bounds, rather
       * than originating from the location of the click event.
       */
      centered;
      /**
       * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius
       * will be the distance from the center of the ripple to the furthest corner of the host element's
       * bounding rectangle.
       */
      radius = 0;
      /**
       * Configuration for the ripple animation. Allows modifying the enter and exit animation
       * duration of the ripples. The animation durations will be overwritten if the
       * `NoopAnimationsModule` is being used.
       */
      animation;
      /**
       * Whether click events will not trigger the ripple. Ripples can be still launched manually
       * by using the `launch()` method.
       */
      get disabled() {
        return this._disabled;
      }
      set disabled(value) {
        if (value) {
          this.fadeOutAllNonPersistent();
        }
        this._disabled = value;
        this._setupTriggerEventsIfEnabled();
      }
      _disabled = false;
      /**
       * The element that triggers the ripple when click events are received.
       * Defaults to the directive's host element.
       */
      get trigger() {
        return this._trigger || this._elementRef.nativeElement;
      }
      set trigger(trigger) {
        this._trigger = trigger;
        this._setupTriggerEventsIfEnabled();
      }
      _trigger;
      /** Renderer for the ripple DOM manipulations. */
      _rippleRenderer;
      /** Options that are set globally for all ripples. */
      _globalOptions;
      /** @docs-private Whether ripple directive is initialized and the input bindings are set. */
      _isInitialized = false;
      constructor() {
        const ngZone = inject(NgZone);
        const platform = inject(Platform);
        const globalOptions = inject(MAT_RIPPLE_GLOBAL_OPTIONS, { optional: true });
        const injector = inject(Injector);
        this._globalOptions = globalOptions || {};
        this._rippleRenderer = new RippleRenderer(this, ngZone, this._elementRef, platform, injector);
      }
      ngOnInit() {
        this._isInitialized = true;
        this._setupTriggerEventsIfEnabled();
      }
      ngOnDestroy() {
        this._rippleRenderer._removeTriggerEvents();
      }
      /** Fades out all currently showing ripple elements. */
      fadeOutAll() {
        this._rippleRenderer.fadeOutAll();
      }
      /** Fades out all currently showing non-persistent ripple elements. */
      fadeOutAllNonPersistent() {
        this._rippleRenderer.fadeOutAllNonPersistent();
      }
      /**
       * Ripple configuration from the directive's input values.
       * @docs-private Implemented as part of RippleTarget
       */
      get rippleConfig() {
        return {
          centered: this.centered,
          radius: this.radius,
          color: this.color,
          animation: __spreadValues(__spreadValues(__spreadValues({}, this._globalOptions.animation), this._animationsDisabled ? { enterDuration: 0, exitDuration: 0 } : {}), this.animation),
          terminateOnPointerUp: this._globalOptions.terminateOnPointerUp
        };
      }
      /**
       * Whether ripples on pointer-down are disabled or not.
       * @docs-private Implemented as part of RippleTarget
       */
      get rippleDisabled() {
        return this.disabled || !!this._globalOptions.disabled;
      }
      /** Sets up the trigger event listeners if ripples are enabled. */
      _setupTriggerEventsIfEnabled() {
        if (!this.disabled && this._isInitialized) {
          this._rippleRenderer.setupTriggerEvents(this.trigger);
        }
      }
      /** Launches a manual ripple at the specified coordinated or just by the ripple config. */
      launch(configOrX, y3 = 0, config) {
        if (typeof configOrX === "number") {
          return this._rippleRenderer.fadeInRipple(configOrX, y3, __spreadValues(__spreadValues({}, this.rippleConfig), config));
        } else {
          return this._rippleRenderer.fadeInRipple(0, 0, __spreadValues(__spreadValues({}, this.rippleConfig), configOrX));
        }
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatRipple, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _MatRipple, isStandalone: true, selector: "[mat-ripple], [matRipple]", inputs: { color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], radius: ["matRippleRadius", "radius"], animation: ["matRippleAnimation", "animation"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"] }, host: { properties: { "class.mat-ripple-unbounded": "unbounded" }, classAttribute: "mat-ripple" }, exportAs: ["matRipple"], ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatRipple, decorators: [{
      type: Directive,
      args: [{
        selector: "[mat-ripple], [matRipple]",
        exportAs: "matRipple",
        host: {
          "class": "mat-ripple",
          "[class.mat-ripple-unbounded]": "unbounded"
        }
      }]
    }], ctorParameters: () => [], propDecorators: { color: [{
      type: Input,
      args: ["matRippleColor"]
    }], unbounded: [{
      type: Input,
      args: ["matRippleUnbounded"]
    }], centered: [{
      type: Input,
      args: ["matRippleCentered"]
    }], radius: [{
      type: Input,
      args: ["matRippleRadius"]
    }], animation: [{
      type: Input,
      args: ["matRippleAnimation"]
    }], disabled: [{
      type: Input,
      args: ["matRippleDisabled"]
    }], trigger: [{
      type: Input,
      args: ["matRippleTrigger"]
    }] } });
  }
});

// node_modules/@angular/material/fesm2022/ripple-loader.mjs
var eventListenerOptions, rippleInteractionEvents, matRippleUninitialized, matRippleClassName, matRippleCentered, matRippleDisabled, MatRippleLoader;
var init_ripple_loader = __esm({
  "node_modules/@angular/material/fesm2022/ripple-loader.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_platform();
    init_animation();
    init_ripple();
    eventListenerOptions = { capture: true };
    rippleInteractionEvents = ["focus", "mousedown", "mouseenter", "touchstart"];
    matRippleUninitialized = "mat-ripple-loader-uninitialized";
    matRippleClassName = "mat-ripple-loader-class-name";
    matRippleCentered = "mat-ripple-loader-centered";
    matRippleDisabled = "mat-ripple-loader-disabled";
    MatRippleLoader = class _MatRippleLoader {
      _document = inject(DOCUMENT);
      _animationsDisabled = _animationsDisabled();
      _globalRippleOptions = inject(MAT_RIPPLE_GLOBAL_OPTIONS, { optional: true });
      _platform = inject(Platform);
      _ngZone = inject(NgZone);
      _injector = inject(Injector);
      _eventCleanups;
      _hosts = /* @__PURE__ */ new Map();
      constructor() {
        const renderer = inject(RendererFactory2).createRenderer(null, null);
        this._eventCleanups = this._ngZone.runOutsideAngular(() => rippleInteractionEvents.map((name) => renderer.listen(this._document, name, this._onInteraction, eventListenerOptions)));
      }
      ngOnDestroy() {
        const hosts = this._hosts.keys();
        for (const host of hosts) {
          this.destroyRipple(host);
        }
        this._eventCleanups.forEach((cleanup) => cleanup());
      }
      /**
       * Configures the ripple that will be rendered by the ripple loader.
       *
       * Stores the given information about how the ripple should be configured on the host
       * element so that it can later be retrived & used when the ripple is actually created.
       */
      configureRipple(host, config) {
        host.setAttribute(matRippleUninitialized, this._globalRippleOptions?.namespace ?? "");
        if (config.className || !host.hasAttribute(matRippleClassName)) {
          host.setAttribute(matRippleClassName, config.className || "");
        }
        if (config.centered) {
          host.setAttribute(matRippleCentered, "");
        }
        if (config.disabled) {
          host.setAttribute(matRippleDisabled, "");
        }
      }
      /** Sets the disabled state on the ripple instance corresponding to the given host element. */
      setDisabled(host, disabled) {
        const ripple = this._hosts.get(host);
        if (ripple) {
          ripple.target.rippleDisabled = disabled;
          if (!disabled && !ripple.hasSetUpEvents) {
            ripple.hasSetUpEvents = true;
            ripple.renderer.setupTriggerEvents(host);
          }
        } else if (disabled) {
          host.setAttribute(matRippleDisabled, "");
        } else {
          host.removeAttribute(matRippleDisabled);
        }
      }
      /**
       * Handles creating and attaching component internals
       * when a component is initially interacted with.
       */
      _onInteraction = (event) => {
        const eventTarget = _getEventTarget(event);
        if (eventTarget instanceof HTMLElement) {
          const element = eventTarget.closest(`[${matRippleUninitialized}="${this._globalRippleOptions?.namespace ?? ""}"]`);
          if (element) {
            this._createRipple(element);
          }
        }
      };
      /** Creates a MatRipple and appends it to the given element. */
      _createRipple(host) {
        if (!this._document || this._hosts.has(host)) {
          return;
        }
        host.querySelector(".mat-ripple")?.remove();
        const rippleEl = this._document.createElement("span");
        rippleEl.classList.add("mat-ripple", host.getAttribute(matRippleClassName));
        host.append(rippleEl);
        const globalOptions = this._globalRippleOptions;
        const enterDuration = this._animationsDisabled ? 0 : globalOptions?.animation?.enterDuration ?? defaultRippleAnimationConfig.enterDuration;
        const exitDuration = this._animationsDisabled ? 0 : globalOptions?.animation?.exitDuration ?? defaultRippleAnimationConfig.exitDuration;
        const target = {
          rippleDisabled: this._animationsDisabled || globalOptions?.disabled || host.hasAttribute(matRippleDisabled),
          rippleConfig: {
            centered: host.hasAttribute(matRippleCentered),
            terminateOnPointerUp: globalOptions?.terminateOnPointerUp,
            animation: {
              enterDuration,
              exitDuration
            }
          }
        };
        const renderer = new RippleRenderer(target, this._ngZone, rippleEl, this._platform, this._injector);
        const hasSetUpEvents = !target.rippleDisabled;
        if (hasSetUpEvents) {
          renderer.setupTriggerEvents(host);
        }
        this._hosts.set(host, {
          target,
          renderer,
          hasSetUpEvents
        });
        host.removeAttribute(matRippleUninitialized);
      }
      destroyRipple(host) {
        const ripple = this._hosts.get(host);
        if (ripple) {
          ripple.renderer._removeTriggerEvents();
          this._hosts.delete(host);
        }
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatRippleLoader, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatRippleLoader, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatRippleLoader, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [] });
  }
});

// node_modules/@angular/material/fesm2022/structural-styles.mjs
var _StructuralStylesLoader;
var init_structural_styles = __esm({
  "node_modules/@angular/material/fesm2022/structural-styles.mjs"() {
    "use strict";
    init_core();
    init_core();
    _StructuralStylesLoader = class __StructuralStylesLoader {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: __StructuralStylesLoader, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "20.2.0-next.2", type: __StructuralStylesLoader, isStandalone: true, selector: "structural-styles", ngImport: core_exports, template: "", isInline: true, styles: ['.mat-focus-indicator{position:relative}.mat-focus-indicator::before{top:0;left:0;right:0;bottom:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border-width:var(--mat-focus-indicator-border-width, 3px);border-style:var(--mat-focus-indicator-border-style, solid);border-color:var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus::before{content:""}@media(forced-colors: active){html{--mat-focus-indicator-display: block}}\n'], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _StructuralStylesLoader, decorators: [{
      type: Component,
      args: [{ selector: "structural-styles", encapsulation: ViewEncapsulation.None, template: "", changeDetection: ChangeDetectionStrategy.OnPush, styles: ['.mat-focus-indicator{position:relative}.mat-focus-indicator::before{top:0;left:0;right:0;bottom:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border-width:var(--mat-focus-indicator-border-width, 3px);border-style:var(--mat-focus-indicator-border-style, solid);border-color:var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus::before{content:""}@media(forced-colors: active){html{--mat-focus-indicator-display: block}}\n'] }]
    }] });
  }
});

// node_modules/@angular/material/fesm2022/icon-button.mjs
function transformTabIndex(value) {
  return value == null ? void 0 : numberAttribute(value);
}
var MAT_BUTTON_CONFIG, MatButtonBase, MatIconButton;
var init_icon_button = __esm({
  "node_modules/@angular/material/fesm2022/icon-button.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_a11y();
    init_private();
    init_ripple_loader();
    init_structural_styles();
    init_animation();
    MAT_BUTTON_CONFIG = new InjectionToken("MAT_BUTTON_CONFIG");
    MatButtonBase = class _MatButtonBase {
      _elementRef = inject(ElementRef);
      _ngZone = inject(NgZone);
      _animationsDisabled = _animationsDisabled();
      _config = inject(MAT_BUTTON_CONFIG, { optional: true });
      _focusMonitor = inject(FocusMonitor);
      _cleanupClick;
      _renderer = inject(Renderer2);
      /**
       * Handles the lazy creation of the MatButton ripple.
       * Used to improve initial load time of large applications.
       */
      _rippleLoader = inject(MatRippleLoader);
      /** Whether the button is set on an anchor node. */
      _isAnchor;
      /** Whether this button is a FAB. Used to apply the correct class on the ripple. */
      _isFab = false;
      /**
       * Theme color of the button. This API is supported in M2 themes only, it has
       * no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/button/styling.
       *
       * For information on applying color variants in M3, see
       * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants
       */
      color;
      /** Whether the ripple effect is disabled or not. */
      get disableRipple() {
        return this._disableRipple;
      }
      set disableRipple(value) {
        this._disableRipple = value;
        this._updateRippleDisabled();
      }
      _disableRipple = false;
      /** Whether the button is disabled. */
      get disabled() {
        return this._disabled;
      }
      set disabled(value) {
        this._disabled = value;
        this._updateRippleDisabled();
      }
      _disabled = false;
      /** `aria-disabled` value of the button. */
      ariaDisabled;
      /**
       * Natively disabled buttons prevent focus and any pointer events from reaching the button.
       * In some scenarios this might not be desirable, because it can prevent users from finding out
       * why the button is disabled (e.g. via tooltip). This is also useful for buttons that may
       * become disabled when activated, which would cause focus to be transferred to the document
       * body instead of remaining on the button.
       *
       * Enabling this input will change the button so that it is styled to be disabled and will be
       * marked as `aria-disabled`, but it will allow the button to receive events and focus.
       *
       * Note that by enabling this, you need to set the `tabindex` yourself if the button isn't
       * meant to be tabbable and you have to prevent the button action (e.g. form submissions).
       */
      disabledInteractive;
      /** Tab index for the button. */
      tabIndex;
      /**
       * Backwards-compatibility input that handles pre-existing `[tabindex]` bindings.
       * @docs-private
       */
      set _tabindex(value) {
        this.tabIndex = value;
      }
      constructor() {
        inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);
        const element = this._elementRef.nativeElement;
        this._isAnchor = element.tagName === "A";
        this.disabledInteractive = this._config?.disabledInteractive ?? false;
        this.color = this._config?.color ?? null;
        this._rippleLoader?.configureRipple(element, { className: "mat-mdc-button-ripple" });
      }
      ngAfterViewInit() {
        this._focusMonitor.monitor(this._elementRef, true);
        if (this._isAnchor) {
          this._setupAsAnchor();
        }
      }
      ngOnDestroy() {
        this._cleanupClick?.();
        this._focusMonitor.stopMonitoring(this._elementRef);
        this._rippleLoader?.destroyRipple(this._elementRef.nativeElement);
      }
      /** Focuses the button. */
      focus(origin = "program", options) {
        if (origin) {
          this._focusMonitor.focusVia(this._elementRef.nativeElement, origin, options);
        } else {
          this._elementRef.nativeElement.focus(options);
        }
      }
      _getAriaDisabled() {
        if (this.ariaDisabled != null) {
          return this.ariaDisabled;
        }
        if (this._isAnchor) {
          return this.disabled || null;
        }
        return this.disabled && this.disabledInteractive ? true : null;
      }
      _getDisabledAttribute() {
        return this.disabledInteractive || !this.disabled ? null : true;
      }
      _updateRippleDisabled() {
        this._rippleLoader?.setDisabled(this._elementRef.nativeElement, this.disableRipple || this.disabled);
      }
      _getTabIndex() {
        if (this._isAnchor) {
          return this.disabled && !this.disabledInteractive ? -1 : this.tabIndex;
        }
        return this.tabIndex;
      }
      _setupAsAnchor() {
        this._cleanupClick = this._ngZone.runOutsideAngular(() => this._renderer.listen(this._elementRef.nativeElement, "click", (event) => {
          if (this.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
          }
        }));
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatButtonBase, deps: [], target: FactoryTarget.Directive });
      static \u0275dir = \u0275\u0275ngDeclareDirective({ minVersion: "16.1.0", version: "20.2.0-next.2", type: _MatButtonBase, isStandalone: true, inputs: { color: "color", disableRipple: ["disableRipple", "disableRipple", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], ariaDisabled: ["aria-disabled", "ariaDisabled", booleanAttribute], disabledInteractive: ["disabledInteractive", "disabledInteractive", booleanAttribute], tabIndex: ["tabIndex", "tabIndex", transformTabIndex], _tabindex: ["tabindex", "_tabindex", transformTabIndex] }, host: { properties: { "class": 'color ? "mat-" + color : ""', "attr.disabled": "_getDisabledAttribute()", "attr.aria-disabled": "_getAriaDisabled()", "attr.tabindex": "_getTabIndex()", "class.mat-mdc-button-disabled": "disabled", "class.mat-mdc-button-disabled-interactive": "disabledInteractive", "class.mat-unthemed": "!color", "class._mat-animation-noopable": "_animationsDisabled" }, classAttribute: "mat-mdc-button-base" }, ngImport: core_exports });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatButtonBase, decorators: [{
      type: Directive,
      args: [{
        host: {
          // Add a class that applies to all buttons. This makes it easier to target if somebody
          // wants to target all Material buttons.
          "class": "mat-mdc-button-base",
          "[class]": 'color ? "mat-" + color : ""',
          "[attr.disabled]": "_getDisabledAttribute()",
          "[attr.aria-disabled]": "_getAriaDisabled()",
          "[attr.tabindex]": "_getTabIndex()",
          "[class.mat-mdc-button-disabled]": "disabled",
          "[class.mat-mdc-button-disabled-interactive]": "disabledInteractive",
          "[class.mat-unthemed]": "!color",
          "[class._mat-animation-noopable]": "_animationsDisabled"
        }
      }]
    }], ctorParameters: () => [], propDecorators: { color: [{
      type: Input
    }], disableRipple: [{
      type: Input,
      args: [{ transform: booleanAttribute }]
    }], disabled: [{
      type: Input,
      args: [{ transform: booleanAttribute }]
    }], ariaDisabled: [{
      type: Input,
      args: [{ transform: booleanAttribute, alias: "aria-disabled" }]
    }], disabledInteractive: [{
      type: Input,
      args: [{ transform: booleanAttribute }]
    }], tabIndex: [{
      type: Input,
      args: [{ transform: transformTabIndex }]
    }], _tabindex: [{
      type: Input,
      args: [{ alias: "tabindex", transform: transformTabIndex }]
    }] } });
    MatIconButton = class _MatIconButton extends MatButtonBase {
      constructor() {
        super();
        this._rippleLoader.configureRipple(this._elementRef.nativeElement, { centered: true });
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatIconButton, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _MatIconButton, isStandalone: true, selector: "button[mat-icon-button], a[mat-icon-button], button[matIconButton], a[matIconButton]", host: { classAttribute: "mdc-icon-button mat-mdc-icon-button" }, exportAs: ["matButton", "matAnchor"], usesInheritance: true, ngImport: core_exports, template: `<span class="mat-mdc-button-persistent-ripple mdc-icon-button__ripple"></span>

<ng-content></ng-content>

<!--
  The indicator can't be directly on the button, because MDC uses ::before for high contrast
  indication and it can't be on the ripple, because it has a border radius and overflow: hidden.
-->
<span class="mat-focus-indicator"></span>

<span class="mat-mdc-button-touch-target"></span>
`, styles: ['.mat-mdc-icon-button{-webkit-user-select:none;user-select:none;display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:rgba(0,0,0,0);fill:currentColor;text-decoration:none;cursor:pointer;z-index:0;overflow:visible;border-radius:var(--mat-icon-button-container-shape, var(--mat-sys-corner-full, 50%));flex-shrink:0;text-align:center;width:var(--mat-icon-button-state-layer-size, 40px);height:var(--mat-icon-button-state-layer-size, 40px);padding:calc(calc(var(--mat-icon-button-state-layer-size, 40px) - var(--mat-icon-button-icon-size, 24px)) / 2);font-size:var(--mat-icon-button-icon-size, 24px);color:var(--mat-icon-button-icon-color, var(--mat-sys-on-surface-variant));-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-icon-button .mat-mdc-button-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-icon-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-icon-button .mdc-button__label,.mat-mdc-icon-button .mat-icon{z-index:1;position:relative}.mat-mdc-icon-button .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit}.mat-mdc-icon-button:focus>.mat-focus-indicator::before{content:"";border-radius:inherit}.mat-mdc-icon-button .mat-ripple-element{background-color:var(--mat-icon-button-ripple-color, color-mix(in srgb, var(--mat-sys-on-surface-variant) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-icon-button-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-icon-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-icon-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-icon-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-icon-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-icon-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-icon-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-icon-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-icon-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-icon-button-touch-target-size, 48px);display:var(--mat-icon-button-touch-target-display, block);left:50%;width:var(--mat-icon-button-touch-target-size, 48px);transform:translate(-50%, -50%)}.mat-mdc-icon-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-icon-button[disabled],.mat-mdc-icon-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-icon-button-disabled-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-icon-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-icon-button img,.mat-mdc-icon-button svg{width:var(--mat-icon-button-icon-size, 24px);height:var(--mat-icon-button-icon-size, 24px);vertical-align:baseline}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple{border-radius:var(--mat-icon-button-container-shape, var(--mat-sys-corner-full, 50%))}.mat-mdc-icon-button[hidden]{display:none}.mat-mdc-icon-button.mat-unthemed:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-primary:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-accent:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-warn:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}\n', "@media(forced-colors: active){.mat-mdc-button:not(.mdc-button--outlined),.mat-mdc-unelevated-button:not(.mdc-button--outlined),.mat-mdc-raised-button:not(.mdc-button--outlined),.mat-mdc-outlined-button:not(.mdc-button--outlined),.mat-mdc-button-base.mat-tonal-button,.mat-mdc-icon-button.mat-mdc-icon-button,.mat-mdc-outlined-button .mdc-button__ripple{outline:solid 1px}}\n"], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatIconButton, decorators: [{
      type: Component,
      args: [{ selector: `button[mat-icon-button], a[mat-icon-button], button[matIconButton], a[matIconButton]`, host: {
        "class": "mdc-icon-button mat-mdc-icon-button"
      }, exportAs: "matButton, matAnchor", encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: `<span class="mat-mdc-button-persistent-ripple mdc-icon-button__ripple"></span>

<ng-content></ng-content>

<!--
  The indicator can't be directly on the button, because MDC uses ::before for high contrast
  indication and it can't be on the ripple, because it has a border radius and overflow: hidden.
-->
<span class="mat-focus-indicator"></span>

<span class="mat-mdc-button-touch-target"></span>
`, styles: ['.mat-mdc-icon-button{-webkit-user-select:none;user-select:none;display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:rgba(0,0,0,0);fill:currentColor;text-decoration:none;cursor:pointer;z-index:0;overflow:visible;border-radius:var(--mat-icon-button-container-shape, var(--mat-sys-corner-full, 50%));flex-shrink:0;text-align:center;width:var(--mat-icon-button-state-layer-size, 40px);height:var(--mat-icon-button-state-layer-size, 40px);padding:calc(calc(var(--mat-icon-button-state-layer-size, 40px) - var(--mat-icon-button-icon-size, 24px)) / 2);font-size:var(--mat-icon-button-icon-size, 24px);color:var(--mat-icon-button-icon-color, var(--mat-sys-on-surface-variant));-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-icon-button .mat-mdc-button-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-icon-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-icon-button .mdc-button__label,.mat-mdc-icon-button .mat-icon{z-index:1;position:relative}.mat-mdc-icon-button .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit}.mat-mdc-icon-button:focus>.mat-focus-indicator::before{content:"";border-radius:inherit}.mat-mdc-icon-button .mat-ripple-element{background-color:var(--mat-icon-button-ripple-color, color-mix(in srgb, var(--mat-sys-on-surface-variant) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-icon-button-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-icon-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-icon-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-icon-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-icon-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-icon-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-icon-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-icon-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-icon-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-icon-button-touch-target-size, 48px);display:var(--mat-icon-button-touch-target-display, block);left:50%;width:var(--mat-icon-button-touch-target-size, 48px);transform:translate(-50%, -50%)}.mat-mdc-icon-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-icon-button[disabled],.mat-mdc-icon-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-icon-button-disabled-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-icon-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-icon-button img,.mat-mdc-icon-button svg{width:var(--mat-icon-button-icon-size, 24px);height:var(--mat-icon-button-icon-size, 24px);vertical-align:baseline}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple{border-radius:var(--mat-icon-button-container-shape, var(--mat-sys-corner-full, 50%))}.mat-mdc-icon-button[hidden]{display:none}.mat-mdc-icon-button.mat-unthemed:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-primary:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-accent:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-warn:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}\n', "@media(forced-colors: active){.mat-mdc-button:not(.mdc-button--outlined),.mat-mdc-unelevated-button:not(.mdc-button--outlined),.mat-mdc-raised-button:not(.mdc-button--outlined),.mat-mdc-outlined-button:not(.mdc-button--outlined),.mat-mdc-button-base.mat-tonal-button,.mat-mdc-icon-button.mat-mdc-icon-button,.mat-mdc-outlined-button .mdc-button__ripple{outline:solid 1px}}\n"] }]
    }], ctorParameters: () => [] });
  }
});

// node_modules/@angular/material/fesm2022/ripple-module.mjs
var MatRippleModule;
var init_ripple_module = __esm({
  "node_modules/@angular/material/fesm2022/ripple-module.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_common_module();
    init_ripple();
    MatRippleModule = class _MatRippleModule {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatRippleModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatRippleModule, imports: [MatCommonModule, MatRipple], exports: [MatRipple, MatCommonModule] });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatRippleModule, imports: [MatCommonModule, MatCommonModule] });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatRippleModule, decorators: [{
      type: NgModule,
      args: [{
        imports: [MatCommonModule, MatRipple],
        exports: [MatRipple, MatCommonModule]
      }]
    }] });
  }
});

// node_modules/@angular/material/fesm2022/button.mjs
function _inferAppearance(button) {
  if (button.hasAttribute("mat-raised-button")) {
    return "elevated";
  }
  if (button.hasAttribute("mat-stroked-button")) {
    return "outlined";
  }
  if (button.hasAttribute("mat-flat-button")) {
    return "filled";
  }
  if (button.hasAttribute("mat-button")) {
    return "text";
  }
  return null;
}
function MAT_FAB_DEFAULT_OPTIONS_FACTORY() {
  return {
    // The FAB by default has its color set to accent.
    color: "accent"
  };
}
var APPEARANCE_CLASSES, MatButton, MAT_FAB_DEFAULT_OPTIONS, defaults, MatFabButton, MatMiniFabButton, MatButtonModule;
var init_button = __esm({
  "node_modules/@angular/material/fesm2022/button.mjs"() {
    "use strict";
    init_icon_button();
    init_core();
    init_core();
    init_ripple_module();
    init_common_module();
    APPEARANCE_CLASSES = /* @__PURE__ */ new Map([
      ["text", ["mat-mdc-button"]],
      ["filled", ["mdc-button--unelevated", "mat-mdc-unelevated-button"]],
      ["elevated", ["mdc-button--raised", "mat-mdc-raised-button"]],
      ["outlined", ["mdc-button--outlined", "mat-mdc-outlined-button"]],
      ["tonal", ["mat-tonal-button"]]
    ]);
    MatButton = class _MatButton extends MatButtonBase {
      /** Appearance of the button. */
      get appearance() {
        return this._appearance;
      }
      set appearance(value) {
        this.setAppearance(value || this._config?.defaultAppearance || "text");
      }
      _appearance = null;
      constructor() {
        super();
        const inferredAppearance = _inferAppearance(this._elementRef.nativeElement);
        if (inferredAppearance) {
          this.setAppearance(inferredAppearance);
        }
      }
      /** Programmatically sets the appearance of the button. */
      setAppearance(appearance) {
        if (appearance === this._appearance) {
          return;
        }
        const classList = this._elementRef.nativeElement.classList;
        const previousClasses = this._appearance ? APPEARANCE_CLASSES.get(this._appearance) : null;
        const newClasses = APPEARANCE_CLASSES.get(appearance);
        if ((typeof ngDevMode === "undefined" || ngDevMode) && !newClasses) {
          throw new Error(`Unsupported MatButton appearance "${appearance}"`);
        }
        if (previousClasses) {
          classList.remove(...previousClasses);
        }
        classList.add(...newClasses);
        this._appearance = appearance;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatButton, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _MatButton, isStandalone: true, selector: "\n    button[matButton], a[matButton], button[mat-button], button[mat-raised-button],\n    button[mat-flat-button], button[mat-stroked-button], a[mat-button], a[mat-raised-button],\n    a[mat-flat-button], a[mat-stroked-button]\n  ", inputs: { appearance: ["matButton", "appearance"] }, host: { classAttribute: "mdc-button" }, exportAs: ["matButton", "matAnchor"], usesInheritance: true, ngImport: core_exports, template: `<span
    class="mat-mdc-button-persistent-ripple"
    [class.mdc-button__ripple]="!_isFab"
    [class.mdc-fab__ripple]="_isFab"></span>

<ng-content select=".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])">
</ng-content>

<span class="mdc-button__label"><ng-content></ng-content></span>

<ng-content select=".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]">
</ng-content>

<!--
  The indicator can't be directly on the button, because MDC uses ::before for high contrast
  indication and it can't be on the ripple, because it has a border radius and overflow: hidden.
-->
<span class="mat-focus-indicator"></span>

<span class="mat-mdc-button-touch-target"></span>
`, styles: ['.mat-mdc-button-base{text-decoration:none}.mat-mdc-button-base .mat-icon{min-height:fit-content;flex-shrink:0}.mdc-button{-webkit-user-select:none;user-select:none;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0);padding:0 8px}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__label{position:relative}.mat-mdc-button{padding:0 var(--mat-button-text-horizontal-padding, 12px);height:var(--mat-button-text-container-height, 40px);font-family:var(--mat-button-text-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-button-text-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-button-text-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mat-button-text-label-text-transform);font-weight:var(--mat-button-text-label-text-weight, var(--mat-sys-label-large-weight))}.mat-mdc-button,.mat-mdc-button .mdc-button__ripple{border-radius:var(--mat-button-text-container-shape, var(--mat-sys-corner-full))}.mat-mdc-button:not(:disabled){color:var(--mat-button-text-label-text-color, var(--mat-sys-primary))}.mat-mdc-button[disabled],.mat-mdc-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-button-text-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-button:has(.material-icons,mat-icon,[matButtonIcon]){padding:0 var(--mat-button-text-with-icon-horizontal-padding, 16px)}.mat-mdc-button>.mat-icon{margin-right:var(--mat-button-text-icon-spacing, 8px);margin-left:var(--mat-button-text-icon-offset, -4px)}[dir=rtl] .mat-mdc-button>.mat-icon{margin-right:var(--mat-button-text-icon-offset, -4px);margin-left:var(--mat-button-text-icon-spacing, 8px)}.mat-mdc-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-text-icon-offset, -4px);margin-left:var(--mat-button-text-icon-spacing, 8px)}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-text-icon-spacing, 8px);margin-left:var(--mat-button-text-icon-offset, -4px)}.mat-mdc-button .mat-ripple-element{background-color:var(--mat-button-text-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-text-state-layer-color, var(--mat-sys-primary))}.mat-mdc-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-text-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-text-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-text-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-text-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-button-text-touch-target-size, 48px);display:var(--mat-button-text-touch-target-display, block);left:0;right:0;transform:translateY(-50%)}.mat-mdc-unelevated-button{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mat-button-filled-container-height, 40px);font-family:var(--mat-button-filled-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-button-filled-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-button-filled-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mat-button-filled-label-text-transform);font-weight:var(--mat-button-filled-label-text-weight, var(--mat-sys-label-large-weight));padding:0 var(--mat-button-filled-horizontal-padding, 24px)}.mat-mdc-unelevated-button>.mat-icon{margin-right:var(--mat-button-filled-icon-spacing, 8px);margin-left:var(--mat-button-filled-icon-offset, -8px)}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon{margin-right:var(--mat-button-filled-icon-offset, -8px);margin-left:var(--mat-button-filled-icon-spacing, 8px)}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-filled-icon-offset, -8px);margin-left:var(--mat-button-filled-icon-spacing, 8px)}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-filled-icon-spacing, 8px);margin-left:var(--mat-button-filled-icon-offset, -8px)}.mat-mdc-unelevated-button .mat-ripple-element{background-color:var(--mat-button-filled-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-filled-state-layer-color, var(--mat-sys-on-primary))}.mat-mdc-unelevated-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-filled-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-unelevated-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-filled-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-unelevated-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-filled-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-unelevated-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-filled-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-unelevated-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-button-filled-touch-target-size, 48px);display:var(--mat-button-filled-touch-target-display, block);left:0;right:0;transform:translateY(-50%)}.mat-mdc-unelevated-button:not(:disabled){color:var(--mat-button-filled-label-text-color, var(--mat-sys-on-primary));background-color:var(--mat-button-filled-container-color, var(--mat-sys-primary))}.mat-mdc-unelevated-button,.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mat-button-filled-container-shape, var(--mat-sys-corner-full))}.mat-mdc-unelevated-button[disabled],.mat-mdc-unelevated-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-button-filled-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-button-filled-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-unelevated-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-raised-button{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);box-shadow:var(--mat-button-protected-container-elevation-shadow, var(--mat-sys-level1));height:var(--mat-button-protected-container-height, 40px);font-family:var(--mat-button-protected-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-button-protected-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-button-protected-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mat-button-protected-label-text-transform);font-weight:var(--mat-button-protected-label-text-weight, var(--mat-sys-label-large-weight));padding:0 var(--mat-button-protected-horizontal-padding, 24px)}.mat-mdc-raised-button>.mat-icon{margin-right:var(--mat-button-protected-icon-spacing, 8px);margin-left:var(--mat-button-protected-icon-offset, -8px)}[dir=rtl] .mat-mdc-raised-button>.mat-icon{margin-right:var(--mat-button-protected-icon-offset, -8px);margin-left:var(--mat-button-protected-icon-spacing, 8px)}.mat-mdc-raised-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-protected-icon-offset, -8px);margin-left:var(--mat-button-protected-icon-spacing, 8px)}[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-protected-icon-spacing, 8px);margin-left:var(--mat-button-protected-icon-offset, -8px)}.mat-mdc-raised-button .mat-ripple-element{background-color:var(--mat-button-protected-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-protected-state-layer-color, var(--mat-sys-primary))}.mat-mdc-raised-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-protected-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-raised-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-protected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-raised-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-protected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-raised-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-protected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-raised-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-button-protected-touch-target-size, 48px);display:var(--mat-button-protected-touch-target-display, block);left:0;right:0;transform:translateY(-50%)}.mat-mdc-raised-button:not(:disabled){color:var(--mat-button-protected-label-text-color, var(--mat-sys-primary));background-color:var(--mat-button-protected-container-color, var(--mat-sys-surface))}.mat-mdc-raised-button,.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mat-button-protected-container-shape, var(--mat-sys-corner-full))}.mat-mdc-raised-button:hover{box-shadow:var(--mat-button-protected-hover-container-elevation-shadow, var(--mat-sys-level2))}.mat-mdc-raised-button:focus{box-shadow:var(--mat-button-protected-focus-container-elevation-shadow, var(--mat-sys-level1))}.mat-mdc-raised-button:active,.mat-mdc-raised-button:focus:active{box-shadow:var(--mat-button-protected-pressed-container-elevation-shadow, var(--mat-sys-level1))}.mat-mdc-raised-button[disabled],.mat-mdc-raised-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-button-protected-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-button-protected-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-raised-button[disabled].mat-mdc-button-disabled,.mat-mdc-raised-button.mat-mdc-button-disabled.mat-mdc-button-disabled{box-shadow:var(--mat-button-protected-disabled-container-elevation-shadow, var(--mat-sys-level0))}.mat-mdc-raised-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-outlined-button{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mat-button-outlined-container-height, 40px);font-family:var(--mat-button-outlined-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-button-outlined-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-button-outlined-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mat-button-outlined-label-text-transform);font-weight:var(--mat-button-outlined-label-text-weight, var(--mat-sys-label-large-weight));border-radius:var(--mat-button-outlined-container-shape, var(--mat-sys-corner-full));border-width:var(--mat-button-outlined-outline-width, 1px);padding:0 var(--mat-button-outlined-horizontal-padding, 24px)}.mat-mdc-outlined-button>.mat-icon{margin-right:var(--mat-button-outlined-icon-spacing, 8px);margin-left:var(--mat-button-outlined-icon-offset, -8px)}[dir=rtl] .mat-mdc-outlined-button>.mat-icon{margin-right:var(--mat-button-outlined-icon-offset, -8px);margin-left:var(--mat-button-outlined-icon-spacing, 8px)}.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-outlined-icon-offset, -8px);margin-left:var(--mat-button-outlined-icon-spacing, 8px)}[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-outlined-icon-spacing, 8px);margin-left:var(--mat-button-outlined-icon-offset, -8px)}.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-button-outlined-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-outlined-state-layer-color, var(--mat-sys-primary))}.mat-mdc-outlined-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-outlined-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-outlined-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-outlined-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-outlined-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-outlined-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-outlined-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-outlined-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-button-outlined-touch-target-size, 48px);display:var(--mat-button-outlined-touch-target-display, block);left:0;right:0;transform:translateY(-50%)}.mat-mdc-outlined-button:not(:disabled){color:var(--mat-button-outlined-label-text-color, var(--mat-sys-primary));border-color:var(--mat-button-outlined-outline-color, var(--mat-sys-outline))}.mat-mdc-outlined-button[disabled],.mat-mdc-outlined-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-button-outlined-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:var(--mat-button-outlined-disabled-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-outlined-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-tonal-button{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mat-button-tonal-container-height, 40px);font-family:var(--mat-button-tonal-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-button-tonal-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-button-tonal-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mat-button-tonal-label-text-transform);font-weight:var(--mat-button-tonal-label-text-weight, var(--mat-sys-label-large-weight));padding:0 var(--mat-button-tonal-horizontal-padding, 24px)}.mat-tonal-button:not(:disabled){color:var(--mat-button-tonal-label-text-color, var(--mat-sys-on-secondary-container));background-color:var(--mat-button-tonal-container-color, var(--mat-sys-secondary-container))}.mat-tonal-button,.mat-tonal-button .mdc-button__ripple{border-radius:var(--mat-button-tonal-container-shape, var(--mat-sys-corner-full))}.mat-tonal-button[disabled],.mat-tonal-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-button-tonal-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-button-tonal-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-tonal-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-tonal-button>.mat-icon{margin-right:var(--mat-button-tonal-icon-spacing, 8px);margin-left:var(--mat-button-tonal-icon-offset, -8px)}[dir=rtl] .mat-tonal-button>.mat-icon{margin-right:var(--mat-button-tonal-icon-offset, -8px);margin-left:var(--mat-button-tonal-icon-spacing, 8px)}.mat-tonal-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-tonal-icon-offset, -8px);margin-left:var(--mat-button-tonal-icon-spacing, 8px)}[dir=rtl] .mat-tonal-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-tonal-icon-spacing, 8px);margin-left:var(--mat-button-tonal-icon-offset, -8px)}.mat-tonal-button .mat-ripple-element{background-color:var(--mat-button-tonal-ripple-color, color-mix(in srgb, var(--mat-sys-on-secondary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-tonal-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-tonal-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-tonal-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-tonal-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-tonal-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-tonal-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-tonal-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-tonal-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-tonal-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-tonal-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-tonal-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-tonal-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-tonal-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-button-tonal-touch-target-size, 48px);display:var(--mat-button-tonal-touch-target-display, block);left:0;right:0;transform:translateY(-50%)}.mat-mdc-button,.mat-mdc-unelevated-button,.mat-mdc-raised-button,.mat-mdc-outlined-button,.mat-tonal-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before,.mat-tonal-button .mat-mdc-button-ripple,.mat-tonal-button .mat-mdc-button-persistent-ripple,.mat-tonal-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-tonal-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before,.mat-tonal-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-button .mdc-button__label,.mat-mdc-button .mat-icon,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-unelevated-button .mat-icon,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-raised-button .mat-icon,.mat-mdc-outlined-button .mdc-button__label,.mat-mdc-outlined-button .mat-icon,.mat-tonal-button .mdc-button__label,.mat-tonal-button .mat-icon{z-index:1;position:relative}.mat-mdc-button .mat-focus-indicator,.mat-mdc-unelevated-button .mat-focus-indicator,.mat-mdc-raised-button .mat-focus-indicator,.mat-mdc-outlined-button .mat-focus-indicator,.mat-tonal-button .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit}.mat-mdc-button:focus>.mat-focus-indicator::before,.mat-mdc-unelevated-button:focus>.mat-focus-indicator::before,.mat-mdc-raised-button:focus>.mat-focus-indicator::before,.mat-mdc-outlined-button:focus>.mat-focus-indicator::before,.mat-tonal-button:focus>.mat-focus-indicator::before{content:"";border-radius:inherit}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable,.mat-tonal-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon,.mat-tonal-button>.mat-icon{display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px}.mat-mdc-unelevated-button .mat-focus-indicator::before,.mat-tonal-button .mat-focus-indicator::before,.mat-mdc-raised-button .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-outlined-button .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 3px)*-1)}\n', "@media(forced-colors: active){.mat-mdc-button:not(.mdc-button--outlined),.mat-mdc-unelevated-button:not(.mdc-button--outlined),.mat-mdc-raised-button:not(.mdc-button--outlined),.mat-mdc-outlined-button:not(.mdc-button--outlined),.mat-mdc-button-base.mat-tonal-button,.mat-mdc-icon-button.mat-mdc-icon-button,.mat-mdc-outlined-button .mdc-button__ripple{outline:solid 1px}}\n"], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatButton, decorators: [{
      type: Component,
      args: [{ selector: `
    button[matButton], a[matButton], button[mat-button], button[mat-raised-button],
    button[mat-flat-button], button[mat-stroked-button], a[mat-button], a[mat-raised-button],
    a[mat-flat-button], a[mat-stroked-button]
  `, host: {
        "class": "mdc-button"
      }, exportAs: "matButton, matAnchor", encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: `<span
    class="mat-mdc-button-persistent-ripple"
    [class.mdc-button__ripple]="!_isFab"
    [class.mdc-fab__ripple]="_isFab"></span>

<ng-content select=".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])">
</ng-content>

<span class="mdc-button__label"><ng-content></ng-content></span>

<ng-content select=".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]">
</ng-content>

<!--
  The indicator can't be directly on the button, because MDC uses ::before for high contrast
  indication and it can't be on the ripple, because it has a border radius and overflow: hidden.
-->
<span class="mat-focus-indicator"></span>

<span class="mat-mdc-button-touch-target"></span>
`, styles: ['.mat-mdc-button-base{text-decoration:none}.mat-mdc-button-base .mat-icon{min-height:fit-content;flex-shrink:0}.mdc-button{-webkit-user-select:none;user-select:none;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0);padding:0 8px}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__label{position:relative}.mat-mdc-button{padding:0 var(--mat-button-text-horizontal-padding, 12px);height:var(--mat-button-text-container-height, 40px);font-family:var(--mat-button-text-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-button-text-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-button-text-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mat-button-text-label-text-transform);font-weight:var(--mat-button-text-label-text-weight, var(--mat-sys-label-large-weight))}.mat-mdc-button,.mat-mdc-button .mdc-button__ripple{border-radius:var(--mat-button-text-container-shape, var(--mat-sys-corner-full))}.mat-mdc-button:not(:disabled){color:var(--mat-button-text-label-text-color, var(--mat-sys-primary))}.mat-mdc-button[disabled],.mat-mdc-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-button-text-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-button:has(.material-icons,mat-icon,[matButtonIcon]){padding:0 var(--mat-button-text-with-icon-horizontal-padding, 16px)}.mat-mdc-button>.mat-icon{margin-right:var(--mat-button-text-icon-spacing, 8px);margin-left:var(--mat-button-text-icon-offset, -4px)}[dir=rtl] .mat-mdc-button>.mat-icon{margin-right:var(--mat-button-text-icon-offset, -4px);margin-left:var(--mat-button-text-icon-spacing, 8px)}.mat-mdc-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-text-icon-offset, -4px);margin-left:var(--mat-button-text-icon-spacing, 8px)}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-text-icon-spacing, 8px);margin-left:var(--mat-button-text-icon-offset, -4px)}.mat-mdc-button .mat-ripple-element{background-color:var(--mat-button-text-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-text-state-layer-color, var(--mat-sys-primary))}.mat-mdc-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-text-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-text-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-text-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-text-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-button-text-touch-target-size, 48px);display:var(--mat-button-text-touch-target-display, block);left:0;right:0;transform:translateY(-50%)}.mat-mdc-unelevated-button{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mat-button-filled-container-height, 40px);font-family:var(--mat-button-filled-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-button-filled-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-button-filled-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mat-button-filled-label-text-transform);font-weight:var(--mat-button-filled-label-text-weight, var(--mat-sys-label-large-weight));padding:0 var(--mat-button-filled-horizontal-padding, 24px)}.mat-mdc-unelevated-button>.mat-icon{margin-right:var(--mat-button-filled-icon-spacing, 8px);margin-left:var(--mat-button-filled-icon-offset, -8px)}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon{margin-right:var(--mat-button-filled-icon-offset, -8px);margin-left:var(--mat-button-filled-icon-spacing, 8px)}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-filled-icon-offset, -8px);margin-left:var(--mat-button-filled-icon-spacing, 8px)}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-filled-icon-spacing, 8px);margin-left:var(--mat-button-filled-icon-offset, -8px)}.mat-mdc-unelevated-button .mat-ripple-element{background-color:var(--mat-button-filled-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-filled-state-layer-color, var(--mat-sys-on-primary))}.mat-mdc-unelevated-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-filled-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-unelevated-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-filled-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-unelevated-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-filled-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-unelevated-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-filled-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-unelevated-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-button-filled-touch-target-size, 48px);display:var(--mat-button-filled-touch-target-display, block);left:0;right:0;transform:translateY(-50%)}.mat-mdc-unelevated-button:not(:disabled){color:var(--mat-button-filled-label-text-color, var(--mat-sys-on-primary));background-color:var(--mat-button-filled-container-color, var(--mat-sys-primary))}.mat-mdc-unelevated-button,.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mat-button-filled-container-shape, var(--mat-sys-corner-full))}.mat-mdc-unelevated-button[disabled],.mat-mdc-unelevated-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-button-filled-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-button-filled-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-unelevated-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-raised-button{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);box-shadow:var(--mat-button-protected-container-elevation-shadow, var(--mat-sys-level1));height:var(--mat-button-protected-container-height, 40px);font-family:var(--mat-button-protected-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-button-protected-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-button-protected-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mat-button-protected-label-text-transform);font-weight:var(--mat-button-protected-label-text-weight, var(--mat-sys-label-large-weight));padding:0 var(--mat-button-protected-horizontal-padding, 24px)}.mat-mdc-raised-button>.mat-icon{margin-right:var(--mat-button-protected-icon-spacing, 8px);margin-left:var(--mat-button-protected-icon-offset, -8px)}[dir=rtl] .mat-mdc-raised-button>.mat-icon{margin-right:var(--mat-button-protected-icon-offset, -8px);margin-left:var(--mat-button-protected-icon-spacing, 8px)}.mat-mdc-raised-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-protected-icon-offset, -8px);margin-left:var(--mat-button-protected-icon-spacing, 8px)}[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-protected-icon-spacing, 8px);margin-left:var(--mat-button-protected-icon-offset, -8px)}.mat-mdc-raised-button .mat-ripple-element{background-color:var(--mat-button-protected-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-protected-state-layer-color, var(--mat-sys-primary))}.mat-mdc-raised-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-protected-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-raised-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-protected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-raised-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-protected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-raised-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-protected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-raised-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-button-protected-touch-target-size, 48px);display:var(--mat-button-protected-touch-target-display, block);left:0;right:0;transform:translateY(-50%)}.mat-mdc-raised-button:not(:disabled){color:var(--mat-button-protected-label-text-color, var(--mat-sys-primary));background-color:var(--mat-button-protected-container-color, var(--mat-sys-surface))}.mat-mdc-raised-button,.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mat-button-protected-container-shape, var(--mat-sys-corner-full))}.mat-mdc-raised-button:hover{box-shadow:var(--mat-button-protected-hover-container-elevation-shadow, var(--mat-sys-level2))}.mat-mdc-raised-button:focus{box-shadow:var(--mat-button-protected-focus-container-elevation-shadow, var(--mat-sys-level1))}.mat-mdc-raised-button:active,.mat-mdc-raised-button:focus:active{box-shadow:var(--mat-button-protected-pressed-container-elevation-shadow, var(--mat-sys-level1))}.mat-mdc-raised-button[disabled],.mat-mdc-raised-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-button-protected-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-button-protected-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-raised-button[disabled].mat-mdc-button-disabled,.mat-mdc-raised-button.mat-mdc-button-disabled.mat-mdc-button-disabled{box-shadow:var(--mat-button-protected-disabled-container-elevation-shadow, var(--mat-sys-level0))}.mat-mdc-raised-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-outlined-button{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mat-button-outlined-container-height, 40px);font-family:var(--mat-button-outlined-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-button-outlined-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-button-outlined-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mat-button-outlined-label-text-transform);font-weight:var(--mat-button-outlined-label-text-weight, var(--mat-sys-label-large-weight));border-radius:var(--mat-button-outlined-container-shape, var(--mat-sys-corner-full));border-width:var(--mat-button-outlined-outline-width, 1px);padding:0 var(--mat-button-outlined-horizontal-padding, 24px)}.mat-mdc-outlined-button>.mat-icon{margin-right:var(--mat-button-outlined-icon-spacing, 8px);margin-left:var(--mat-button-outlined-icon-offset, -8px)}[dir=rtl] .mat-mdc-outlined-button>.mat-icon{margin-right:var(--mat-button-outlined-icon-offset, -8px);margin-left:var(--mat-button-outlined-icon-spacing, 8px)}.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-outlined-icon-offset, -8px);margin-left:var(--mat-button-outlined-icon-spacing, 8px)}[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-outlined-icon-spacing, 8px);margin-left:var(--mat-button-outlined-icon-offset, -8px)}.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-button-outlined-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-outlined-state-layer-color, var(--mat-sys-primary))}.mat-mdc-outlined-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-outlined-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-outlined-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-outlined-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-outlined-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-outlined-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-outlined-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-outlined-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-button-outlined-touch-target-size, 48px);display:var(--mat-button-outlined-touch-target-display, block);left:0;right:0;transform:translateY(-50%)}.mat-mdc-outlined-button:not(:disabled){color:var(--mat-button-outlined-label-text-color, var(--mat-sys-primary));border-color:var(--mat-button-outlined-outline-color, var(--mat-sys-outline))}.mat-mdc-outlined-button[disabled],.mat-mdc-outlined-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-button-outlined-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:var(--mat-button-outlined-disabled-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-outlined-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-tonal-button{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mat-button-tonal-container-height, 40px);font-family:var(--mat-button-tonal-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-button-tonal-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-button-tonal-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mat-button-tonal-label-text-transform);font-weight:var(--mat-button-tonal-label-text-weight, var(--mat-sys-label-large-weight));padding:0 var(--mat-button-tonal-horizontal-padding, 24px)}.mat-tonal-button:not(:disabled){color:var(--mat-button-tonal-label-text-color, var(--mat-sys-on-secondary-container));background-color:var(--mat-button-tonal-container-color, var(--mat-sys-secondary-container))}.mat-tonal-button,.mat-tonal-button .mdc-button__ripple{border-radius:var(--mat-button-tonal-container-shape, var(--mat-sys-corner-full))}.mat-tonal-button[disabled],.mat-tonal-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-button-tonal-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-button-tonal-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-tonal-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-tonal-button>.mat-icon{margin-right:var(--mat-button-tonal-icon-spacing, 8px);margin-left:var(--mat-button-tonal-icon-offset, -8px)}[dir=rtl] .mat-tonal-button>.mat-icon{margin-right:var(--mat-button-tonal-icon-offset, -8px);margin-left:var(--mat-button-tonal-icon-spacing, 8px)}.mat-tonal-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-tonal-icon-offset, -8px);margin-left:var(--mat-button-tonal-icon-spacing, 8px)}[dir=rtl] .mat-tonal-button .mdc-button__label+.mat-icon{margin-right:var(--mat-button-tonal-icon-spacing, 8px);margin-left:var(--mat-button-tonal-icon-offset, -8px)}.mat-tonal-button .mat-ripple-element{background-color:var(--mat-button-tonal-ripple-color, color-mix(in srgb, var(--mat-sys-on-secondary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-tonal-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-tonal-state-layer-color, var(--mat-sys-on-secondary-container))}.mat-tonal-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-button-tonal-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-tonal-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-tonal-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-tonal-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-tonal-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-tonal-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-tonal-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-tonal-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-button-tonal-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-tonal-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-button-tonal-touch-target-size, 48px);display:var(--mat-button-tonal-touch-target-display, block);left:0;right:0;transform:translateY(-50%)}.mat-mdc-button,.mat-mdc-unelevated-button,.mat-mdc-raised-button,.mat-mdc-outlined-button,.mat-tonal-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before,.mat-tonal-button .mat-mdc-button-ripple,.mat-tonal-button .mat-mdc-button-persistent-ripple,.mat-tonal-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-tonal-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before,.mat-tonal-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-button .mdc-button__label,.mat-mdc-button .mat-icon,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-unelevated-button .mat-icon,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-raised-button .mat-icon,.mat-mdc-outlined-button .mdc-button__label,.mat-mdc-outlined-button .mat-icon,.mat-tonal-button .mdc-button__label,.mat-tonal-button .mat-icon{z-index:1;position:relative}.mat-mdc-button .mat-focus-indicator,.mat-mdc-unelevated-button .mat-focus-indicator,.mat-mdc-raised-button .mat-focus-indicator,.mat-mdc-outlined-button .mat-focus-indicator,.mat-tonal-button .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit}.mat-mdc-button:focus>.mat-focus-indicator::before,.mat-mdc-unelevated-button:focus>.mat-focus-indicator::before,.mat-mdc-raised-button:focus>.mat-focus-indicator::before,.mat-mdc-outlined-button:focus>.mat-focus-indicator::before,.mat-tonal-button:focus>.mat-focus-indicator::before{content:"";border-radius:inherit}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable,.mat-tonal-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon,.mat-tonal-button>.mat-icon{display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px}.mat-mdc-unelevated-button .mat-focus-indicator::before,.mat-tonal-button .mat-focus-indicator::before,.mat-mdc-raised-button .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-outlined-button .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 3px)*-1)}\n', "@media(forced-colors: active){.mat-mdc-button:not(.mdc-button--outlined),.mat-mdc-unelevated-button:not(.mdc-button--outlined),.mat-mdc-raised-button:not(.mdc-button--outlined),.mat-mdc-outlined-button:not(.mdc-button--outlined),.mat-mdc-button-base.mat-tonal-button,.mat-mdc-icon-button.mat-mdc-icon-button,.mat-mdc-outlined-button .mdc-button__ripple{outline:solid 1px}}\n"] }]
    }], ctorParameters: () => [], propDecorators: { appearance: [{
      type: Input,
      args: ["matButton"]
    }] } });
    MAT_FAB_DEFAULT_OPTIONS = new InjectionToken("mat-mdc-fab-default-options", {
      providedIn: "root",
      factory: MAT_FAB_DEFAULT_OPTIONS_FACTORY
    });
    defaults = MAT_FAB_DEFAULT_OPTIONS_FACTORY();
    MatFabButton = class _MatFabButton extends MatButtonBase {
      _options = inject(MAT_FAB_DEFAULT_OPTIONS, { optional: true });
      _isFab = true;
      extended;
      constructor() {
        super();
        this._options = this._options || defaults;
        this.color = this._options.color || defaults.color;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatFabButton, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "16.1.0", version: "20.2.0-next.2", type: _MatFabButton, isStandalone: true, selector: "button[mat-fab], a[mat-fab], button[matFab], a[matFab]", inputs: { extended: ["extended", "extended", booleanAttribute] }, host: { properties: { "class.mdc-fab--extended": "extended", "class.mat-mdc-extended-fab": "extended" }, classAttribute: "mdc-fab mat-mdc-fab-base mat-mdc-fab" }, exportAs: ["matButton", "matAnchor"], usesInheritance: true, ngImport: core_exports, template: `<span
    class="mat-mdc-button-persistent-ripple"
    [class.mdc-button__ripple]="!_isFab"
    [class.mdc-fab__ripple]="_isFab"></span>

<ng-content select=".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])">
</ng-content>

<span class="mdc-button__label"><ng-content></ng-content></span>

<ng-content select=".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]">
</ng-content>

<!--
  The indicator can't be directly on the button, because MDC uses ::before for high contrast
  indication and it can't be on the ripple, because it has a border radius and overflow: hidden.
-->
<span class="mat-focus-indicator"></span>

<span class="mat-mdc-button-touch-target"></span>
`, styles: ['.mat-mdc-fab-base{-webkit-user-select:none;user-select:none;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1);flex-shrink:0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-fab-base .mat-mdc-button-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab-base .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-fab-base .mdc-button__label,.mat-mdc-fab-base .mat-icon{z-index:1;position:relative}.mat-mdc-fab-base .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab-base:focus>.mat-focus-indicator::before{content:""}.mat-mdc-fab-base._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab-base::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mat-mdc-fab-base[hidden]{display:none}.mat-mdc-fab-base::-moz-focus-inner{padding:0;border:0}.mat-mdc-fab-base:active,.mat-mdc-fab-base:focus{outline:none}.mat-mdc-fab-base:hover{cursor:pointer}.mat-mdc-fab-base>svg{width:100%}.mat-mdc-fab-base .mat-icon,.mat-mdc-fab-base .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab-base .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base[disabled]:focus,.mat-mdc-fab-base.mat-mdc-button-disabled,.mat-mdc-fab-base.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-fab-base.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab{background-color:var(--mat-fab-container-color, var(--mat-sys-primary-container));border-radius:var(--mat-fab-container-shape, var(--mat-sys-corner-large));color:var(--mat-fab-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mat-fab-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:hover{box-shadow:var(--mat-fab-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-fab:focus{box-shadow:var(--mat-fab-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:active,.mat-mdc-fab:focus:active{box-shadow:var(--mat-fab-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab[disabled],.mat-mdc-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-fab-touch-target-size, 48px);display:var(--mat-fab-touch-target-display, block);left:50%;width:var(--mat-fab-touch-target-size, 48px);transform:translate(-50%, -50%)}.mat-mdc-fab .mat-ripple-element{background-color:var(--mat-fab-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-disabled-state-layer-color)}.mat-mdc-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-mini-fab{width:40px;height:40px;background-color:var(--mat-fab-small-container-color, var(--mat-sys-primary-container));border-radius:var(--mat-fab-small-container-shape, var(--mat-sys-corner-medium));color:var(--mat-fab-small-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mat-fab-small-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:hover{box-shadow:var(--mat-fab-small-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-mini-fab:focus{box-shadow:var(--mat-fab-small-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:var(--mat-fab-small-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab[disabled],.mat-mdc-mini-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-small-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-small-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-fab-small-touch-target-size, 48px);display:var(--mat-fab-small-touch-target-display);left:50%;width:var(--mat-fab-small-touch-target-size, 48px);transform:translate(-50%, -50%)}.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-fab-small-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-mini-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-disabled-state-layer-color)}.mat-mdc-mini-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-mini-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-mini-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-extended-fab{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;padding-left:20px;padding-right:20px;width:auto;max-width:100%;line-height:normal;box-shadow:var(--mat-fab-extended-container-elevation-shadow, var(--mat-sys-level3));height:var(--mat-fab-extended-container-height, 56px);border-radius:var(--mat-fab-extended-container-shape, var(--mat-sys-corner-large));font-family:var(--mat-fab-extended-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-fab-extended-label-text-size, var(--mat-sys-label-large-size));font-weight:var(--mat-fab-extended-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mat-fab-extended-label-text-tracking, var(--mat-sys-label-large-tracking))}.mat-mdc-extended-fab:hover{box-shadow:var(--mat-fab-extended-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-extended-fab:focus{box-shadow:var(--mat-fab-extended-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab:active,.mat-mdc-extended-fab:focus:active{box-shadow:var(--mat-fab-extended-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab[disabled]:focus,.mat-mdc-extended-fab.mat-mdc-button-disabled,.mat-mdc-extended-fab.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-extended-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:-8px;margin-right:12px}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons,[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons{margin-left:12px;margin-right:-8px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}\n'], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatFabButton, decorators: [{
      type: Component,
      args: [{ selector: `button[mat-fab], a[mat-fab], button[matFab], a[matFab]`, host: {
        "class": "mdc-fab mat-mdc-fab-base mat-mdc-fab",
        "[class.mdc-fab--extended]": "extended",
        "[class.mat-mdc-extended-fab]": "extended"
      }, exportAs: "matButton, matAnchor", encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: `<span
    class="mat-mdc-button-persistent-ripple"
    [class.mdc-button__ripple]="!_isFab"
    [class.mdc-fab__ripple]="_isFab"></span>

<ng-content select=".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])">
</ng-content>

<span class="mdc-button__label"><ng-content></ng-content></span>

<ng-content select=".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]">
</ng-content>

<!--
  The indicator can't be directly on the button, because MDC uses ::before for high contrast
  indication and it can't be on the ripple, because it has a border radius and overflow: hidden.
-->
<span class="mat-focus-indicator"></span>

<span class="mat-mdc-button-touch-target"></span>
`, styles: ['.mat-mdc-fab-base{-webkit-user-select:none;user-select:none;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1);flex-shrink:0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-fab-base .mat-mdc-button-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab-base .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-fab-base .mdc-button__label,.mat-mdc-fab-base .mat-icon{z-index:1;position:relative}.mat-mdc-fab-base .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab-base:focus>.mat-focus-indicator::before{content:""}.mat-mdc-fab-base._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab-base::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mat-mdc-fab-base[hidden]{display:none}.mat-mdc-fab-base::-moz-focus-inner{padding:0;border:0}.mat-mdc-fab-base:active,.mat-mdc-fab-base:focus{outline:none}.mat-mdc-fab-base:hover{cursor:pointer}.mat-mdc-fab-base>svg{width:100%}.mat-mdc-fab-base .mat-icon,.mat-mdc-fab-base .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab-base .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base[disabled]:focus,.mat-mdc-fab-base.mat-mdc-button-disabled,.mat-mdc-fab-base.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-fab-base.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab{background-color:var(--mat-fab-container-color, var(--mat-sys-primary-container));border-radius:var(--mat-fab-container-shape, var(--mat-sys-corner-large));color:var(--mat-fab-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mat-fab-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:hover{box-shadow:var(--mat-fab-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-fab:focus{box-shadow:var(--mat-fab-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:active,.mat-mdc-fab:focus:active{box-shadow:var(--mat-fab-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab[disabled],.mat-mdc-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-fab-touch-target-size, 48px);display:var(--mat-fab-touch-target-display, block);left:50%;width:var(--mat-fab-touch-target-size, 48px);transform:translate(-50%, -50%)}.mat-mdc-fab .mat-ripple-element{background-color:var(--mat-fab-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-disabled-state-layer-color)}.mat-mdc-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-mini-fab{width:40px;height:40px;background-color:var(--mat-fab-small-container-color, var(--mat-sys-primary-container));border-radius:var(--mat-fab-small-container-shape, var(--mat-sys-corner-medium));color:var(--mat-fab-small-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mat-fab-small-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:hover{box-shadow:var(--mat-fab-small-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-mini-fab:focus{box-shadow:var(--mat-fab-small-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:var(--mat-fab-small-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab[disabled],.mat-mdc-mini-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-small-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-small-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-fab-small-touch-target-size, 48px);display:var(--mat-fab-small-touch-target-display);left:50%;width:var(--mat-fab-small-touch-target-size, 48px);transform:translate(-50%, -50%)}.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-fab-small-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-mini-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-disabled-state-layer-color)}.mat-mdc-mini-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-mini-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-mini-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-extended-fab{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;padding-left:20px;padding-right:20px;width:auto;max-width:100%;line-height:normal;box-shadow:var(--mat-fab-extended-container-elevation-shadow, var(--mat-sys-level3));height:var(--mat-fab-extended-container-height, 56px);border-radius:var(--mat-fab-extended-container-shape, var(--mat-sys-corner-large));font-family:var(--mat-fab-extended-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-fab-extended-label-text-size, var(--mat-sys-label-large-size));font-weight:var(--mat-fab-extended-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mat-fab-extended-label-text-tracking, var(--mat-sys-label-large-tracking))}.mat-mdc-extended-fab:hover{box-shadow:var(--mat-fab-extended-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-extended-fab:focus{box-shadow:var(--mat-fab-extended-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab:active,.mat-mdc-extended-fab:focus:active{box-shadow:var(--mat-fab-extended-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab[disabled]:focus,.mat-mdc-extended-fab.mat-mdc-button-disabled,.mat-mdc-extended-fab.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-extended-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:-8px;margin-right:12px}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons,[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons{margin-left:12px;margin-right:-8px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}\n'] }]
    }], ctorParameters: () => [], propDecorators: { extended: [{
      type: Input,
      args: [{ transform: booleanAttribute }]
    }] } });
    MatMiniFabButton = class _MatMiniFabButton extends MatButtonBase {
      _options = inject(MAT_FAB_DEFAULT_OPTIONS, { optional: true });
      _isFab = true;
      constructor() {
        super();
        this._options = this._options || defaults;
        this.color = this._options.color || defaults.color;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatMiniFabButton, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "14.0.0", version: "20.2.0-next.2", type: _MatMiniFabButton, isStandalone: true, selector: "button[mat-mini-fab], a[mat-mini-fab], button[matMiniFab], a[matMiniFab]", host: { classAttribute: "mdc-fab mat-mdc-fab-base mdc-fab--mini mat-mdc-mini-fab" }, exportAs: ["matButton", "matAnchor"], usesInheritance: true, ngImport: core_exports, template: `<span
    class="mat-mdc-button-persistent-ripple"
    [class.mdc-button__ripple]="!_isFab"
    [class.mdc-fab__ripple]="_isFab"></span>

<ng-content select=".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])">
</ng-content>

<span class="mdc-button__label"><ng-content></ng-content></span>

<ng-content select=".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]">
</ng-content>

<!--
  The indicator can't be directly on the button, because MDC uses ::before for high contrast
  indication and it can't be on the ripple, because it has a border radius and overflow: hidden.
-->
<span class="mat-focus-indicator"></span>

<span class="mat-mdc-button-touch-target"></span>
`, styles: ['.mat-mdc-fab-base{-webkit-user-select:none;user-select:none;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1);flex-shrink:0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-fab-base .mat-mdc-button-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab-base .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-fab-base .mdc-button__label,.mat-mdc-fab-base .mat-icon{z-index:1;position:relative}.mat-mdc-fab-base .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab-base:focus>.mat-focus-indicator::before{content:""}.mat-mdc-fab-base._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab-base::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mat-mdc-fab-base[hidden]{display:none}.mat-mdc-fab-base::-moz-focus-inner{padding:0;border:0}.mat-mdc-fab-base:active,.mat-mdc-fab-base:focus{outline:none}.mat-mdc-fab-base:hover{cursor:pointer}.mat-mdc-fab-base>svg{width:100%}.mat-mdc-fab-base .mat-icon,.mat-mdc-fab-base .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab-base .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base[disabled]:focus,.mat-mdc-fab-base.mat-mdc-button-disabled,.mat-mdc-fab-base.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-fab-base.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab{background-color:var(--mat-fab-container-color, var(--mat-sys-primary-container));border-radius:var(--mat-fab-container-shape, var(--mat-sys-corner-large));color:var(--mat-fab-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mat-fab-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:hover{box-shadow:var(--mat-fab-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-fab:focus{box-shadow:var(--mat-fab-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:active,.mat-mdc-fab:focus:active{box-shadow:var(--mat-fab-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab[disabled],.mat-mdc-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-fab-touch-target-size, 48px);display:var(--mat-fab-touch-target-display, block);left:50%;width:var(--mat-fab-touch-target-size, 48px);transform:translate(-50%, -50%)}.mat-mdc-fab .mat-ripple-element{background-color:var(--mat-fab-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-disabled-state-layer-color)}.mat-mdc-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-mini-fab{width:40px;height:40px;background-color:var(--mat-fab-small-container-color, var(--mat-sys-primary-container));border-radius:var(--mat-fab-small-container-shape, var(--mat-sys-corner-medium));color:var(--mat-fab-small-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mat-fab-small-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:hover{box-shadow:var(--mat-fab-small-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-mini-fab:focus{box-shadow:var(--mat-fab-small-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:var(--mat-fab-small-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab[disabled],.mat-mdc-mini-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-small-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-small-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-fab-small-touch-target-size, 48px);display:var(--mat-fab-small-touch-target-display);left:50%;width:var(--mat-fab-small-touch-target-size, 48px);transform:translate(-50%, -50%)}.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-fab-small-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-mini-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-disabled-state-layer-color)}.mat-mdc-mini-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-mini-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-mini-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-extended-fab{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;padding-left:20px;padding-right:20px;width:auto;max-width:100%;line-height:normal;box-shadow:var(--mat-fab-extended-container-elevation-shadow, var(--mat-sys-level3));height:var(--mat-fab-extended-container-height, 56px);border-radius:var(--mat-fab-extended-container-shape, var(--mat-sys-corner-large));font-family:var(--mat-fab-extended-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-fab-extended-label-text-size, var(--mat-sys-label-large-size));font-weight:var(--mat-fab-extended-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mat-fab-extended-label-text-tracking, var(--mat-sys-label-large-tracking))}.mat-mdc-extended-fab:hover{box-shadow:var(--mat-fab-extended-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-extended-fab:focus{box-shadow:var(--mat-fab-extended-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab:active,.mat-mdc-extended-fab:focus:active{box-shadow:var(--mat-fab-extended-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab[disabled]:focus,.mat-mdc-extended-fab.mat-mdc-button-disabled,.mat-mdc-extended-fab.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-extended-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:-8px;margin-right:12px}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons,[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons{margin-left:12px;margin-right:-8px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}\n'], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatMiniFabButton, decorators: [{
      type: Component,
      args: [{ selector: `button[mat-mini-fab], a[mat-mini-fab], button[matMiniFab], a[matMiniFab]`, host: {
        "class": "mdc-fab mat-mdc-fab-base mdc-fab--mini mat-mdc-mini-fab"
      }, exportAs: "matButton, matAnchor", encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: `<span
    class="mat-mdc-button-persistent-ripple"
    [class.mdc-button__ripple]="!_isFab"
    [class.mdc-fab__ripple]="_isFab"></span>

<ng-content select=".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])">
</ng-content>

<span class="mdc-button__label"><ng-content></ng-content></span>

<ng-content select=".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]">
</ng-content>

<!--
  The indicator can't be directly on the button, because MDC uses ::before for high contrast
  indication and it can't be on the ripple, because it has a border radius and overflow: hidden.
-->
<span class="mat-focus-indicator"></span>

<span class="mat-mdc-button-touch-target"></span>
`, styles: ['.mat-mdc-fab-base{-webkit-user-select:none;user-select:none;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1);flex-shrink:0;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-fab-base .mat-mdc-button-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple,.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab-base .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-fab-base .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-fab-base .mdc-button__label,.mat-mdc-fab-base .mat-icon{z-index:1;position:relative}.mat-mdc-fab-base .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab-base:focus>.mat-focus-indicator::before{content:""}.mat-mdc-fab-base._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab-base::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mat-mdc-fab-base[hidden]{display:none}.mat-mdc-fab-base::-moz-focus-inner{padding:0;border:0}.mat-mdc-fab-base:active,.mat-mdc-fab-base:focus{outline:none}.mat-mdc-fab-base:hover{cursor:pointer}.mat-mdc-fab-base>svg{width:100%}.mat-mdc-fab-base .mat-icon,.mat-mdc-fab-base .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab-base .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-fab-base[disabled],.mat-mdc-fab-base[disabled]:focus,.mat-mdc-fab-base.mat-mdc-button-disabled,.mat-mdc-fab-base.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-fab-base.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab{background-color:var(--mat-fab-container-color, var(--mat-sys-primary-container));border-radius:var(--mat-fab-container-shape, var(--mat-sys-corner-large));color:var(--mat-fab-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mat-fab-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:hover{box-shadow:var(--mat-fab-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-fab:focus{box-shadow:var(--mat-fab-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab:active,.mat-mdc-fab:focus:active{box-shadow:var(--mat-fab-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-fab[disabled],.mat-mdc-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-fab-touch-target-size, 48px);display:var(--mat-fab-touch-target-display, block);left:50%;width:var(--mat-fab-touch-target-size, 48px);transform:translate(-50%, -50%)}.mat-mdc-fab .mat-ripple-element{background-color:var(--mat-fab-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-disabled-state-layer-color)}.mat-mdc-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-mini-fab{width:40px;height:40px;background-color:var(--mat-fab-small-container-color, var(--mat-sys-primary-container));border-radius:var(--mat-fab-small-container-shape, var(--mat-sys-corner-medium));color:var(--mat-fab-small-foreground-color, var(--mat-sys-on-primary-container, inherit));box-shadow:var(--mat-fab-small-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:hover{box-shadow:var(--mat-fab-small-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-mini-fab:focus{box-shadow:var(--mat-fab-small-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:var(--mat-fab-small-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-mini-fab[disabled],.mat-mdc-mini-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mat-fab-small-disabled-state-foreground-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mat-fab-small-disabled-state-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:var(--mat-fab-small-touch-target-size, 48px);display:var(--mat-fab-small-touch-target-display);left:50%;width:var(--mat-fab-small-touch-target-size, 48px);transform:translate(-50%, -50%)}.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-fab-small-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary-container) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-state-layer-color, var(--mat-sys-on-primary-container))}.mat-mdc-mini-fab.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-fab-small-disabled-state-layer-color)}.mat-mdc-mini-fab:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-mini-fab.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-mini-fab:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-fab-small-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-extended-fab{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;padding-left:20px;padding-right:20px;width:auto;max-width:100%;line-height:normal;box-shadow:var(--mat-fab-extended-container-elevation-shadow, var(--mat-sys-level3));height:var(--mat-fab-extended-container-height, 56px);border-radius:var(--mat-fab-extended-container-shape, var(--mat-sys-corner-large));font-family:var(--mat-fab-extended-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mat-fab-extended-label-text-size, var(--mat-sys-label-large-size));font-weight:var(--mat-fab-extended-label-text-weight, var(--mat-sys-label-large-weight));letter-spacing:var(--mat-fab-extended-label-text-tracking, var(--mat-sys-label-large-tracking))}.mat-mdc-extended-fab:hover{box-shadow:var(--mat-fab-extended-hover-container-elevation-shadow, var(--mat-sys-level4))}.mat-mdc-extended-fab:focus{box-shadow:var(--mat-fab-extended-focus-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab:active,.mat-mdc-extended-fab:focus:active{box-shadow:var(--mat-fab-extended-pressed-container-elevation-shadow, var(--mat-sys-level3))}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab.mat-mdc-button-disabled{cursor:default;pointer-events:none}.mat-mdc-extended-fab[disabled],.mat-mdc-extended-fab[disabled]:focus,.mat-mdc-extended-fab.mat-mdc-button-disabled,.mat-mdc-extended-fab.mat-mdc-button-disabled:focus{box-shadow:none}.mat-mdc-extended-fab.mat-mdc-button-disabled-interactive{pointer-events:auto}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:-8px;margin-right:12px}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons,[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons{margin-left:12px;margin-right:-8px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}\n'] }]
    }], ctorParameters: () => [] });
    MatButtonModule = class _MatButtonModule {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatButtonModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatButtonModule, imports: [
        MatCommonModule,
        MatRippleModule,
        MatButton,
        MatMiniFabButton,
        MatIconButton,
        MatFabButton
      ], exports: [MatCommonModule, MatButton, MatMiniFabButton, MatIconButton, MatFabButton] });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatButtonModule, imports: [
        MatCommonModule,
        MatRippleModule,
        MatCommonModule
      ] });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatButtonModule, decorators: [{
      type: NgModule,
      args: [{
        imports: [
          MatCommonModule,
          MatRippleModule,
          MatButton,
          MatMiniFabButton,
          MatIconButton,
          MatFabButton
        ],
        exports: [MatCommonModule, MatButton, MatMiniFabButton, MatIconButton, MatFabButton]
      }]
    }] });
  }
});

// node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs
var Meta, META_KEYS_MAP, Title, EVENT_NAMES, HAMMER_GESTURE_CONFIG, HAMMER_LOADER, HammerGestureConfig, HammerGesturesPlugin, HammerModule, DomSanitizer, DomSanitizerImpl, HydrationFeatureKind;
var init_platform_browser = __esm({
  "node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs"() {
    "use strict";
    init_common();
    init_core();
    init_core();
    init_dom_renderer();
    Meta = class _Meta {
      _doc;
      _dom;
      constructor(_doc) {
        this._doc = _doc;
        this._dom = getDOM();
      }
      /**
       * Retrieves or creates a specific `<meta>` tag element in the current HTML document.
       * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
       * values in the provided tag definition, and verifies that all other attribute values are equal.
       * If an existing element is found, it is returned and is not modified in any way.
       * @param tag The definition of a `<meta>` element to match or create.
       * @param forceCreation True to create a new element without checking whether one already exists.
       * @returns The existing element with the same attributes and values if found,
       * the new element if no match is found, or `null` if the tag parameter is not defined.
       */
      addTag(tag, forceCreation = false) {
        if (!tag)
          return null;
        return this._getOrCreateElement(tag, forceCreation);
      }
      /**
       * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.
       * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute
       * values in the provided tag definition, and verifies that all other attribute values are equal.
       * @param tags An array of tag definitions to match or create.
       * @param forceCreation True to create new elements without checking whether they already exist.
       * @returns The matching elements if found, or the new elements.
       */
      addTags(tags, forceCreation = false) {
        if (!tags)
          return [];
        return tags.reduce((result, tag) => {
          if (tag) {
            result.push(this._getOrCreateElement(tag, forceCreation));
          }
          return result;
        }, []);
      }
      /**
       * Retrieves a `<meta>` tag element in the current HTML document.
       * @param attrSelector The tag attribute and value to match against, in the format
       * `"tag_attribute='value string'"`.
       * @returns The matching element, if any.
       */
      getTag(attrSelector) {
        if (!attrSelector)
          return null;
        return this._doc.querySelector(`meta[${attrSelector}]`) || null;
      }
      /**
       * Retrieves a set of `<meta>` tag elements in the current HTML document.
       * @param attrSelector The tag attribute and value to match against, in the format
       * `"tag_attribute='value string'"`.
       * @returns The matching elements, if any.
       */
      getTags(attrSelector) {
        if (!attrSelector)
          return [];
        const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
        return list ? [].slice.call(list) : [];
      }
      /**
       * Modifies an existing `<meta>` tag element in the current HTML document.
       * @param tag The tag description with which to replace the existing tag content.
       * @param selector A tag attribute and value to match against, to identify
       * an existing tag. A string in the format `"tag_attribute=`value string`"`.
       * If not supplied, matches a tag with the same `name` or `property` attribute value as the
       * replacement tag.
       * @return The modified element.
       */
      updateTag(tag, selector) {
        if (!tag)
          return null;
        selector = selector || this._parseSelector(tag);
        const meta = this.getTag(selector);
        if (meta) {
          return this._setMetaElementAttributes(tag, meta);
        }
        return this._getOrCreateElement(tag, true);
      }
      /**
       * Removes an existing `<meta>` tag element from the current HTML document.
       * @param attrSelector A tag attribute and value to match against, to identify
       * an existing tag. A string in the format `"tag_attribute=`value string`"`.
       */
      removeTag(attrSelector) {
        this.removeTagElement(this.getTag(attrSelector));
      }
      /**
       * Removes an existing `<meta>` tag element from the current HTML document.
       * @param meta The tag definition to match against to identify an existing tag.
       */
      removeTagElement(meta) {
        if (meta) {
          this._dom.remove(meta);
        }
      }
      _getOrCreateElement(meta, forceCreation = false) {
        if (!forceCreation) {
          const selector = this._parseSelector(meta);
          const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];
          if (elem !== void 0)
            return elem;
        }
        const element = this._dom.createElement("meta");
        this._setMetaElementAttributes(meta, element);
        const head = this._doc.getElementsByTagName("head")[0];
        head.appendChild(element);
        return element;
      }
      _setMetaElementAttributes(tag, el) {
        Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
        return el;
      }
      _parseSelector(tag) {
        const attr = tag.name ? "name" : "property";
        return `${attr}="${tag[attr]}"`;
      }
      _containsAttributes(tag, elem) {
        return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
      }
      _getMetaKeyMap(prop) {
        return META_KEYS_MAP[prop] || prop;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _Meta, deps: [{ token: DOCUMENT }], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _Meta, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: Meta, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }] }] });
    META_KEYS_MAP = {
      httpEquiv: "http-equiv"
    };
    Title = class _Title {
      _doc;
      constructor(_doc) {
        this._doc = _doc;
      }
      /**
       * Get the title of the current HTML document.
       */
      getTitle() {
        return this._doc.title;
      }
      /**
       * Set the title of the current HTML document.
       * @param newTitle
       */
      setTitle(newTitle) {
        this._doc.title = newTitle || "";
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _Title, deps: [{ token: DOCUMENT }], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _Title, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: Title, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }] }] });
    EVENT_NAMES = {
      // pan
      "pan": true,
      "panstart": true,
      "panmove": true,
      "panend": true,
      "pancancel": true,
      "panleft": true,
      "panright": true,
      "panup": true,
      "pandown": true,
      // pinch
      "pinch": true,
      "pinchstart": true,
      "pinchmove": true,
      "pinchend": true,
      "pinchcancel": true,
      "pinchin": true,
      "pinchout": true,
      // press
      "press": true,
      "pressup": true,
      // rotate
      "rotate": true,
      "rotatestart": true,
      "rotatemove": true,
      "rotateend": true,
      "rotatecancel": true,
      // swipe
      "swipe": true,
      "swipeleft": true,
      "swiperight": true,
      "swipeup": true,
      "swipedown": true,
      // tap
      "tap": true,
      "doubletap": true
    };
    HAMMER_GESTURE_CONFIG = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerGestureConfig" : "");
    HAMMER_LOADER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerLoader" : "");
    HammerGestureConfig = class _HammerGestureConfig {
      /**
       * A set of supported event names for gestures to be used in Angular.
       * Angular supports all built-in recognizers, as listed in
       * [HammerJS documentation](https://hammerjs.github.io/).
       */
      events = [];
      /**
       * Maps gesture event names to a set of configuration options
       * that specify overrides to the default values for specific properties.
       *
       * The key is a supported event name to be configured,
       * and the options object contains a set of properties, with override values
       * to be applied to the named recognizer event.
       * For example, to disable recognition of the rotate event, specify
       *  `{"rotate": {"enable": false}}`.
       *
       * Properties that are not present take the HammerJS default values.
       * For information about which properties are supported for which events,
       * and their allowed and default values, see
       * [HammerJS documentation](https://hammerjs.github.io/).
       *
       */
      overrides = {};
      /**
       * Properties whose default values can be overridden for a given event.
       * Different sets of properties apply to different events.
       * For information about which properties are supported for which events,
       * and their allowed and default values, see
       * [HammerJS documentation](https://hammerjs.github.io/).
       */
      options;
      /**
       * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)
       * and attaches it to a given HTML element.
       * @param element The element that will recognize gestures.
       * @returns A HammerJS event-manager object.
       */
      buildHammer(element) {
        const mc = new Hammer(element, this.options);
        mc.get("pinch").set({ enable: true });
        mc.get("rotate").set({ enable: true });
        for (const eventName in this.overrides) {
          mc.get(eventName).set(this.overrides[eventName]);
        }
        return mc;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _HammerGestureConfig, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _HammerGestureConfig });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: HammerGestureConfig, decorators: [{
      type: Injectable
    }] });
    HammerGesturesPlugin = class _HammerGesturesPlugin extends EventManagerPlugin {
      _config;
      _injector;
      loader;
      _loaderPromise = null;
      constructor(doc, _config, _injector, loader) {
        super(doc);
        this._config = _config;
        this._injector = _injector;
        this.loader = loader;
      }
      supports(eventName) {
        if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
          return false;
        }
        if (!window.Hammer && !this.loader) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            const _console = this._injector.get(Console);
            _console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
          }
          return false;
        }
        return true;
      }
      addEventListener(element, eventName, handler) {
        const zone = this.manager.getZone();
        eventName = eventName.toLowerCase();
        if (!window.Hammer && this.loader) {
          this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
          let cancelRegistration = false;
          let deregister = () => {
            cancelRegistration = true;
          };
          zone.runOutsideAngular(() => this._loaderPromise.then(() => {
            if (!window.Hammer) {
              if (typeof ngDevMode === "undefined" || ngDevMode) {
                const _console = this._injector.get(Console);
                _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
              }
              deregister = () => {
              };
              return;
            }
            if (!cancelRegistration) {
              deregister = this.addEventListener(element, eventName, handler);
            }
          }).catch(() => {
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              const _console = this._injector.get(Console);
              _console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
            }
            deregister = () => {
            };
          }));
          return () => {
            deregister();
          };
        }
        return zone.runOutsideAngular(() => {
          const mc = this._config.buildHammer(element);
          const callback = function(eventObj) {
            zone.runGuarded(function() {
              handler(eventObj);
            });
          };
          mc.on(eventName, callback);
          return () => {
            mc.off(eventName, callback);
            if (typeof mc.destroy === "function") {
              mc.destroy();
            }
          };
        });
      }
      isCustomEvent(eventName) {
        return this._config.events.indexOf(eventName) > -1;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _HammerGesturesPlugin, deps: [{ token: DOCUMENT }, { token: HAMMER_GESTURE_CONFIG }, { token: Injector }, { token: HAMMER_LOADER, optional: true }], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _HammerGesturesPlugin });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: HammerGesturesPlugin, decorators: [{
      type: Injectable
    }], ctorParameters: () => [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }] }, { type: HammerGestureConfig, decorators: [{
      type: Inject,
      args: [HAMMER_GESTURE_CONFIG]
    }] }, { type: Injector }, { type: void 0, decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [HAMMER_LOADER]
    }] }] });
    HammerModule = class _HammerModule {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _HammerModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.3.12", ngImport: core_exports, type: _HammerModule });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _HammerModule, providers: [
        {
          provide: EVENT_MANAGER_PLUGINS,
          useClass: HammerGesturesPlugin,
          multi: true,
          deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]
        },
        { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig }
      ] });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: HammerModule, decorators: [{
      type: NgModule,
      args: [{
        providers: [
          {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: HammerGesturesPlugin,
            multi: true,
            deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]
          },
          { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig }
        ]
      }]
    }] });
    DomSanitizer = class _DomSanitizer {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _DomSanitizer, deps: [], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _DomSanitizer, providedIn: "root", useExisting: forwardRef(() => DomSanitizerImpl) });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: DomSanitizer, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root", useExisting: forwardRef(() => DomSanitizerImpl) }]
    }] });
    DomSanitizerImpl = class _DomSanitizerImpl extends DomSanitizer {
      _doc;
      constructor(_doc) {
        super();
        this._doc = _doc;
      }
      sanitize(ctx, value) {
        if (value == null)
          return null;
        switch (ctx) {
          case SecurityContext.NONE:
            return value;
          case SecurityContext.HTML:
            if (allowSanitizationBypassAndThrow(
              value,
              "HTML"
              /* BypassType.Html */
            )) {
              return unwrapSafeValue(value);
            }
            return _sanitizeHtml(this._doc, String(value)).toString();
          case SecurityContext.STYLE:
            if (allowSanitizationBypassAndThrow(
              value,
              "Style"
              /* BypassType.Style */
            )) {
              return unwrapSafeValue(value);
            }
            return value;
          case SecurityContext.SCRIPT:
            if (allowSanitizationBypassAndThrow(
              value,
              "Script"
              /* BypassType.Script */
            )) {
              return unwrapSafeValue(value);
            }
            throw new RuntimeError(5200, (typeof ngDevMode === "undefined" || ngDevMode) && "unsafe value used in a script context");
          case SecurityContext.URL:
            if (allowSanitizationBypassAndThrow(
              value,
              "URL"
              /* BypassType.Url */
            )) {
              return unwrapSafeValue(value);
            }
            return _sanitizeUrl(String(value));
          case SecurityContext.RESOURCE_URL:
            if (allowSanitizationBypassAndThrow(
              value,
              "ResourceURL"
              /* BypassType.ResourceUrl */
            )) {
              return unwrapSafeValue(value);
            }
            throw new RuntimeError(5201, (typeof ngDevMode === "undefined" || ngDevMode) && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
          default:
            throw new RuntimeError(5202, (typeof ngDevMode === "undefined" || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${XSS_SECURITY_URL})`);
        }
      }
      bypassSecurityTrustHtml(value) {
        return bypassSanitizationTrustHtml(value);
      }
      bypassSecurityTrustStyle(value) {
        return bypassSanitizationTrustStyle(value);
      }
      bypassSecurityTrustScript(value) {
        return bypassSanitizationTrustScript(value);
      }
      bypassSecurityTrustUrl(value) {
        return bypassSanitizationTrustUrl(value);
      }
      bypassSecurityTrustResourceUrl(value) {
        return bypassSanitizationTrustResourceUrl(value);
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _DomSanitizerImpl, deps: [{ token: DOCUMENT }], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: _DomSanitizerImpl, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.3.12", ngImport: core_exports, type: DomSanitizerImpl, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [{ type: void 0, decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }] }] });
    (function(HydrationFeatureKind2) {
      HydrationFeatureKind2[HydrationFeatureKind2["NoHttpTransferCache"] = 0] = "NoHttpTransferCache";
      HydrationFeatureKind2[HydrationFeatureKind2["HttpTransferCacheOptions"] = 1] = "HttpTransferCacheOptions";
      HydrationFeatureKind2[HydrationFeatureKind2["I18nSupport"] = 2] = "I18nSupport";
      HydrationFeatureKind2[HydrationFeatureKind2["EventReplay"] = 3] = "EventReplay";
      HydrationFeatureKind2[HydrationFeatureKind2["IncrementalHydration"] = 4] = "IncrementalHydration";
    })(HydrationFeatureKind || (HydrationFeatureKind = {}));
  }
});

// node_modules/@angular/material/fesm2022/icon-registry.mjs
function getPolicy() {
  if (policy === void 0) {
    policy = null;
    if (typeof window !== "undefined") {
      const ttWindow = window;
      if (ttWindow.trustedTypes !== void 0) {
        policy = ttWindow.trustedTypes.createPolicy("angular#components", {
          createHTML: (s2) => s2
        });
      }
    }
  }
  return policy;
}
function trustedHTMLFromString(html) {
  return getPolicy()?.createHTML(html) || html;
}
function getMatIconNameNotFoundError(iconName) {
  return Error(`Unable to find icon with the name "${iconName}"`);
}
function getMatIconNoHttpProviderError() {
  return Error("Could not find HttpClient for use with Angular Material icons. Please add provideHttpClient() to your providers.");
}
function getMatIconFailedToSanitizeUrlError(url) {
  return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${url}".`);
}
function getMatIconFailedToSanitizeLiteralError(literal) {
  return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${literal}".`);
}
function ICON_REGISTRY_PROVIDER_FACTORY(parentRegistry, httpClient, sanitizer, errorHandler, document2) {
  return parentRegistry || new MatIconRegistry(httpClient, sanitizer, document2, errorHandler);
}
function cloneSvg(svg) {
  return svg.cloneNode(true);
}
function iconKey(namespace, name) {
  return namespace + ":" + name;
}
function isSafeUrlWithOptions(value) {
  return !!(value.url && value.options);
}
var policy, SvgIconConfig, MatIconRegistry, ICON_REGISTRY_PROVIDER;
var init_icon_registry = __esm({
  "node_modules/@angular/material/fesm2022/icon-registry.mjs"() {
    "use strict";
    init_http();
    init_http();
    init_core();
    init_core();
    init_platform_browser();
    init_platform_browser();
    init_esm();
    init_operators();
    SvgIconConfig = class {
      url;
      svgText;
      options;
      svgElement;
      constructor(url, svgText, options) {
        this.url = url;
        this.svgText = svgText;
        this.options = options;
      }
    };
    MatIconRegistry = class _MatIconRegistry {
      _httpClient;
      _sanitizer;
      _errorHandler;
      _document;
      /**
       * URLs and cached SVG elements for individual icons. Keys are of the format "[namespace]:[icon]".
       */
      _svgIconConfigs = /* @__PURE__ */ new Map();
      /**
       * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.
       * Multiple icon sets can be registered under the same namespace.
       */
      _iconSetConfigs = /* @__PURE__ */ new Map();
      /** Cache for icons loaded by direct URLs. */
      _cachedIconsByUrl = /* @__PURE__ */ new Map();
      /** In-progress icon fetches. Used to coalesce multiple requests to the same URL. */
      _inProgressUrlFetches = /* @__PURE__ */ new Map();
      /** Map from font identifiers to their CSS class names. Used for icon fonts. */
      _fontCssClassesByAlias = /* @__PURE__ */ new Map();
      /** Registered icon resolver functions. */
      _resolvers = [];
      /**
       * The CSS classes to apply when an `<mat-icon>` component has no icon name, url, or font
       * specified. The default 'material-icons' value assumes that the material icon font has been
       * loaded as described at https://google.github.io/material-design-icons/#icon-font-for-the-web
       */
      _defaultFontSetClass = ["material-icons", "mat-ligature-font"];
      constructor(_httpClient, _sanitizer, document2, _errorHandler) {
        this._httpClient = _httpClient;
        this._sanitizer = _sanitizer;
        this._errorHandler = _errorHandler;
        this._document = document2;
      }
      /**
       * Registers an icon by URL in the default namespace.
       * @param iconName Name under which the icon should be registered.
       * @param url
       */
      addSvgIcon(iconName, url, options) {
        return this.addSvgIconInNamespace("", iconName, url, options);
      }
      /**
       * Registers an icon using an HTML string in the default namespace.
       * @param iconName Name under which the icon should be registered.
       * @param literal SVG source of the icon.
       */
      addSvgIconLiteral(iconName, literal, options) {
        return this.addSvgIconLiteralInNamespace("", iconName, literal, options);
      }
      /**
       * Registers an icon by URL in the specified namespace.
       * @param namespace Namespace in which the icon should be registered.
       * @param iconName Name under which the icon should be registered.
       * @param url
       */
      addSvgIconInNamespace(namespace, iconName, url, options) {
        return this._addSvgIconConfig(namespace, iconName, new SvgIconConfig(url, null, options));
      }
      /**
       * Registers an icon resolver function with the registry. The function will be invoked with the
       * name and namespace of an icon when the registry tries to resolve the URL from which to fetch
       * the icon. The resolver is expected to return a `SafeResourceUrl` that points to the icon,
       * an object with the icon URL and icon options, or `null` if the icon is not supported. Resolvers
       * will be invoked in the order in which they have been registered.
       * @param resolver Resolver function to be registered.
       */
      addSvgIconResolver(resolver) {
        this._resolvers.push(resolver);
        return this;
      }
      /**
       * Registers an icon using an HTML string in the specified namespace.
       * @param namespace Namespace in which the icon should be registered.
       * @param iconName Name under which the icon should be registered.
       * @param literal SVG source of the icon.
       */
      addSvgIconLiteralInNamespace(namespace, iconName, literal, options) {
        const cleanLiteral = this._sanitizer.sanitize(SecurityContext.HTML, literal);
        if (!cleanLiteral) {
          throw getMatIconFailedToSanitizeLiteralError(literal);
        }
        const trustedLiteral = trustedHTMLFromString(cleanLiteral);
        return this._addSvgIconConfig(namespace, iconName, new SvgIconConfig("", trustedLiteral, options));
      }
      /**
       * Registers an icon set by URL in the default namespace.
       * @param url
       */
      addSvgIconSet(url, options) {
        return this.addSvgIconSetInNamespace("", url, options);
      }
      /**
       * Registers an icon set using an HTML string in the default namespace.
       * @param literal SVG source of the icon set.
       */
      addSvgIconSetLiteral(literal, options) {
        return this.addSvgIconSetLiteralInNamespace("", literal, options);
      }
      /**
       * Registers an icon set by URL in the specified namespace.
       * @param namespace Namespace in which to register the icon set.
       * @param url
       */
      addSvgIconSetInNamespace(namespace, url, options) {
        return this._addSvgIconSetConfig(namespace, new SvgIconConfig(url, null, options));
      }
      /**
       * Registers an icon set using an HTML string in the specified namespace.
       * @param namespace Namespace in which to register the icon set.
       * @param literal SVG source of the icon set.
       */
      addSvgIconSetLiteralInNamespace(namespace, literal, options) {
        const cleanLiteral = this._sanitizer.sanitize(SecurityContext.HTML, literal);
        if (!cleanLiteral) {
          throw getMatIconFailedToSanitizeLiteralError(literal);
        }
        const trustedLiteral = trustedHTMLFromString(cleanLiteral);
        return this._addSvgIconSetConfig(namespace, new SvgIconConfig("", trustedLiteral, options));
      }
      /**
       * Defines an alias for CSS class names to be used for icon fonts. Creating an matIcon
       * component with the alias as the fontSet input will cause the class name to be applied
       * to the `<mat-icon>` element.
       *
       * If the registered font is a ligature font, then don't forget to also include the special
       * class `mat-ligature-font` to allow the usage via attribute. So register like this:
       *
       * ```ts
       * iconRegistry.registerFontClassAlias('f1', 'font1 mat-ligature-font');
       * ```
       *
       * And use like this:
       *
       * ```html
       * <mat-icon fontSet="f1" fontIcon="home"></mat-icon>
       * ```
       *
       * @param alias Alias for the font.
       * @param classNames Class names override to be used instead of the alias.
       */
      registerFontClassAlias(alias, classNames = alias) {
        this._fontCssClassesByAlias.set(alias, classNames);
        return this;
      }
      /**
       * Returns the CSS class name associated with the alias by a previous call to
       * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.
       */
      classNameForFontAlias(alias) {
        return this._fontCssClassesByAlias.get(alias) || alias;
      }
      /**
       * Sets the CSS classes to be used for icon fonts when an `<mat-icon>` component does not
       * have a fontSet input value, and is not loading an icon by name or URL.
       */
      setDefaultFontSetClass(...classNames) {
        this._defaultFontSetClass = classNames;
        return this;
      }
      /**
       * Returns the CSS classes to be used for icon fonts when an `<mat-icon>` component does not
       * have a fontSet input value, and is not loading an icon by name or URL.
       */
      getDefaultFontSetClass() {
        return this._defaultFontSetClass;
      }
      /**
       * Returns an Observable that produces the icon (as an `<svg>` DOM element) from the given URL.
       * The response from the URL may be cached so this will not always cause an HTTP request, but
       * the produced element will always be a new copy of the originally fetched icon. (That is,
       * it will not contain any modifications made to elements previously returned).
       *
       * @param safeUrl URL from which to fetch the SVG icon.
       */
      getSvgIconFromUrl(safeUrl) {
        const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
        if (!url) {
          throw getMatIconFailedToSanitizeUrlError(safeUrl);
        }
        const cachedIcon = this._cachedIconsByUrl.get(url);
        if (cachedIcon) {
          return of(cloneSvg(cachedIcon));
        }
        return this._loadSvgIconFromConfig(new SvgIconConfig(safeUrl, null)).pipe(tap((svg) => this._cachedIconsByUrl.set(url, svg)), map((svg) => cloneSvg(svg)));
      }
      /**
       * Returns an Observable that produces the icon (as an `<svg>` DOM element) with the given name
       * and namespace. The icon must have been previously registered with addIcon or addIconSet;
       * if not, the Observable will throw an error.
       *
       * @param name Name of the icon to be retrieved.
       * @param namespace Namespace in which to look for the icon.
       */
      getNamedSvgIcon(name, namespace = "") {
        const key = iconKey(namespace, name);
        let config = this._svgIconConfigs.get(key);
        if (config) {
          return this._getSvgFromConfig(config);
        }
        config = this._getIconConfigFromResolvers(namespace, name);
        if (config) {
          this._svgIconConfigs.set(key, config);
          return this._getSvgFromConfig(config);
        }
        const iconSetConfigs = this._iconSetConfigs.get(namespace);
        if (iconSetConfigs) {
          return this._getSvgFromIconSetConfigs(name, iconSetConfigs);
        }
        return throwError(getMatIconNameNotFoundError(key));
      }
      ngOnDestroy() {
        this._resolvers = [];
        this._svgIconConfigs.clear();
        this._iconSetConfigs.clear();
        this._cachedIconsByUrl.clear();
      }
      /**
       * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.
       */
      _getSvgFromConfig(config) {
        if (config.svgText) {
          return of(cloneSvg(this._svgElementFromConfig(config)));
        } else {
          return this._loadSvgIconFromConfig(config).pipe(map((svg) => cloneSvg(svg)));
        }
      }
      /**
       * Attempts to find an icon with the specified name in any of the SVG icon sets.
       * First searches the available cached icons for a nested element with a matching name, and
       * if found copies the element to a new `<svg>` element. If not found, fetches all icon sets
       * that have not been cached, and searches again after all fetches are completed.
       * The returned Observable produces the SVG element if possible, and throws
       * an error if no icon with the specified name can be found.
       */
      _getSvgFromIconSetConfigs(name, iconSetConfigs) {
        const namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);
        if (namedIcon) {
          return of(namedIcon);
        }
        const iconSetFetchRequests = iconSetConfigs.filter((iconSetConfig) => !iconSetConfig.svgText).map((iconSetConfig) => {
          return this._loadSvgIconSetFromConfig(iconSetConfig).pipe(catchError((err2) => {
            const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, iconSetConfig.url);
            const errorMessage = `Loading icon set URL: ${url} failed: ${err2.message}`;
            this._errorHandler.handleError(new Error(errorMessage));
            return of(null);
          }));
        });
        return forkJoin(iconSetFetchRequests).pipe(map(() => {
          const foundIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);
          if (!foundIcon) {
            throw getMatIconNameNotFoundError(name);
          }
          return foundIcon;
        }));
      }
      /**
       * Searches the cached SVG elements for the given icon sets for a nested icon element whose "id"
       * tag matches the specified name. If found, copies the nested element to a new SVG element and
       * returns it. Returns null if no matching element is found.
       */
      _extractIconWithNameFromAnySet(iconName, iconSetConfigs) {
        for (let i2 = iconSetConfigs.length - 1; i2 >= 0; i2--) {
          const config = iconSetConfigs[i2];
          if (config.svgText && config.svgText.toString().indexOf(iconName) > -1) {
            const svg = this._svgElementFromConfig(config);
            const foundIcon = this._extractSvgIconFromSet(svg, iconName, config.options);
            if (foundIcon) {
              return foundIcon;
            }
          }
        }
        return null;
      }
      /**
       * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element
       * from it.
       */
      _loadSvgIconFromConfig(config) {
        return this._fetchIcon(config).pipe(tap((svgText) => config.svgText = svgText), map(() => this._svgElementFromConfig(config)));
      }
      /**
       * Loads the content of the icon set URL specified in the
       * SvgIconConfig and attaches it to the config.
       */
      _loadSvgIconSetFromConfig(config) {
        if (config.svgText) {
          return of(null);
        }
        return this._fetchIcon(config).pipe(tap((svgText) => config.svgText = svgText));
      }
      /**
       * Searches the cached element of the given SvgIconConfig for a nested icon element whose "id"
       * tag matches the specified name. If found, copies the nested element to a new SVG element and
       * returns it. Returns null if no matching element is found.
       */
      _extractSvgIconFromSet(iconSet, iconName, options) {
        const iconSource = iconSet.querySelector(`[id="${iconName}"]`);
        if (!iconSource) {
          return null;
        }
        const iconElement = iconSource.cloneNode(true);
        iconElement.removeAttribute("id");
        if (iconElement.nodeName.toLowerCase() === "svg") {
          return this._setSvgAttributes(iconElement, options);
        }
        if (iconElement.nodeName.toLowerCase() === "symbol") {
          return this._setSvgAttributes(this._toSvgElement(iconElement), options);
        }
        const svg = this._svgElementFromString(trustedHTMLFromString("<svg></svg>"));
        svg.appendChild(iconElement);
        return this._setSvgAttributes(svg, options);
      }
      /**
       * Creates a DOM element from the given SVG string.
       */
      _svgElementFromString(str) {
        const div = this._document.createElement("DIV");
        div.innerHTML = str;
        const svg = div.querySelector("svg");
        if (!svg) {
          throw Error("<svg> tag not found");
        }
        return svg;
      }
      /**
       * Converts an element into an SVG node by cloning all of its children.
       */
      _toSvgElement(element) {
        const svg = this._svgElementFromString(trustedHTMLFromString("<svg></svg>"));
        const attributes = element.attributes;
        for (let i2 = 0; i2 < attributes.length; i2++) {
          const { name, value } = attributes[i2];
          if (name !== "id") {
            svg.setAttribute(name, value);
          }
        }
        for (let i2 = 0; i2 < element.childNodes.length; i2++) {
          if (element.childNodes[i2].nodeType === this._document.ELEMENT_NODE) {
            svg.appendChild(element.childNodes[i2].cloneNode(true));
          }
        }
        return svg;
      }
      /**
       * Sets the default attributes for an SVG element to be used as an icon.
       */
      _setSvgAttributes(svg, options) {
        svg.setAttribute("fit", "");
        svg.setAttribute("height", "100%");
        svg.setAttribute("width", "100%");
        svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
        svg.setAttribute("focusable", "false");
        if (options && options.viewBox) {
          svg.setAttribute("viewBox", options.viewBox);
        }
        return svg;
      }
      /**
       * Returns an Observable which produces the string contents of the given icon. Results may be
       * cached, so future calls with the same URL may not cause another HTTP request.
       */
      _fetchIcon(iconConfig) {
        const { url: safeUrl, options } = iconConfig;
        const withCredentials = options?.withCredentials ?? false;
        if (!this._httpClient) {
          throw getMatIconNoHttpProviderError();
        }
        if (safeUrl == null) {
          throw Error(`Cannot fetch icon from URL "${safeUrl}".`);
        }
        const url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
        if (!url) {
          throw getMatIconFailedToSanitizeUrlError(safeUrl);
        }
        const inProgressFetch = this._inProgressUrlFetches.get(url);
        if (inProgressFetch) {
          return inProgressFetch;
        }
        const req = this._httpClient.get(url, { responseType: "text", withCredentials }).pipe(map((svg) => {
          return trustedHTMLFromString(svg);
        }), finalize(() => this._inProgressUrlFetches.delete(url)), share());
        this._inProgressUrlFetches.set(url, req);
        return req;
      }
      /**
       * Registers an icon config by name in the specified namespace.
       * @param namespace Namespace in which to register the icon config.
       * @param iconName Name under which to register the config.
       * @param config Config to be registered.
       */
      _addSvgIconConfig(namespace, iconName, config) {
        this._svgIconConfigs.set(iconKey(namespace, iconName), config);
        return this;
      }
      /**
       * Registers an icon set config in the specified namespace.
       * @param namespace Namespace in which to register the icon config.
       * @param config Config to be registered.
       */
      _addSvgIconSetConfig(namespace, config) {
        const configNamespace = this._iconSetConfigs.get(namespace);
        if (configNamespace) {
          configNamespace.push(config);
        } else {
          this._iconSetConfigs.set(namespace, [config]);
        }
        return this;
      }
      /** Parses a config's text into an SVG element. */
      _svgElementFromConfig(config) {
        if (!config.svgElement) {
          const svg = this._svgElementFromString(config.svgText);
          this._setSvgAttributes(svg, config.options);
          config.svgElement = svg;
        }
        return config.svgElement;
      }
      /** Tries to create an icon config through the registered resolver functions. */
      _getIconConfigFromResolvers(namespace, name) {
        for (let i2 = 0; i2 < this._resolvers.length; i2++) {
          const result = this._resolvers[i2](name, namespace);
          if (result) {
            return isSafeUrlWithOptions(result) ? new SvgIconConfig(result.url, null, result.options) : new SvgIconConfig(result, null);
          }
        }
        return void 0;
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatIconRegistry, deps: [{ token: HttpClient, optional: true }, { token: DomSanitizer }, { token: DOCUMENT, optional: true }, { token: ErrorHandler }], target: FactoryTarget.Injectable });
      static \u0275prov = \u0275\u0275ngDeclareInjectable({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatIconRegistry, providedIn: "root" });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatIconRegistry, decorators: [{
      type: Injectable,
      args: [{ providedIn: "root" }]
    }], ctorParameters: () => [{ type: HttpClient, decorators: [{
      type: Optional
    }] }, { type: DomSanitizer }, { type: void 0, decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }] }, { type: ErrorHandler }] });
    ICON_REGISTRY_PROVIDER = {
      // If there is already an MatIconRegistry available, use that. Otherwise, provide a new one.
      provide: MatIconRegistry,
      deps: [
        [new Optional(), new SkipSelf(), MatIconRegistry],
        [new Optional(), HttpClient],
        DomSanitizer,
        ErrorHandler,
        [new Optional(), DOCUMENT]
      ],
      useFactory: ICON_REGISTRY_PROVIDER_FACTORY
    };
  }
});

// node_modules/@angular/material/fesm2022/icon.mjs
function MAT_ICON_LOCATION_FACTORY() {
  const _document = inject(DOCUMENT);
  const _location = _document ? _document.location : null;
  return {
    // Note that this needs to be a function, rather than a property, because Angular
    // will only resolve it once, but we want the current path on each call.
    getPathname: () => _location ? _location.pathname + _location.search : ""
  };
}
var MAT_ICON_DEFAULT_OPTIONS, MAT_ICON_LOCATION, funcIriAttributes, funcIriAttributeSelector, funcIriPattern, MatIcon, MatIconModule;
var init_icon = __esm({
  "node_modules/@angular/material/fesm2022/icon.mjs"() {
    "use strict";
    init_core();
    init_core();
    init_esm();
    init_operators();
    init_icon_registry();
    init_common_module();
    MAT_ICON_DEFAULT_OPTIONS = new InjectionToken("MAT_ICON_DEFAULT_OPTIONS");
    MAT_ICON_LOCATION = new InjectionToken("mat-icon-location", {
      providedIn: "root",
      factory: MAT_ICON_LOCATION_FACTORY
    });
    funcIriAttributes = [
      "clip-path",
      "color-profile",
      "src",
      "cursor",
      "fill",
      "filter",
      "marker",
      "marker-start",
      "marker-mid",
      "marker-end",
      "mask",
      "stroke"
    ];
    funcIriAttributeSelector = funcIriAttributes.map((attr) => `[${attr}]`).join(", ");
    funcIriPattern = /^url\(['"]?#(.*?)['"]?\)$/;
    MatIcon = class _MatIcon {
      _elementRef = inject(ElementRef);
      _iconRegistry = inject(MatIconRegistry);
      _location = inject(MAT_ICON_LOCATION);
      _errorHandler = inject(ErrorHandler);
      _defaultColor;
      /**
       * Theme color of the icon. This API is supported in M2 themes only, it
       * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/icon/styling.
       *
       * For information on applying color variants in M3, see
       * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants
       */
      get color() {
        return this._color || this._defaultColor;
      }
      set color(value) {
        this._color = value;
      }
      _color;
      /**
       * Whether the icon should be inlined, automatically sizing the icon to match the font size of
       * the element the icon is contained in.
       */
      inline = false;
      /** Name of the icon in the SVG icon set. */
      get svgIcon() {
        return this._svgIcon;
      }
      set svgIcon(value) {
        if (value !== this._svgIcon) {
          if (value) {
            this._updateSvgIcon(value);
          } else if (this._svgIcon) {
            this._clearSvgElement();
          }
          this._svgIcon = value;
        }
      }
      _svgIcon;
      /** Font set that the icon is a part of. */
      get fontSet() {
        return this._fontSet;
      }
      set fontSet(value) {
        const newValue = this._cleanupFontValue(value);
        if (newValue !== this._fontSet) {
          this._fontSet = newValue;
          this._updateFontIconClasses();
        }
      }
      _fontSet;
      /** Name of an icon within a font set. */
      get fontIcon() {
        return this._fontIcon;
      }
      set fontIcon(value) {
        const newValue = this._cleanupFontValue(value);
        if (newValue !== this._fontIcon) {
          this._fontIcon = newValue;
          this._updateFontIconClasses();
        }
      }
      _fontIcon;
      _previousFontSetClass = [];
      _previousFontIconClass;
      _svgName;
      _svgNamespace;
      /** Keeps track of the current page path. */
      _previousPath;
      /** Keeps track of the elements and attributes that we've prefixed with the current path. */
      _elementsWithExternalReferences;
      /** Subscription to the current in-progress SVG icon request. */
      _currentIconFetch = Subscription.EMPTY;
      constructor() {
        const ariaHidden = inject(new HostAttributeToken("aria-hidden"), { optional: true });
        const defaults2 = inject(MAT_ICON_DEFAULT_OPTIONS, { optional: true });
        if (defaults2) {
          if (defaults2.color) {
            this.color = this._defaultColor = defaults2.color;
          }
          if (defaults2.fontSet) {
            this.fontSet = defaults2.fontSet;
          }
        }
        if (!ariaHidden) {
          this._elementRef.nativeElement.setAttribute("aria-hidden", "true");
        }
      }
      /**
       * Splits an svgIcon binding value into its icon set and icon name components.
       * Returns a 2-element array of [(icon set), (icon name)].
       * The separator for the two fields is ':'. If there is no separator, an empty
       * string is returned for the icon set and the entire value is returned for
       * the icon name. If the argument is falsy, returns an array of two empty strings.
       * Throws an error if the name contains two or more ':' separators.
       * Examples:
       *   `'social:cake' -> ['social', 'cake']
       *   'penguin' -> ['', 'penguin']
       *   null -> ['', '']
       *   'a:b:c' -> (throws Error)`
       */
      _splitIconName(iconName) {
        if (!iconName) {
          return ["", ""];
        }
        const parts = iconName.split(":");
        switch (parts.length) {
          case 1:
            return ["", parts[0]];
          // Use default namespace.
          case 2:
            return parts;
          default:
            throw Error(`Invalid icon name: "${iconName}"`);
        }
      }
      ngOnInit() {
        this._updateFontIconClasses();
      }
      ngAfterViewChecked() {
        const cachedElements = this._elementsWithExternalReferences;
        if (cachedElements && cachedElements.size) {
          const newPath = this._location.getPathname();
          if (newPath !== this._previousPath) {
            this._previousPath = newPath;
            this._prependPathToReferences(newPath);
          }
        }
      }
      ngOnDestroy() {
        this._currentIconFetch.unsubscribe();
        if (this._elementsWithExternalReferences) {
          this._elementsWithExternalReferences.clear();
        }
      }
      _usingFontIcon() {
        return !this.svgIcon;
      }
      _setSvgElement(svg) {
        this._clearSvgElement();
        const path = this._location.getPathname();
        this._previousPath = path;
        this._cacheChildrenWithExternalReferences(svg);
        this._prependPathToReferences(path);
        this._elementRef.nativeElement.appendChild(svg);
      }
      _clearSvgElement() {
        const layoutElement = this._elementRef.nativeElement;
        let childCount = layoutElement.childNodes.length;
        if (this._elementsWithExternalReferences) {
          this._elementsWithExternalReferences.clear();
        }
        while (childCount--) {
          const child = layoutElement.childNodes[childCount];
          if (child.nodeType !== 1 || child.nodeName.toLowerCase() === "svg") {
            child.remove();
          }
        }
      }
      _updateFontIconClasses() {
        if (!this._usingFontIcon()) {
          return;
        }
        const elem = this._elementRef.nativeElement;
        const fontSetClasses = (this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/) : this._iconRegistry.getDefaultFontSetClass()).filter((className) => className.length > 0);
        this._previousFontSetClass.forEach((className) => elem.classList.remove(className));
        fontSetClasses.forEach((className) => elem.classList.add(className));
        this._previousFontSetClass = fontSetClasses;
        if (this.fontIcon !== this._previousFontIconClass && !fontSetClasses.includes("mat-ligature-font")) {
          if (this._previousFontIconClass) {
            elem.classList.remove(this._previousFontIconClass);
          }
          if (this.fontIcon) {
            elem.classList.add(this.fontIcon);
          }
          this._previousFontIconClass = this.fontIcon;
        }
      }
      /**
       * Cleans up a value to be used as a fontIcon or fontSet.
       * Since the value ends up being assigned as a CSS class, we
       * have to trim the value and omit space-separated values.
       */
      _cleanupFontValue(value) {
        return typeof value === "string" ? value.trim().split(" ")[0] : value;
      }
      /**
       * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`
       * reference. This is required because WebKit browsers require references to be prefixed with
       * the current path, if the page has a `base` tag.
       */
      _prependPathToReferences(path) {
        const elements = this._elementsWithExternalReferences;
        if (elements) {
          elements.forEach((attrs, element) => {
            attrs.forEach((attr) => {
              element.setAttribute(attr.name, `url('${path}#${attr.value}')`);
            });
          });
        }
      }
      /**
       * Caches the children of an SVG element that have `url()`
       * references that we need to prefix with the current path.
       */
      _cacheChildrenWithExternalReferences(element) {
        const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);
        const elements = this._elementsWithExternalReferences = this._elementsWithExternalReferences || /* @__PURE__ */ new Map();
        for (let i2 = 0; i2 < elementsWithFuncIri.length; i2++) {
          funcIriAttributes.forEach((attr) => {
            const elementWithReference = elementsWithFuncIri[i2];
            const value = elementWithReference.getAttribute(attr);
            const match = value ? value.match(funcIriPattern) : null;
            if (match) {
              let attributes = elements.get(elementWithReference);
              if (!attributes) {
                attributes = [];
                elements.set(elementWithReference, attributes);
              }
              attributes.push({ name: attr, value: match[1] });
            }
          });
        }
      }
      /** Sets a new SVG icon with a particular name. */
      _updateSvgIcon(rawName) {
        this._svgNamespace = null;
        this._svgName = null;
        this._currentIconFetch.unsubscribe();
        if (rawName) {
          const [namespace, iconName] = this._splitIconName(rawName);
          if (namespace) {
            this._svgNamespace = namespace;
          }
          if (iconName) {
            this._svgName = iconName;
          }
          this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(iconName, namespace).pipe(take(1)).subscribe((svg) => this._setSvgElement(svg), (err2) => {
            const errorMessage = `Error retrieving icon ${namespace}:${iconName}! ${err2.message}`;
            this._errorHandler.handleError(new Error(errorMessage));
          });
        }
      }
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatIcon, deps: [], target: FactoryTarget.Component });
      static \u0275cmp = \u0275\u0275ngDeclareComponent({ minVersion: "16.1.0", version: "20.2.0-next.2", type: _MatIcon, isStandalone: true, selector: "mat-icon", inputs: { color: "color", inline: ["inline", "inline", booleanAttribute], svgIcon: "svgIcon", fontSet: "fontSet", fontIcon: "fontIcon" }, host: { attributes: { "role": "img" }, properties: { "class": 'color ? "mat-" + color : ""', "attr.data-mat-icon-type": '_usingFontIcon() ? "font" : "svg"', "attr.data-mat-icon-name": "_svgName || fontIcon", "attr.data-mat-icon-namespace": "_svgNamespace || fontSet", "attr.fontIcon": "_usingFontIcon() ? fontIcon : null", "class.mat-icon-inline": "inline", "class.mat-icon-no-color": 'color !== "primary" && color !== "accent" && color !== "warn"' }, classAttribute: "mat-icon notranslate" }, exportAs: ["matIcon"], ngImport: core_exports, template: "<ng-content></ng-content>", isInline: true, styles: ["mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatIcon, decorators: [{
      type: Component,
      args: [{ template: "<ng-content></ng-content>", selector: "mat-icon", exportAs: "matIcon", host: {
        "role": "img",
        "class": "mat-icon notranslate",
        "[class]": 'color ? "mat-" + color : ""',
        "[attr.data-mat-icon-type]": '_usingFontIcon() ? "font" : "svg"',
        "[attr.data-mat-icon-name]": "_svgName || fontIcon",
        "[attr.data-mat-icon-namespace]": "_svgNamespace || fontSet",
        "[attr.fontIcon]": "_usingFontIcon() ? fontIcon : null",
        "[class.mat-icon-inline]": "inline",
        "[class.mat-icon-no-color]": 'color !== "primary" && color !== "accent" && color !== "warn"'
      }, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, styles: ["mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"] }]
    }], ctorParameters: () => [], propDecorators: { color: [{
      type: Input
    }], inline: [{
      type: Input,
      args: [{ transform: booleanAttribute }]
    }], svgIcon: [{
      type: Input
    }], fontSet: [{
      type: Input
    }], fontIcon: [{
      type: Input
    }] } });
    MatIconModule = class _MatIconModule {
      static \u0275fac = \u0275\u0275ngDeclareFactory({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatIconModule, deps: [], target: FactoryTarget.NgModule });
      static \u0275mod = \u0275\u0275ngDeclareNgModule({ minVersion: "14.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatIconModule, imports: [MatCommonModule, MatIcon], exports: [MatIcon, MatCommonModule] });
      static \u0275inj = \u0275\u0275ngDeclareInjector({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: _MatIconModule, imports: [MatCommonModule, MatCommonModule] });
    };
    \u0275\u0275ngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.2.0-next.2", ngImport: core_exports, type: MatIconModule, decorators: [{
      type: NgModule,
      args: [{
        imports: [MatCommonModule, MatIcon],
        exports: [MatIcon, MatCommonModule]
      }]
    }] });
  }
});

// node_modules/fflate/esm/browser.js
function zlibSync(data, opts) {
  if (!opts)
    opts = {};
  var a2 = adler();
  a2.p(data);
  var d3 = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
  return zlh(d3, opts), wbytes(d3, d3.length - 4, a2.d()), d3;
}
var u8, u16, i32, fleb, fdeb, clim, freb, _a, fl, revfl, _b, fd, revfd, rev, x3, i2, hMap, flt, i2, i2, i2, i2, fdt, i2, flm, fdm, shft, slc, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, deo, et, dflt, adler, dopt, wbytes, zlh, td, tds;
var init_browser = __esm({
  "node_modules/fflate/esm/browser.js"() {
    "use strict";
    u8 = Uint8Array;
    u16 = Uint16Array;
    i32 = Int32Array;
    fleb = new u8([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      0,
      /* unused */
      0,
      0,
      /* impossible */
      0
    ]);
    fdeb = new u8([
      0,
      0,
      0,
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      4,
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      8,
      8,
      9,
      9,
      10,
      10,
      11,
      11,
      12,
      12,
      13,
      13,
      /* unused */
      0,
      0
    ]);
    clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    freb = function(eb, start) {
      var b3 = new u16(31);
      for (var i2 = 0; i2 < 31; ++i2) {
        b3[i2] = start += 1 << eb[i2 - 1];
      }
      var r = new i32(b3[30]);
      for (var i2 = 1; i2 < 30; ++i2) {
        for (var j3 = b3[i2]; j3 < b3[i2 + 1]; ++j3) {
          r[j3] = j3 - b3[i2] << 5 | i2;
        }
      }
      return { b: b3, r };
    };
    _a = freb(fleb, 2);
    fl = _a.b;
    revfl = _a.r;
    fl[28] = 258, revfl[258] = 28;
    _b = freb(fdeb, 0);
    fd = _b.b;
    revfd = _b.r;
    rev = new u16(32768);
    for (i2 = 0; i2 < 32768; ++i2) {
      x3 = (i2 & 43690) >> 1 | (i2 & 21845) << 1;
      x3 = (x3 & 52428) >> 2 | (x3 & 13107) << 2;
      x3 = (x3 & 61680) >> 4 | (x3 & 3855) << 4;
      rev[i2] = ((x3 & 65280) >> 8 | (x3 & 255) << 8) >> 1;
    }
    hMap = (function(cd, mb, r) {
      var s2 = cd.length;
      var i2 = 0;
      var l4 = new u16(mb);
      for (; i2 < s2; ++i2) {
        if (cd[i2])
          ++l4[cd[i2] - 1];
      }
      var le3 = new u16(mb);
      for (i2 = 1; i2 < mb; ++i2) {
        le3[i2] = le3[i2 - 1] + l4[i2 - 1] << 1;
      }
      var co;
      if (r) {
        co = new u16(1 << mb);
        var rvb = 15 - mb;
        for (i2 = 0; i2 < s2; ++i2) {
          if (cd[i2]) {
            var sv = i2 << 4 | cd[i2];
            var r_1 = mb - cd[i2];
            var v3 = le3[cd[i2] - 1]++ << r_1;
            for (var m3 = v3 | (1 << r_1) - 1; v3 <= m3; ++v3) {
              co[rev[v3] >> rvb] = sv;
            }
          }
        }
      } else {
        co = new u16(s2);
        for (i2 = 0; i2 < s2; ++i2) {
          if (cd[i2]) {
            co[i2] = rev[le3[cd[i2] - 1]++] >> 15 - cd[i2];
          }
        }
      }
      return co;
    });
    flt = new u8(288);
    for (i2 = 0; i2 < 144; ++i2)
      flt[i2] = 8;
    for (i2 = 144; i2 < 256; ++i2)
      flt[i2] = 9;
    for (i2 = 256; i2 < 280; ++i2)
      flt[i2] = 7;
    for (i2 = 280; i2 < 288; ++i2)
      flt[i2] = 8;
    fdt = new u8(32);
    for (i2 = 0; i2 < 32; ++i2)
      fdt[i2] = 5;
    flm = /* @__PURE__ */ hMap(flt, 9, 0);
    fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
    shft = function(p2) {
      return (p2 + 7) / 8 | 0;
    };
    slc = function(v3, s2, e) {
      if (s2 == null || s2 < 0)
        s2 = 0;
      if (e == null || e > v3.length)
        e = v3.length;
      return new u8(v3.subarray(s2, e));
    };
    wbits = function(d3, p2, v3) {
      v3 <<= p2 & 7;
      var o2 = p2 / 8 | 0;
      d3[o2] |= v3;
      d3[o2 + 1] |= v3 >> 8;
    };
    wbits16 = function(d3, p2, v3) {
      v3 <<= p2 & 7;
      var o2 = p2 / 8 | 0;
      d3[o2] |= v3;
      d3[o2 + 1] |= v3 >> 8;
      d3[o2 + 2] |= v3 >> 16;
    };
    hTree = function(d3, mb) {
      var t2 = [];
      for (var i2 = 0; i2 < d3.length; ++i2) {
        if (d3[i2])
          t2.push({ s: i2, f: d3[i2] });
      }
      var s2 = t2.length;
      var t22 = t2.slice();
      if (!s2)
        return { t: et, l: 0 };
      if (s2 == 1) {
        var v3 = new u8(t2[0].s + 1);
        v3[t2[0].s] = 1;
        return { t: v3, l: 1 };
      }
      t2.sort(function(a2, b3) {
        return a2.f - b3.f;
      });
      t2.push({ s: -1, f: 25001 });
      var l4 = t2[0], r = t2[1], i0 = 0, i1 = 1, i22 = 2;
      t2[0] = { s: -1, f: l4.f + r.f, l: l4, r };
      while (i1 != s2 - 1) {
        l4 = t2[t2[i0].f < t2[i22].f ? i0++ : i22++];
        r = t2[i0 != i1 && t2[i0].f < t2[i22].f ? i0++ : i22++];
        t2[i1++] = { s: -1, f: l4.f + r.f, l: l4, r };
      }
      var maxSym = t22[0].s;
      for (var i2 = 1; i2 < s2; ++i2) {
        if (t22[i2].s > maxSym)
          maxSym = t22[i2].s;
      }
      var tr = new u16(maxSym + 1);
      var mbt = ln(t2[i1 - 1], tr, 0);
      if (mbt > mb) {
        var i2 = 0, dt2 = 0;
        var lft = mbt - mb, cst = 1 << lft;
        t22.sort(function(a2, b3) {
          return tr[b3.s] - tr[a2.s] || a2.f - b3.f;
        });
        for (; i2 < s2; ++i2) {
          var i2_1 = t22[i2].s;
          if (tr[i2_1] > mb) {
            dt2 += cst - (1 << mbt - tr[i2_1]);
            tr[i2_1] = mb;
          } else
            break;
        }
        dt2 >>= lft;
        while (dt2 > 0) {
          var i2_2 = t22[i2].s;
          if (tr[i2_2] < mb)
            dt2 -= 1 << mb - tr[i2_2]++ - 1;
          else
            ++i2;
        }
        for (; i2 >= 0 && dt2; --i2) {
          var i2_3 = t22[i2].s;
          if (tr[i2_3] == mb) {
            --tr[i2_3];
            ++dt2;
          }
        }
        mbt = mb;
      }
      return { t: new u8(tr), l: mbt };
    };
    ln = function(n, l4, d3) {
      return n.s == -1 ? Math.max(ln(n.l, l4, d3 + 1), ln(n.r, l4, d3 + 1)) : l4[n.s] = d3;
    };
    lc = function(c2) {
      var s2 = c2.length;
      while (s2 && !c2[--s2])
        ;
      var cl = new u16(++s2);
      var cli = 0, cln = c2[0], cls = 1;
      var w3 = function(v3) {
        cl[cli++] = v3;
      };
      for (var i2 = 1; i2 <= s2; ++i2) {
        if (c2[i2] == cln && i2 != s2)
          ++cls;
        else {
          if (!cln && cls > 2) {
            for (; cls > 138; cls -= 138)
              w3(32754);
            if (cls > 2) {
              w3(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
              cls = 0;
            }
          } else if (cls > 3) {
            w3(cln), --cls;
            for (; cls > 6; cls -= 6)
              w3(8304);
            if (cls > 2)
              w3(cls - 3 << 5 | 8208), cls = 0;
          }
          while (cls--)
            w3(cln);
          cls = 1;
          cln = c2[i2];
        }
      }
      return { c: cl.subarray(0, cli), n: s2 };
    };
    clen = function(cf, cl) {
      var l4 = 0;
      for (var i2 = 0; i2 < cl.length; ++i2)
        l4 += cf[i2] * cl[i2];
      return l4;
    };
    wfblk = function(out, pos, dat) {
      var s2 = dat.length;
      var o2 = shft(pos + 2);
      out[o2] = s2 & 255;
      out[o2 + 1] = s2 >> 8;
      out[o2 + 2] = out[o2] ^ 255;
      out[o2 + 3] = out[o2 + 1] ^ 255;
      for (var i2 = 0; i2 < s2; ++i2)
        out[o2 + i2 + 4] = dat[i2];
      return (o2 + 4 + s2) * 8;
    };
    wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p2) {
      wbits(out, p2++, final);
      ++lf[256];
      var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
      var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
      var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
      var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
      var lcfreq = new u16(19);
      for (var i2 = 0; i2 < lclt.length; ++i2)
        ++lcfreq[lclt[i2] & 31];
      for (var i2 = 0; i2 < lcdt.length; ++i2)
        ++lcfreq[lcdt[i2] & 31];
      var _e3 = hTree(lcfreq, 7), lct = _e3.t, mlcb = _e3.l;
      var nlcc = 19;
      for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
        ;
      var flen = bl + 5 << 3;
      var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
      var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
      if (bs >= 0 && flen <= ftlen && flen <= dtlen)
        return wfblk(out, p2, dat.subarray(bs, bs + bl));
      var lm, ll, dm, dl;
      wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
      if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p2, nlc - 257);
        wbits(out, p2 + 5, ndc - 1);
        wbits(out, p2 + 10, nlcc - 4);
        p2 += 14;
        for (var i2 = 0; i2 < nlcc; ++i2)
          wbits(out, p2 + 3 * i2, lct[clim[i2]]);
        p2 += 3 * nlcc;
        var lcts = [lclt, lcdt];
        for (var it2 = 0; it2 < 2; ++it2) {
          var clct = lcts[it2];
          for (var i2 = 0; i2 < clct.length; ++i2) {
            var len = clct[i2] & 31;
            wbits(out, p2, llm[len]), p2 += lct[len];
            if (len > 15)
              wbits(out, p2, clct[i2] >> 5 & 127), p2 += clct[i2] >> 12;
          }
        }
      } else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
      }
      for (var i2 = 0; i2 < li; ++i2) {
        var sym = syms[i2];
        if (sym > 255) {
          var len = sym >> 18 & 31;
          wbits16(out, p2, lm[len + 257]), p2 += ll[len + 257];
          if (len > 7)
            wbits(out, p2, sym >> 23 & 31), p2 += fleb[len];
          var dst = sym & 31;
          wbits16(out, p2, dm[dst]), p2 += dl[dst];
          if (dst > 3)
            wbits16(out, p2, sym >> 5 & 8191), p2 += fdeb[dst];
        } else {
          wbits16(out, p2, lm[sym]), p2 += ll[sym];
        }
      }
      wbits16(out, p2, lm[256]);
      return p2 + ll[256];
    };
    deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
    et = /* @__PURE__ */ new u8(0);
    dflt = function(dat, lvl, plvl, pre, post, st2) {
      var s2 = st2.z || dat.length;
      var o2 = new u8(pre + s2 + 5 * (1 + Math.ceil(s2 / 7e3)) + post);
      var w3 = o2.subarray(pre, o2.length - post);
      var lst = st2.l;
      var pos = (st2.r || 0) & 7;
      if (lvl) {
        if (pos)
          w3[0] = st2.r >> 3;
        var opt = deo[lvl - 1];
        var n = opt >> 13, c2 = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        var prev = st2.p || new u16(32768), head = st2.h || new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function(i3) {
          return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
        };
        var syms = new i32(25e3);
        var lf = new u16(288), df = new u16(32);
        var lc_1 = 0, eb = 0, i2 = st2.i || 0, li = 0, wi = st2.w || 0, bs = 0;
        for (; i2 + 2 < s2; ++i2) {
          var hv = hsh(i2);
          var imod = i2 & 32767, pimod = head[hv];
          prev[imod] = pimod;
          head[hv] = imod;
          if (wi <= i2) {
            var rem = s2 - i2;
            if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
              pos = wblk(dat, w3, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
              li = lc_1 = eb = 0, bs = i2;
              for (var j3 = 0; j3 < 286; ++j3)
                lf[j3] = 0;
              for (var j3 = 0; j3 < 30; ++j3)
                df[j3] = 0;
            }
            var l4 = 2, d3 = 0, ch_1 = c2, dif = imod - pimod & 32767;
            if (rem > 2 && hv == hsh(i2 - dif)) {
              var maxn = Math.min(n, rem) - 1;
              var maxd = Math.min(32767, i2);
              var ml = Math.min(258, rem);
              while (dif <= maxd && --ch_1 && imod != pimod) {
                if (dat[i2 + l4] == dat[i2 + l4 - dif]) {
                  var nl = 0;
                  for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                    ;
                  if (nl > l4) {
                    l4 = nl, d3 = dif;
                    if (nl > maxn)
                      break;
                    var mmd = Math.min(dif, nl - 2);
                    var md = 0;
                    for (var j3 = 0; j3 < mmd; ++j3) {
                      var ti = i2 - dif + j3 & 32767;
                      var pti = prev[ti];
                      var cd = ti - pti & 32767;
                      if (cd > md)
                        md = cd, pimod = ti;
                    }
                  }
                }
                imod = pimod, pimod = prev[imod];
                dif += imod - pimod & 32767;
              }
            }
            if (d3) {
              syms[li++] = 268435456 | revfl[l4] << 18 | revfd[d3];
              var lin = revfl[l4] & 31, din = revfd[d3] & 31;
              eb += fleb[lin] + fdeb[din];
              ++lf[257 + lin];
              ++df[din];
              wi = i2 + l4;
              ++lc_1;
            } else {
              syms[li++] = dat[i2];
              ++lf[dat[i2]];
            }
          }
        }
        for (i2 = Math.max(i2, wi); i2 < s2; ++i2) {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
        pos = wblk(dat, w3, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
        if (!lst) {
          st2.r = pos & 7 | w3[pos / 8 | 0] << 3;
          pos -= 7;
          st2.h = head, st2.p = prev, st2.i = i2, st2.w = wi;
        }
      } else {
        for (var i2 = st2.w || 0; i2 < s2 + lst; i2 += 65535) {
          var e = i2 + 65535;
          if (e >= s2) {
            w3[pos / 8 | 0] = lst;
            e = s2;
          }
          pos = wfblk(w3, pos + 1, dat.subarray(i2, e));
        }
        st2.i = s2;
      }
      return slc(o2, 0, pre + shft(pos) + post);
    };
    adler = function() {
      var a2 = 1, b3 = 0;
      return {
        p: function(d3) {
          var n = a2, m3 = b3;
          var l4 = d3.length | 0;
          for (var i2 = 0; i2 != l4; ) {
            var e = Math.min(i2 + 2655, l4);
            for (; i2 < e; ++i2)
              m3 += n += d3[i2];
            n = (n & 65535) + 15 * (n >> 16), m3 = (m3 & 65535) + 15 * (m3 >> 16);
          }
          a2 = n, b3 = m3;
        },
        d: function() {
          a2 %= 65521, b3 %= 65521;
          return (a2 & 255) << 24 | (a2 & 65280) << 8 | (b3 & 255) << 8 | b3 >> 8;
        }
      };
    };
    dopt = function(dat, opt, pre, post, st2) {
      if (!st2) {
        st2 = { l: 1 };
        if (opt.dictionary) {
          var dict = opt.dictionary.subarray(-32768);
          var newDat = new u8(dict.length + dat.length);
          newDat.set(dict);
          newDat.set(dat, dict.length);
          dat = newDat;
          st2.w = dict.length;
        }
      }
      return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st2.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st2);
    };
    wbytes = function(d3, b3, v3) {
      for (; v3; ++b3)
        d3[b3] = v3, v3 >>>= 8;
    };
    zlh = function(c2, o2) {
      var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
      c2[0] = 120, c2[1] = fl2 << 6 | (o2.dictionary && 32);
      c2[1] |= 31 - (c2[0] << 8 | c2[1]) % 31;
      if (o2.dictionary) {
        var h2 = adler();
        h2.p(o2.dictionary);
        wbytes(c2, 2, h2.d());
      }
    };
    td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
    tds = 0;
    try {
      td.decode(et, { stream: true });
      tds = 1;
    } catch (e) {
    }
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
var init_arrayWithHoles = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"() {
    "use strict";
  }
});

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r, l4) {
  var t2 = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t2) {
    var e, n, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t2 = t2.call(r)).next, 0 === l4) {
        if (Object(t2) !== t2) return;
        f2 = false;
      } else for (; !(f2 = (e = i2.call(t2)).done) && (a2.push(e.value), a2.length !== l4); f2 = true) ;
    } catch (r2) {
      o2 = true, n = r2;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n;
      }
    }
    return a2;
  }
}
var init_iterableToArrayLimit = __esm({
  "node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"() {
    "use strict";
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r, a2) {
  (null == a2 || a2 > r.length) && (a2 = r.length);
  for (var e = 0, n = Array(a2); e < a2; e++) n[e] = r[e];
  return n;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
    "use strict";
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r, a2) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a2);
    var t2 = {}.toString.call(r).slice(8, -1);
    return "Object" === t2 && r.constructor && (t2 = r.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r, a2) : void 0;
  }
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    "use strict";
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableRest = __esm({
  "node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"() {
    "use strict";
  }
});

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
var init_slicedToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/slicedToArray.js"() {
    "use strict";
    init_arrayWithHoles();
    init_iterableToArrayLimit();
    init_unsupportedIterableToArray();
    init_nonIterableRest();
  }
});

// node_modules/iobuffer/lib-esm/text.js
function decode(bytes, encoding = "utf8") {
  const decoder = new TextDecoder(encoding);
  return decoder.decode(bytes);
}
function encode(str) {
  return encoder.encode(str);
}
var encoder;
var init_text = __esm({
  "node_modules/iobuffer/lib-esm/text.js"() {
    "use strict";
    encoder = new TextEncoder();
  }
});

// node_modules/iobuffer/lib-esm/IOBuffer.js
var defaultByteLength, hostBigEndian, typedArrays, IOBuffer;
var init_IOBuffer = __esm({
  "node_modules/iobuffer/lib-esm/IOBuffer.js"() {
    "use strict";
    init_text();
    defaultByteLength = 1024 * 8;
    hostBigEndian = (() => {
      const array = new Uint8Array(4);
      const view = new Uint32Array(array.buffer);
      return !((view[0] = 1) & array[0]);
    })();
    typedArrays = {
      int8: globalThis.Int8Array,
      uint8: globalThis.Uint8Array,
      int16: globalThis.Int16Array,
      uint16: globalThis.Uint16Array,
      int32: globalThis.Int32Array,
      uint32: globalThis.Uint32Array,
      uint64: globalThis.BigUint64Array,
      int64: globalThis.BigInt64Array,
      float32: globalThis.Float32Array,
      float64: globalThis.Float64Array
    };
    IOBuffer = class _IOBuffer {
      /**
       * Reference to the internal ArrayBuffer object.
       */
      buffer;
      /**
       * Byte length of the internal ArrayBuffer.
       */
      byteLength;
      /**
       * Byte offset of the internal ArrayBuffer.
       */
      byteOffset;
      /**
       * Byte length of the internal ArrayBuffer.
       */
      length;
      /**
       * The current offset of the buffer's pointer.
       */
      offset;
      lastWrittenByte;
      littleEndian;
      _data;
      _mark;
      _marks;
      /**
       * Create a new IOBuffer.
       * @param data - The data to construct the IOBuffer with.
       * If data is a number, it will be the new buffer's length<br>
       * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
       * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
       * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
       * @param options - An object for the options.
       * @returns A new IOBuffer instance.
       */
      constructor(data = defaultByteLength, options = {}) {
        let dataIsGiven = false;
        if (typeof data === "number") {
          data = new ArrayBuffer(data);
        } else {
          dataIsGiven = true;
          this.lastWrittenByte = data.byteLength;
        }
        const offset = options.offset ? options.offset >>> 0 : 0;
        const byteLength = data.byteLength - offset;
        let dvOffset = offset;
        if (ArrayBuffer.isView(data) || data instanceof _IOBuffer) {
          if (data.byteLength !== data.buffer.byteLength) {
            dvOffset = data.byteOffset + offset;
          }
          data = data.buffer;
        }
        if (dataIsGiven) {
          this.lastWrittenByte = byteLength;
        } else {
          this.lastWrittenByte = 0;
        }
        this.buffer = data;
        this.length = byteLength;
        this.byteLength = byteLength;
        this.byteOffset = dvOffset;
        this.offset = 0;
        this.littleEndian = true;
        this._data = new DataView(this.buffer, dvOffset, byteLength);
        this._mark = 0;
        this._marks = [];
      }
      /**
       * Checks if the memory allocated to the buffer is sufficient to store more
       * bytes after the offset.
       * @param byteLength - The needed memory in bytes.
       * @returns `true` if there is sufficient space and `false` otherwise.
       */
      available(byteLength = 1) {
        return this.offset + byteLength <= this.length;
      }
      /**
       * Check if little-endian mode is used for reading and writing multi-byte
       * values.
       * @returns `true` if little-endian mode is used, `false` otherwise.
       */
      isLittleEndian() {
        return this.littleEndian;
      }
      /**
       * Set little-endian mode for reading and writing multi-byte values.
       * @returns This.
       */
      setLittleEndian() {
        this.littleEndian = true;
        return this;
      }
      /**
       * Check if big-endian mode is used for reading and writing multi-byte values.
       * @returns `true` if big-endian mode is used, `false` otherwise.
       */
      isBigEndian() {
        return !this.littleEndian;
      }
      /**
       * Switches to big-endian mode for reading and writing multi-byte values.
       * @returns This.
       */
      setBigEndian() {
        this.littleEndian = false;
        return this;
      }
      /**
       * Move the pointer n bytes forward.
       * @param n - Number of bytes to skip.
       * @returns This.
       */
      skip(n = 1) {
        this.offset += n;
        return this;
      }
      /**
       * Move the pointer n bytes backward.
       * @param n - Number of bytes to move back.
       * @returns This.
       */
      back(n = 1) {
        this.offset -= n;
        return this;
      }
      /**
       * Move the pointer to the given offset.
       * @param offset - The offset to move to.
       * @returns This.
       */
      seek(offset) {
        this.offset = offset;
        return this;
      }
      /**
       * Store the current pointer offset.
       * @see {@link IOBuffer#reset}
       * @returns This.
       */
      mark() {
        this._mark = this.offset;
        return this;
      }
      /**
       * Move the pointer back to the last pointer offset set by mark.
       * @see {@link IOBuffer#mark}
       * @returns This.
       */
      reset() {
        this.offset = this._mark;
        return this;
      }
      /**
       * Push the current pointer offset to the mark stack.
       * @see {@link IOBuffer#popMark}
       * @returns This.
       */
      pushMark() {
        this._marks.push(this.offset);
        return this;
      }
      /**
       * Pop the last pointer offset from the mark stack, and set the current
       * pointer offset to the popped value.
       * @see {@link IOBuffer#pushMark}
       * @returns This.
       */
      popMark() {
        const offset = this._marks.pop();
        if (offset === void 0) {
          throw new Error("Mark stack empty");
        }
        this.seek(offset);
        return this;
      }
      /**
       * Move the pointer offset back to 0.
       * @returns This.
       */
      rewind() {
        this.offset = 0;
        return this;
      }
      /**
       * Make sure the buffer has sufficient memory to write a given byteLength at
       * the current pointer offset.
       * If the buffer's memory is insufficient, this method will create a new
       * buffer (a copy) with a length that is twice (byteLength + current offset).
       * @param byteLength - The needed memory in bytes.
       * @returns This.
       */
      ensureAvailable(byteLength = 1) {
        if (!this.available(byteLength)) {
          const lengthNeeded = this.offset + byteLength;
          const newLength = lengthNeeded * 2;
          const newArray = new Uint8Array(newLength);
          newArray.set(new Uint8Array(this.buffer));
          this.buffer = newArray.buffer;
          this.length = newLength;
          this.byteLength = newLength;
          this._data = new DataView(this.buffer);
        }
        return this;
      }
      /**
       * Read a byte and return false if the byte's value is 0, or true otherwise.
       * Moves pointer forward by one byte.
       * @returns The read boolean.
       */
      readBoolean() {
        return this.readUint8() !== 0;
      }
      /**
       * Read a signed 8-bit integer and move pointer forward by 1 byte.
       * @returns The read byte.
       */
      readInt8() {
        return this._data.getInt8(this.offset++);
      }
      /**
       * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
       * @returns The read byte.
       */
      readUint8() {
        return this._data.getUint8(this.offset++);
      }
      /**
       * Alias for {@link IOBuffer#readUint8}.
       * @returns The read byte.
       */
      readByte() {
        return this.readUint8();
      }
      /**
       * Read `n` bytes and move pointer forward by `n` bytes.
       * @param n - Number of bytes to read.
       * @returns The read bytes.
       */
      readBytes(n = 1) {
        return this.readArray(n, "uint8");
      }
      /**
       * Creates an array of corresponding to the type `type` and size `size`.
       * For example type `uint8` will create a `Uint8Array`.
       * @param size - size of the resulting array
       * @param type - number type of elements to read
       * @returns The read array.
       */
      readArray(size, type) {
        const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;
        const offset = this.byteOffset + this.offset;
        const slice = this.buffer.slice(offset, offset + bytes);
        if (this.littleEndian === hostBigEndian && type !== "uint8" && type !== "int8") {
          const slice2 = new Uint8Array(this.buffer.slice(offset, offset + bytes));
          slice2.reverse();
          const returnArray2 = new typedArrays[type](slice2.buffer);
          this.offset += bytes;
          returnArray2.reverse();
          return returnArray2;
        }
        const returnArray = new typedArrays[type](slice);
        this.offset += bytes;
        return returnArray;
      }
      /**
       * Read a 16-bit signed integer and move pointer forward by 2 bytes.
       * @returns The read value.
       */
      readInt16() {
        const value = this._data.getInt16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      /**
       * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
       * @returns The read value.
       */
      readUint16() {
        const value = this._data.getUint16(this.offset, this.littleEndian);
        this.offset += 2;
        return value;
      }
      /**
       * Read a 32-bit signed integer and move pointer forward by 4 bytes.
       * @returns The read value.
       */
      readInt32() {
        const value = this._data.getInt32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
       * @returns The read value.
       */
      readUint32() {
        const value = this._data.getUint32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 32-bit floating number and move pointer forward by 4 bytes.
       * @returns The read value.
       */
      readFloat32() {
        const value = this._data.getFloat32(this.offset, this.littleEndian);
        this.offset += 4;
        return value;
      }
      /**
       * Read a 64-bit floating number and move pointer forward by 8 bytes.
       * @returns The read value.
       */
      readFloat64() {
        const value = this._data.getFloat64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
       * @returns The read value.
       */
      readBigInt64() {
        const value = this._data.getBigInt64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
       * @returns The read value.
       */
      readBigUint64() {
        const value = this._data.getBigUint64(this.offset, this.littleEndian);
        this.offset += 8;
        return value;
      }
      /**
       * Read a 1-byte ASCII character and move pointer forward by 1 byte.
       * @returns The read character.
       */
      readChar() {
        return String.fromCharCode(this.readInt8());
      }
      /**
       * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
       * @param n - Number of characters to read.
       * @returns The read characters.
       */
      readChars(n = 1) {
        let result = "";
        for (let i2 = 0; i2 < n; i2++) {
          result += this.readChar();
        }
        return result;
      }
      /**
       * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
       * forward by `n` bytes.
       * @param n - Number of bytes to read.
       * @returns The decoded string.
       */
      readUtf8(n = 1) {
        return decode(this.readBytes(n));
      }
      /**
       * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
       * forward by `n` bytes.
       * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
       * @param n - Number of bytes to read.
       * @param encoding - The encoding to use. Default is 'utf8'.
       * @returns The decoded string.
       */
      decodeText(n = 1, encoding = "utf8") {
        return decode(this.readBytes(n), encoding);
      }
      /**
       * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
       * forward by 1 byte.
       * @param value - The value to write.
       * @returns This.
       */
      writeBoolean(value) {
        this.writeUint8(value ? 255 : 0);
        return this;
      }
      /**
       * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
       * @param value - The value to write.
       * @returns This.
       */
      writeInt8(value) {
        this.ensureAvailable(1);
        this._data.setInt8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
       * byte.
       * @param value - The value to write.
       * @returns This.
       */
      writeUint8(value) {
        this.ensureAvailable(1);
        this._data.setUint8(this.offset++, value);
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * An alias for {@link IOBuffer#writeUint8}.
       * @param value - The value to write.
       * @returns This.
       */
      writeByte(value) {
        return this.writeUint8(value);
      }
      /**
       * Write all elements of `bytes` as uint8 values and move pointer forward by
       * `bytes.length` bytes.
       * @param bytes - The array of bytes to write.
       * @returns This.
       */
      writeBytes(bytes) {
        this.ensureAvailable(bytes.length);
        for (let i2 = 0; i2 < bytes.length; i2++) {
          this._data.setUint8(this.offset++, bytes[i2]);
        }
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 16-bit signed integer and move pointer forward by 2
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeInt16(value) {
        this.ensureAvailable(2);
        this._data.setInt16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeUint16(value) {
        this.ensureAvailable(2);
        this._data.setUint16(this.offset, value, this.littleEndian);
        this.offset += 2;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit signed integer and move pointer forward by 4
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeInt32(value) {
        this.ensureAvailable(4);
        this._data.setInt32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeUint32(value) {
        this.ensureAvailable(4);
        this._data.setUint32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 32-bit floating number and move pointer forward by 4
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeFloat32(value) {
        this.ensureAvailable(4);
        this._data.setFloat32(this.offset, value, this.littleEndian);
        this.offset += 4;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit floating number and move pointer forward by 8
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeFloat64(value) {
        this.ensureAvailable(8);
        this._data.setFloat64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit signed bigint and move pointer forward by 8
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeBigInt64(value) {
        this.ensureAvailable(8);
        this._data.setBigInt64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
       * bytes.
       * @param value - The value to write.
       * @returns This.
       */
      writeBigUint64(value) {
        this.ensureAvailable(8);
        this._data.setBigUint64(this.offset, value, this.littleEndian);
        this.offset += 8;
        this._updateLastWrittenByte();
        return this;
      }
      /**
       * Write the charCode of `str`'s first character as an 8-bit unsigned integer
       * and move pointer forward by 1 byte.
       * @param str - The character to write.
       * @returns This.
       */
      writeChar(str) {
        return this.writeUint8(str.charCodeAt(0));
      }
      /**
       * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
       * and move pointer forward by `str.length` bytes.
       * @param str - The characters to write.
       * @returns This.
       */
      writeChars(str) {
        for (let i2 = 0; i2 < str.length; i2++) {
          this.writeUint8(str.charCodeAt(i2));
        }
        return this;
      }
      /**
       * UTF-8 encode and write `str` to the current pointer offset and move pointer
       * forward according to the encoded length.
       * @param str - The string to write.
       * @returns This.
       */
      writeUtf8(str) {
        return this.writeBytes(encode(str));
      }
      /**
       * Export a Uint8Array view of the internal buffer.
       * The view starts at the byte offset and its length
       * is calculated to stop at the last written byte or the original length.
       * @returns A new Uint8Array view.
       */
      toArray() {
        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
      }
      /**
       *  Get the total number of bytes written so far, regardless of the current offset.
       * @returns - Total number of bytes.
       */
      getWrittenByteLength() {
        return this.lastWrittenByte - this.byteOffset;
      }
      /**
       * Update the last written byte offset
       * @private
       */
      _updateLastWrittenByte() {
        if (this.offset > this.lastWrittenByte) {
          this.lastWrittenByte = this.offset;
        }
      }
    };
  }
});

// node_modules/pako/dist/pako.esm.mjs
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Z_FIXED$1, Z_BINARY, Z_TEXT, Z_UNKNOWN$1, STORED_BLOCK, STATIC_TREES, DYN_TREES, MIN_MATCH$1, MAX_MATCH$1, LENGTH_CODES$1, LITERALS$1, L_CODES$1, D_CODES$1, BL_CODES$1, HEAP_SIZE$1, MAX_BITS$1, Buf_size, MAX_BL_BITS, END_BLOCK, REP_3_6, REPZ_3_10, REPZ_11_138, extra_lbits, extra_dbits, extra_blbits, bl_order, DIST_CODE_LEN, static_ltree, static_dtree, _dist_code, _length_code, base_length, base_dist, static_l_desc, static_d_desc, static_bl_desc, d_code, put_short, send_bits, send_code, bi_reverse, bi_flush, gen_bitlen, gen_codes, tr_static_init, init_block, bi_windup, smaller, pqdownheap, compress_block, build_tree, scan_tree, send_tree, build_bl_tree, send_all_trees, detect_data_type, static_init_done, _tr_init$1, _tr_stored_block$1, _tr_align$1, _tr_flush_block$1, _tr_tally$1, _tr_init_1, _tr_stored_block_1, _tr_flush_block_1, _tr_tally_1, _tr_align_1, trees, adler32, adler32_1, makeTable, crcTable, crc32, crc32_1, messages, constants$2, _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align, Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH$1, Z_FINISH$3, Z_BLOCK$1, Z_OK$3, Z_STREAM_END$3, Z_STREAM_ERROR$2, Z_DATA_ERROR$2, Z_BUF_ERROR$1, Z_DEFAULT_COMPRESSION$1, Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY$1, Z_UNKNOWN, Z_DEFLATED$2, MAX_MEM_LEVEL, MAX_WBITS$1, DEF_MEM_LEVEL, LENGTH_CODES, LITERALS, L_CODES, D_CODES, BL_CODES, HEAP_SIZE, MAX_BITS, MIN_MATCH, MAX_MATCH, MIN_LOOKAHEAD, PRESET_DICT, INIT_STATE, GZIP_STATE, EXTRA_STATE, NAME_STATE, COMMENT_STATE, HCRC_STATE, BUSY_STATE, FINISH_STATE, BS_NEED_MORE, BS_BLOCK_DONE, BS_FINISH_STARTED, BS_FINISH_DONE, OS_CODE, err, rank, zero, slide_hash, HASH_ZLIB, HASH, flush_pending, flush_block_only, put_byte, putShortMSB, read_buf, longest_match, fill_window, deflate_stored, deflate_fast, deflate_slow, deflate_rle, deflate_huff, configuration_table, lm_init, deflateStateCheck, deflateResetKeep, deflateReset, deflateSetHeader, deflateInit2, deflateInit, deflate$2, deflateEnd, deflateSetDictionary, deflateInit_1, deflateInit2_1, deflateReset_1, deflateResetKeep_1, deflateSetHeader_1, deflate_2$1, deflateEnd_1, deflateSetDictionary_1, deflateInfo, deflate_1$2, _has, assign, flattenChunks, common, STR_APPLY_UIA_OK, _utf8len, string2buf, buf2binstring, buf2string, utf8border, strings, zstream, toString$1, Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH$2, Z_OK$2, Z_STREAM_END$2, Z_DEFAULT_COMPRESSION, Z_DEFAULT_STRATEGY, Z_DEFLATED$1, Deflate_1$1, deflate_2, deflateRaw_1$1, gzip_1$1, constants$1, deflate_1$1, BAD$1, TYPE$1, inffast, MAXBITS, ENOUGH_LENS$1, ENOUGH_DISTS$1, CODES$1, LENS$1, DISTS$1, lbase, lext, dbase, dext, inflate_table, inftrees, CODES, LENS, DISTS, Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK$1, Z_STREAM_END$1, Z_NEED_DICT$1, Z_STREAM_ERROR$1, Z_DATA_ERROR$1, Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED, HEAD, FLAGS, TIME, OS, EXLEN, EXTRA, NAME, COMMENT, HCRC, DICTID, DICT, TYPE, TYPEDO, STORED, COPY_, COPY, TABLE, LENLENS, CODELENS, LEN_, LEN, LENEXT, DIST, DISTEXT, MATCH, LIT, CHECK, LENGTH, DONE, BAD, MEM, SYNC, ENOUGH_LENS, ENOUGH_DISTS, MAX_WBITS, DEF_WBITS, zswap32, inflateStateCheck, inflateResetKeep, inflateReset, inflateReset2, inflateInit2, inflateInit, virgin, lenfix, distfix, fixedtables, updatewindow, inflate$2, inflateEnd, inflateGetHeader, inflateSetDictionary, inflateReset_1, inflateReset2_1, inflateResetKeep_1, inflateInit_1, inflateInit2_1, inflate_2$1, inflateEnd_1, inflateGetHeader_1, inflateSetDictionary_1, inflateInfo, inflate_1$2, gzheader, toString, Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR, Inflate_1$1, inflate_2, inflateRaw_1$1, ungzip$1, constants, inflate_1$1, Deflate, deflate, deflateRaw, gzip, Inflate, inflate, inflateRaw, ungzip, Inflate_1, inflate_1;
var init_pako_esm = __esm({
  "node_modules/pako/dist/pako.esm.mjs"() {
    "use strict";
    Z_FIXED$1 = 4;
    Z_BINARY = 0;
    Z_TEXT = 1;
    Z_UNKNOWN$1 = 2;
    STORED_BLOCK = 0;
    STATIC_TREES = 1;
    DYN_TREES = 2;
    MIN_MATCH$1 = 3;
    MAX_MATCH$1 = 258;
    LENGTH_CODES$1 = 29;
    LITERALS$1 = 256;
    L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
    D_CODES$1 = 30;
    BL_CODES$1 = 19;
    HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
    MAX_BITS$1 = 15;
    Buf_size = 16;
    MAX_BL_BITS = 7;
    END_BLOCK = 256;
    REP_3_6 = 16;
    REPZ_3_10 = 17;
    REPZ_11_138 = 18;
    extra_lbits = /* extra bits for each length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
    extra_dbits = /* extra bits for each distance code */
    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    extra_blbits = /* extra bits for each bit length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
    bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    DIST_CODE_LEN = 512;
    static_ltree = new Array((L_CODES$1 + 2) * 2);
    zero$1(static_ltree);
    static_dtree = new Array(D_CODES$1 * 2);
    zero$1(static_dtree);
    _dist_code = new Array(DIST_CODE_LEN);
    zero$1(_dist_code);
    _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
    zero$1(_length_code);
    base_length = new Array(LENGTH_CODES$1);
    zero$1(base_length);
    base_dist = new Array(D_CODES$1);
    zero$1(base_dist);
    d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    put_short = (s2, w3) => {
      s2.pending_buf[s2.pending++] = w3 & 255;
      s2.pending_buf[s2.pending++] = w3 >>> 8 & 255;
    };
    send_bits = (s2, value, length) => {
      if (s2.bi_valid > Buf_size - length) {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        put_short(s2, s2.bi_buf);
        s2.bi_buf = value >> Buf_size - s2.bi_valid;
        s2.bi_valid += length - Buf_size;
      } else {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        s2.bi_valid += length;
      }
    };
    send_code = (s2, c2, tree) => {
      send_bits(
        s2,
        tree[c2 * 2],
        tree[c2 * 2 + 1]
        /*.Len*/
      );
    };
    bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    bi_flush = (s2) => {
      if (s2.bi_valid === 16) {
        put_short(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    };
    gen_bitlen = (s2, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h2;
      let n, m3;
      let bits;
      let xbits;
      let f2;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
        n = s2.heap[h2];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f2 = tree[n * 2];
        s2.opt_len += f2 * (bits + xbits);
        if (has_stree) {
          s2.static_len += f2 * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s2.bl_count[bits];
        while (n !== 0) {
          m3 = s2.heap[--h2];
          if (m3 > max_code) {
            continue;
          }
          if (tree[m3 * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m3 * 2 + 1]) * tree[m3 * 2];
            tree[m3 * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS$1 + 1);
      let code = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS$1; bits++) {
        code = code + bl_count[bits - 1] << 1;
        next_code[bits] = code;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    tr_static_init = () => {
      let n;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS$1 + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES$1; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS$1; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
      for (n = 0; n < D_CODES$1; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
    };
    init_block = (s2) => {
      let n;
      for (n = 0; n < L_CODES$1; n++) {
        s2.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES$1; n++) {
        s2.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES$1; n++) {
        s2.bl_tree[n * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.sym_next = s2.matches = 0;
    };
    bi_windup = (s2) => {
      if (s2.bi_valid > 8) {
        put_short(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    };
    smaller = (tree, n, m3, depth) => {
      const _n2 = n * 2;
      const _m2 = m3 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m3];
    };
    pqdownheap = (s2, tree, k3) => {
      const v3 = s2.heap[k3];
      let j3 = k3 << 1;
      while (j3 <= s2.heap_len) {
        if (j3 < s2.heap_len && smaller(tree, s2.heap[j3 + 1], s2.heap[j3], s2.depth)) {
          j3++;
        }
        if (smaller(tree, v3, s2.heap[j3], s2.depth)) {
          break;
        }
        s2.heap[k3] = s2.heap[j3];
        k3 = j3;
        j3 <<= 1;
      }
      s2.heap[k3] = v3;
    };
    compress_block = (s2, ltree, dtree) => {
      let dist;
      let lc2;
      let sx = 0;
      let code;
      let extra;
      if (s2.sym_next !== 0) {
        do {
          dist = s2.pending_buf[s2.sym_buf + sx++] & 255;
          dist += (s2.pending_buf[s2.sym_buf + sx++] & 255) << 8;
          lc2 = s2.pending_buf[s2.sym_buf + sx++];
          if (dist === 0) {
            send_code(s2, lc2, ltree);
          } else {
            code = _length_code[lc2];
            send_code(s2, code + LITERALS$1 + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc2 -= base_length[code];
              send_bits(s2, lc2, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s2, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s2, dist, extra);
            }
          }
        } while (sx < s2.sym_next);
      }
      send_code(s2, END_BLOCK, ltree);
    };
    build_tree = (s2, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m3;
      let max_code = -1;
      let node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE$1;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n;
          s2.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s2.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s2, tree, n);
      }
      node = elems;
      do {
        n = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m3 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n;
        s2.heap[--s2.heap_max] = m3;
        tree[node * 2] = tree[n * 2] + tree[m3 * 2];
        s2.depth[node] = (s2.depth[n] >= s2.depth[m3] ? s2.depth[n] : s2.depth[m3]) + 1;
        tree[n * 2 + 1] = tree[m3 * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s2, desc);
      gen_codes(tree, max_code, s2.bl_count);
    };
    scan_tree = (s2, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    send_tree = (s2, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code(s2, REP_3_6, s2.bl_tree);
          send_bits(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code(s2, REPZ_3_10, s2.bl_tree);
          send_bits(s2, count - 3, 3);
        } else {
          send_code(s2, REPZ_11_138, s2.bl_tree);
          send_bits(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    build_bl_tree = (s2) => {
      let max_blindex;
      scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree(s2, s2.bl_desc);
      for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    send_all_trees = (s2, lcodes, dcodes, blcodes) => {
      let rank2;
      send_bits(s2, lcodes - 257, 5);
      send_bits(s2, dcodes - 1, 5);
      send_bits(s2, blcodes - 4, 4);
      for (rank2 = 0; rank2 < blcodes; rank2++) {
        send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
      }
      send_tree(s2, s2.dyn_ltree, lcodes - 1);
      send_tree(s2, s2.dyn_dtree, dcodes - 1);
    };
    detect_data_type = (s2) => {
      let block_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, block_mask >>>= 1) {
        if (block_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS$1; n++) {
        if (s2.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    static_init_done = false;
    _tr_init$1 = (s2) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
      s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
      s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block(s2);
    };
    _tr_stored_block$1 = (s2, buf, stored_len, last) => {
      send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      bi_windup(s2);
      put_short(s2, stored_len);
      put_short(s2, ~stored_len);
      if (stored_len) {
        s2.pending_buf.set(s2.window.subarray(buf, buf + stored_len), s2.pending);
      }
      s2.pending += stored_len;
    };
    _tr_align$1 = (s2) => {
      send_bits(s2, STATIC_TREES << 1, 3);
      send_code(s2, END_BLOCK, static_ltree);
      bi_flush(s2);
    };
    _tr_flush_block$1 = (s2, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN$1) {
          s2.strm.data_type = detect_data_type(s2);
        }
        build_tree(s2, s2.l_desc);
        build_tree(s2, s2.d_desc);
        max_blindex = build_bl_tree(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block$1(s2, buf, stored_len, last);
      } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
        send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s2, static_ltree, static_dtree);
      } else {
        send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block(s2);
      if (last) {
        bi_windup(s2);
      }
    };
    _tr_tally$1 = (s2, dist, lc2) => {
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist;
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist >> 8;
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = lc2;
      if (dist === 0) {
        s2.dyn_ltree[lc2 * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code[lc2] + LITERALS$1 + 1) * 2]++;
        s2.dyn_dtree[d_code(dist) * 2]++;
      }
      return s2.sym_next === s2.sym_end;
    };
    _tr_init_1 = _tr_init$1;
    _tr_stored_block_1 = _tr_stored_block$1;
    _tr_flush_block_1 = _tr_flush_block$1;
    _tr_tally_1 = _tr_tally$1;
    _tr_align_1 = _tr_align$1;
    trees = {
      _tr_init: _tr_init_1,
      _tr_stored_block: _tr_stored_block_1,
      _tr_flush_block: _tr_flush_block_1,
      _tr_tally: _tr_tally_1,
      _tr_align: _tr_align_1
    };
    adler32 = (adler2, buf, len, pos) => {
      let s1 = adler2 & 65535 | 0, s2 = adler2 >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    adler32_1 = adler32;
    makeTable = () => {
      let c2, table = [];
      for (var n = 0; n < 256; n++) {
        c2 = n;
        for (var k3 = 0; k3 < 8; k3++) {
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        }
        table[n] = c2;
      }
      return table;
    };
    crcTable = new Uint32Array(makeTable());
    crc32 = (crc2, buf, len, pos) => {
      const t2 = crcTable;
      const end = pos + len;
      crc2 ^= -1;
      for (let i2 = pos; i2 < end; i2++) {
        crc2 = crc2 >>> 8 ^ t2[(crc2 ^ buf[i2]) & 255];
      }
      return crc2 ^ -1;
    };
    crc32_1 = crc32;
    messages = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
    constants$2 = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
    ({ _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees);
    ({
      Z_NO_FLUSH: Z_NO_FLUSH$2,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH: Z_FULL_FLUSH$1,
      Z_FINISH: Z_FINISH$3,
      Z_BLOCK: Z_BLOCK$1,
      Z_OK: Z_OK$3,
      Z_STREAM_END: Z_STREAM_END$3,
      Z_STREAM_ERROR: Z_STREAM_ERROR$2,
      Z_DATA_ERROR: Z_DATA_ERROR$2,
      Z_BUF_ERROR: Z_BUF_ERROR$1,
      Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
      Z_UNKNOWN,
      Z_DEFLATED: Z_DEFLATED$2
    } = constants$2);
    MAX_MEM_LEVEL = 9;
    MAX_WBITS$1 = 15;
    DEF_MEM_LEVEL = 8;
    LENGTH_CODES = 29;
    LITERALS = 256;
    L_CODES = LITERALS + 1 + LENGTH_CODES;
    D_CODES = 30;
    BL_CODES = 19;
    HEAP_SIZE = 2 * L_CODES + 1;
    MAX_BITS = 15;
    MIN_MATCH = 3;
    MAX_MATCH = 258;
    MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    PRESET_DICT = 32;
    INIT_STATE = 42;
    GZIP_STATE = 57;
    EXTRA_STATE = 69;
    NAME_STATE = 73;
    COMMENT_STATE = 91;
    HCRC_STATE = 103;
    BUSY_STATE = 113;
    FINISH_STATE = 666;
    BS_NEED_MORE = 1;
    BS_BLOCK_DONE = 2;
    BS_FINISH_STARTED = 3;
    BS_FINISH_DONE = 4;
    OS_CODE = 3;
    err = (strm, errorCode) => {
      strm.msg = messages[errorCode];
      return errorCode;
    };
    rank = (f2) => {
      return f2 * 2 - (f2 > 4 ? 9 : 0);
    };
    zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    slide_hash = (s2) => {
      let n, m3;
      let p2;
      let wsize = s2.w_size;
      n = s2.hash_size;
      p2 = n;
      do {
        m3 = s2.head[--p2];
        s2.head[p2] = m3 >= wsize ? m3 - wsize : 0;
      } while (--n);
      n = wsize;
      p2 = n;
      do {
        m3 = s2.prev[--p2];
        s2.prev[p2] = m3 >= wsize ? m3 - wsize : 0;
      } while (--n);
    };
    HASH_ZLIB = (s2, prev, data) => (prev << s2.hash_shift ^ data) & s2.hash_mask;
    HASH = HASH_ZLIB;
    flush_pending = (strm) => {
      const s2 = strm.state;
      let len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len), strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    };
    flush_block_only = (s2, last) => {
      _tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
      s2.block_start = s2.strstart;
      flush_pending(s2.strm);
    };
    put_byte = (s2, b3) => {
      s2.pending_buf[s2.pending++] = b3;
    };
    putShortMSB = (s2, b3) => {
      s2.pending_buf[s2.pending++] = b3 >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b3 & 255;
    };
    read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32_1(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32_1(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    longest_match = (s2, cur_match) => {
      let chain_length = s2.max_chain_length;
      let scan = s2.strstart;
      let match;
      let len;
      let best_len = s2.prev_length;
      let nice_match = s2.nice_match;
      const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s2.window;
      const wmask = s2.w_mask;
      const prev = s2.prev;
      const strend = s2.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    };
    fill_window = (s2) => {
      const _w_size = s2.w_size;
      let n, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          if (s2.insert > s2.strstart) {
            s2.insert = s2.strstart;
          }
          slide_hash(s2);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n;
        if (s2.lookahead + s2.insert >= MIN_MATCH) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + 1]);
          while (s2.insert) {
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
    };
    deflate_stored = (s2, flush) => {
      let min_block = s2.pending_buf_size - 5 > s2.w_size ? s2.w_size : s2.pending_buf_size - 5;
      let len, left, have, last = 0;
      let used = s2.strm.avail_in;
      do {
        len = 65535;
        have = s2.bi_valid + 42 >> 3;
        if (s2.strm.avail_out < have) {
          break;
        }
        have = s2.strm.avail_out - have;
        left = s2.strstart - s2.block_start;
        if (len > left + s2.strm.avail_in) {
          len = left + s2.strm.avail_in;
        }
        if (len > have) {
          len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s2.strm.avail_in)) {
          break;
        }
        last = flush === Z_FINISH$3 && len === left + s2.strm.avail_in ? 1 : 0;
        _tr_stored_block(s2, 0, 0, last);
        s2.pending_buf[s2.pending - 4] = len;
        s2.pending_buf[s2.pending - 3] = len >> 8;
        s2.pending_buf[s2.pending - 2] = ~len;
        s2.pending_buf[s2.pending - 1] = ~len >> 8;
        flush_pending(s2.strm);
        if (left) {
          if (left > len) {
            left = len;
          }
          s2.strm.output.set(s2.window.subarray(s2.block_start, s2.block_start + left), s2.strm.next_out);
          s2.strm.next_out += left;
          s2.strm.avail_out -= left;
          s2.strm.total_out += left;
          s2.block_start += left;
          len -= left;
        }
        if (len) {
          read_buf(s2.strm, s2.strm.output, s2.strm.next_out, len);
          s2.strm.next_out += len;
          s2.strm.avail_out -= len;
          s2.strm.total_out += len;
        }
      } while (last === 0);
      used -= s2.strm.avail_in;
      if (used) {
        if (used >= s2.w_size) {
          s2.matches = 2;
          s2.window.set(s2.strm.input.subarray(s2.strm.next_in - s2.w_size, s2.strm.next_in), 0);
          s2.strstart = s2.w_size;
          s2.insert = s2.strstart;
        } else {
          if (s2.window_size - s2.strstart <= used) {
            s2.strstart -= s2.w_size;
            s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
            if (s2.matches < 2) {
              s2.matches++;
            }
            if (s2.insert > s2.strstart) {
              s2.insert = s2.strstart;
            }
          }
          s2.window.set(s2.strm.input.subarray(s2.strm.next_in - used, s2.strm.next_in), s2.strstart);
          s2.strstart += used;
          s2.insert += used > s2.w_size - s2.insert ? s2.w_size - s2.insert : used;
        }
        s2.block_start = s2.strstart;
      }
      if (s2.high_water < s2.strstart) {
        s2.high_water = s2.strstart;
      }
      if (last) {
        return BS_FINISH_DONE;
      }
      if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s2.strm.avail_in === 0 && s2.strstart === s2.block_start) {
        return BS_BLOCK_DONE;
      }
      have = s2.window_size - s2.strstart;
      if (s2.strm.avail_in > have && s2.block_start >= s2.w_size) {
        s2.block_start -= s2.w_size;
        s2.strstart -= s2.w_size;
        s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
        if (s2.matches < 2) {
          s2.matches++;
        }
        have += s2.w_size;
        if (s2.insert > s2.strstart) {
          s2.insert = s2.strstart;
        }
      }
      if (have > s2.strm.avail_in) {
        have = s2.strm.avail_in;
      }
      if (have) {
        read_buf(s2.strm, s2.window, s2.strstart, have);
        s2.strstart += have;
        s2.insert += have > s2.w_size - s2.insert ? s2.w_size - s2.insert : have;
      }
      if (s2.high_water < s2.strstart) {
        s2.high_water = s2.strstart;
      }
      have = s2.bi_valid + 42 >> 3;
      have = s2.pending_buf_size - have > 65535 ? 65535 : s2.pending_buf_size - have;
      min_block = have > s2.w_size ? s2.w_size : have;
      left = s2.strstart - s2.block_start;
      if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s2.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last = flush === Z_FINISH$3 && s2.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block(s2, s2.block_start, len, last);
        s2.block_start += len;
        flush_pending(s2.strm);
      }
      return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    deflate_fast = (s2, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_slow = (s2, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
          bflush = _tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s2.match_available) {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_rle = (s2, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH) {
          fill_window(s2);
          if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s2, 1, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    deflate_huff = (s2, flush) => {
      let bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH$2) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH$3) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    lm_init = (s2) => {
      s2.window_size = 2 * s2.w_size;
      zero(s2.head);
      s2.max_lazy_match = configuration_table[s2.level].max_lazy;
      s2.good_match = configuration_table[s2.level].good_length;
      s2.nice_match = configuration_table[s2.level].nice_length;
      s2.max_chain_length = configuration_table[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    };
    deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s2 = strm.state;
      if (!s2 || s2.strm !== strm || s2.status !== INIT_STATE && //#ifdef GZIP
      s2.status !== GZIP_STATE && //#endif
      s2.status !== EXTRA_STATE && s2.status !== NAME_STATE && s2.status !== COMMENT_STATE && s2.status !== HCRC_STATE && s2.status !== BUSY_STATE && s2.status !== FINISH_STATE) {
        return 1;
      }
      return 0;
    };
    deflateResetKeep = (strm) => {
      if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = //#ifdef GZIP
      s2.wrap === 2 ? GZIP_STATE : (
        //#endif
        s2.wrap ? INIT_STATE : BUSY_STATE
      );
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = -2;
      _tr_init(s2);
      return Z_OK$3;
    };
    deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK$3) {
        lm_init(strm.state);
      }
      return ret;
    };
    deflateSetHeader = (strm, head) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR$2;
      }
      strm.state.gzhead = head;
      return Z_OK$3;
    };
    deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR$2;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION$1) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR$2);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s2 = new DeflateState();
      strm.state = s2;
      s2.strm = strm;
      s2.status = INIT_STATE;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s2.window = new Uint8Array(s2.w_size * 2);
      s2.head = new Uint16Array(s2.hash_size);
      s2.prev = new Uint16Array(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new Uint8Array(s2.pending_buf_size);
      s2.sym_buf = s2.lit_bufsize;
      s2.sym_end = (s2.lit_bufsize - 1) * 3;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset(strm);
    };
    deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
    };
    deflate$2 = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
      }
      const s2 = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s2.status === FINISH_STATE && flush !== Z_FINISH$3) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
      }
      const old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR$1);
      }
      if (s2.status === INIT_STATE && s2.wrap === 0) {
        s2.status = BUSY_STATE;
      }
      if (s2.status === INIT_STATE) {
        let header = Z_DEFLATED$2 + (s2.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
          level_flags = 0;
        } else if (s2.level < 6) {
          level_flags = 1;
        } else if (s2.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s2.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s2, header);
        if (s2.strstart !== 0) {
          putShortMSB(s2, strm.adler >>> 16);
          putShortMSB(s2, strm.adler & 65535);
        }
        strm.adler = 1;
        s2.status = BUSY_STATE;
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      }
      if (s2.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte(s2, 31);
        put_byte(s2, 139);
        put_byte(s2, 8);
        if (!s2.gzhead) {
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, OS_CODE);
          s2.status = BUSY_STATE;
          flush_pending(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
        } else {
          put_byte(
            s2,
            (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
          );
          put_byte(s2, s2.gzhead.time & 255);
          put_byte(s2, s2.gzhead.time >> 8 & 255);
          put_byte(s2, s2.gzhead.time >> 16 & 255);
          put_byte(s2, s2.gzhead.time >> 24 & 255);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, s2.gzhead.os & 255);
          if (s2.gzhead.extra && s2.gzhead.extra.length) {
            put_byte(s2, s2.gzhead.extra.length & 255);
            put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
          }
          if (s2.gzhead.hcrc) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending, 0);
          }
          s2.gzindex = 0;
          s2.status = EXTRA_STATE;
        }
      }
      if (s2.status === EXTRA_STATE) {
        if (s2.gzhead.extra) {
          let beg = s2.pending;
          let left = (s2.gzhead.extra.length & 65535) - s2.gzindex;
          while (s2.pending + left > s2.pending_buf_size) {
            let copy = s2.pending_buf_size - s2.pending;
            s2.pending_buf.set(s2.gzhead.extra.subarray(s2.gzindex, s2.gzindex + copy), s2.pending);
            s2.pending = s2.pending_buf_size;
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            s2.gzindex += copy;
            flush_pending(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK$3;
            }
            beg = 0;
            left -= copy;
          }
          let gzhead_extra = new Uint8Array(s2.gzhead.extra);
          s2.pending_buf.set(gzhead_extra.subarray(s2.gzindex, s2.gzindex + left), s2.pending);
          s2.pending += left;
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          s2.gzindex = 0;
        }
        s2.status = NAME_STATE;
      }
      if (s2.status === NAME_STATE) {
        if (s2.gzhead.name) {
          let beg = s2.pending;
          let val;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              if (s2.pending !== 0) {
                s2.last_flush = -1;
                return Z_OK$3;
              }
              beg = 0;
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          s2.gzindex = 0;
        }
        s2.status = COMMENT_STATE;
      }
      if (s2.status === COMMENT_STATE) {
        if (s2.gzhead.comment) {
          let beg = s2.pending;
          let val;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              if (s2.pending !== 0) {
                s2.last_flush = -1;
                return Z_OK$3;
              }
              beg = 0;
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
        }
        s2.status = HCRC_STATE;
      }
      if (s2.status === HCRC_STATE) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK$3;
            }
          }
          put_byte(s2, strm.adler & 255);
          put_byte(s2, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s2.status = BUSY_STATE;
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s2.status !== FINISH_STATE) {
        let bstate = s2.level === 0 ? deflate_stored(s2, flush) : s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s2.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK$3;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s2);
          } else if (flush !== Z_BLOCK$1) {
            _tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH$1) {
              zero(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
        }
      }
      if (flush !== Z_FINISH$3) {
        return Z_OK$3;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END$3;
      }
      if (s2.wrap === 2) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        put_byte(s2, strm.adler >> 16 & 255);
        put_byte(s2, strm.adler >> 24 & 255);
        put_byte(s2, strm.total_in & 255);
        put_byte(s2, strm.total_in >> 8 & 255);
        put_byte(s2, strm.total_in >> 16 & 255);
        put_byte(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
    };
    deflateEnd = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR$2;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
    };
    deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR$2;
      }
      const s2 = strm.state;
      const wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
        return Z_STREAM_ERROR$2;
      }
      if (wrap === 1) {
        strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        let tmpDict = new Uint8Array(s2.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s2);
      while (s2.lookahead >= MIN_MATCH) {
        let str = s2.strstart;
        let n = s2.lookahead - (MIN_MATCH - 1);
        do {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH - 1;
        fill_window(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK$3;
    };
    deflateInit_1 = deflateInit;
    deflateInit2_1 = deflateInit2;
    deflateReset_1 = deflateReset;
    deflateResetKeep_1 = deflateResetKeep;
    deflateSetHeader_1 = deflateSetHeader;
    deflate_2$1 = deflate$2;
    deflateEnd_1 = deflateEnd;
    deflateSetDictionary_1 = deflateSetDictionary;
    deflateInfo = "pako deflate (from Nodeca project)";
    deflate_1$2 = {
      deflateInit: deflateInit_1,
      deflateInit2: deflateInit2_1,
      deflateReset: deflateReset_1,
      deflateResetKeep: deflateResetKeep_1,
      deflateSetHeader: deflateSetHeader_1,
      deflate: deflate_2$1,
      deflateEnd: deflateEnd_1,
      deflateSetDictionary: deflateSetDictionary_1,
      deflateInfo
    };
    _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p2 in source) {
          if (_has(source, p2)) {
            obj[p2] = source[p2];
          }
        }
      }
      return obj;
    };
    flattenChunks = (chunks) => {
      let len = 0;
      for (let i2 = 0, l4 = chunks.length; i2 < l4; i2++) {
        len += chunks[i2].length;
      }
      const result = new Uint8Array(len);
      for (let i2 = 0, pos = 0, l4 = chunks.length; i2 < l4; i2++) {
        let chunk = chunks[i2];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
    common = {
      assign,
      flattenChunks
    };
    STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    _utf8len = new Uint8Array(256);
    for (let q3 = 0; q3 < 256; q3++) {
      _utf8len[q3] = q3 >= 252 ? 6 : q3 >= 248 ? 5 : q3 >= 240 ? 4 : q3 >= 224 ? 3 : q3 >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c2 < 128) {
          buf[i2++] = c2;
        } else if (c2 < 2048) {
          buf[i2++] = 192 | c2 >>> 6;
          buf[i2++] = 128 | c2 & 63;
        } else if (c2 < 65536) {
          buf[i2++] = 224 | c2 >>> 12;
          buf[i2++] = 128 | c2 >>> 6 & 63;
          buf[i2++] = 128 | c2 & 63;
        } else {
          buf[i2++] = 240 | c2 >>> 18;
          buf[i2++] = 128 | c2 >>> 12 & 63;
          buf[i2++] = 128 | c2 >>> 6 & 63;
          buf[i2++] = 128 | c2 & 63;
        }
      }
      return buf;
    };
    buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i2 = 0; i2 < len; i2++) {
        result += String.fromCharCode(buf[i2]);
      }
      return result;
    };
    buf2string = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i2, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        let c2 = buf[i2++];
        if (c2 < 128) {
          utf16buf[out++] = c2;
          continue;
        }
        let c_len = _utf8len[c2];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c2 = c2 << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c2 < 65536) {
          utf16buf[out++] = c2;
        } else {
          c2 -= 65536;
          utf16buf[out++] = 55296 | c2 >> 10 & 1023;
          utf16buf[out++] = 56320 | c2 & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
    strings = {
      string2buf,
      buf2string,
      utf8border
    };
    zstream = ZStream;
    toString$1 = Object.prototype.toString;
    ({
      Z_NO_FLUSH: Z_NO_FLUSH$1,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH: Z_FINISH$2,
      Z_OK: Z_OK$2,
      Z_STREAM_END: Z_STREAM_END$2,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED: Z_DEFLATED$1
    } = constants$2);
    Deflate$1.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString$1.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = deflate_1$2.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END$2) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = deflate_1$2.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK$2;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Deflate$1.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate$1.prototype.onEnd = function(status) {
      if (status === Z_OK$2) {
        this.result = common.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    Deflate_1$1 = Deflate$1;
    deflate_2 = deflate$1;
    deflateRaw_1$1 = deflateRaw$1;
    gzip_1$1 = gzip$1;
    constants$1 = constants$2;
    deflate_1$1 = {
      Deflate: Deflate_1$1,
      deflate: deflate_2,
      deflateRaw: deflateRaw_1$1,
      gzip: gzip_1$1,
      constants: constants$1
    };
    BAD$1 = 16209;
    TYPE$1 = 16191;
    inffast = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD$1;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD$1;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE$1;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD$1;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
    MAXBITS = 15;
    ENOUGH_LENS$1 = 852;
    ENOUGH_DISTS$1 = 592;
    CODES$1 = 0;
    LENS$1 = 1;
    DISTS$1 = 2;
    lbase = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    lext = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    dbase = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    dext = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let match;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES$1 || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES$1) {
        base = extra = work;
        match = 20;
      } else if (type === LENS$1) {
        base = lbase;
        extra = lext;
        match = 257;
      } else {
        base = dbase;
        extra = dext;
        match = 0;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] + 1 < match) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match) {
          here_op = extra[work[sym] - match];
          here_val = base[work[sym] - match];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    inftrees = inflate_table;
    CODES = 0;
    LENS = 1;
    DISTS = 2;
    ({
      Z_FINISH: Z_FINISH$1,
      Z_BLOCK,
      Z_TREES,
      Z_OK: Z_OK$1,
      Z_STREAM_END: Z_STREAM_END$1,
      Z_NEED_DICT: Z_NEED_DICT$1,
      Z_STREAM_ERROR: Z_STREAM_ERROR$1,
      Z_DATA_ERROR: Z_DATA_ERROR$1,
      Z_MEM_ERROR: Z_MEM_ERROR$1,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = constants$2);
    HEAD = 16180;
    FLAGS = 16181;
    TIME = 16182;
    OS = 16183;
    EXLEN = 16184;
    EXTRA = 16185;
    NAME = 16186;
    COMMENT = 16187;
    HCRC = 16188;
    DICTID = 16189;
    DICT = 16190;
    TYPE = 16191;
    TYPEDO = 16192;
    STORED = 16193;
    COPY_ = 16194;
    COPY = 16195;
    TABLE = 16196;
    LENLENS = 16197;
    CODELENS = 16198;
    LEN_ = 16199;
    LEN = 16200;
    LENEXT = 16201;
    DIST = 16202;
    DISTEXT = 16203;
    MATCH = 16204;
    LIT = 16205;
    CHECK = 16206;
    LENGTH = 16207;
    DONE = 16208;
    BAD = 16209;
    MEM = 16210;
    SYNC = 16211;
    ENOUGH_LENS = 852;
    ENOUGH_DISTS = 592;
    MAX_WBITS = 15;
    DEF_WBITS = MAX_WBITS;
    zswap32 = (q3) => {
      return (q3 >>> 24 & 255) + (q3 >>> 8 & 65280) + ((q3 & 65280) << 8) + ((q3 & 255) << 24);
    };
    inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state = strm.state;
      if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
        return 1;
      }
      return 0;
    };
    inflateResetKeep = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.flags = -1;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK$1;
    };
    inflateReset = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR$1;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR$1;
      }
      const state = new InflateState();
      strm.state = state;
      state.strm = strm;
      state.window = null;
      state.mode = HEAD;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK$1) {
        strm.state = null;
      }
      return ret;
    };
    inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    virgin = true;
    fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    inflate$2 = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK$1;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                if (state.wbits === 0) {
                  state.wbits = 15;
                }
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              }
              if (len > 15 || len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              state.flags = 0;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            /* falls through */
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32_1(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            /* falls through */
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            /* falls through */
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32_1(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            /* falls through */
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next + copy
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32_1(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            /* falls through */
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32_1(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            /* falls through */
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32_1(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            /* falls through */
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            /* falls through */
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT$1;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            /* falls through */
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case COPY_:
              state.mode = COPY;
            /* falls through */
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            /* falls through */
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            /* falls through */
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case LEN_:
              state.mode = LEN;
            /* falls through */
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inffast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            /* falls through */
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            /* falls through */
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            /* falls through */
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            /* falls through */
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
                }
                _out = left;
                if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            /* falls through */
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            /* falls through */
            case DONE:
              ret = Z_STREAM_END$1;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR$1;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR$1;
            case SYNC:
            /* falls through */
            default:
              return Z_STREAM_ERROR$1;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap & 4 && _out) {
        strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    inflateEnd = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK$1;
    };
    inflateGetHeader = (strm, head) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR$1;
      }
      state.head = head;
      head.done = false;
      return Z_OK$1;
    };
    inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR$1;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR$1;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32_1(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR$1;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR$1;
      }
      state.havedict = 1;
      return Z_OK$1;
    };
    inflateReset_1 = inflateReset;
    inflateReset2_1 = inflateReset2;
    inflateResetKeep_1 = inflateResetKeep;
    inflateInit_1 = inflateInit;
    inflateInit2_1 = inflateInit2;
    inflate_2$1 = inflate$2;
    inflateEnd_1 = inflateEnd;
    inflateGetHeader_1 = inflateGetHeader;
    inflateSetDictionary_1 = inflateSetDictionary;
    inflateInfo = "pako inflate (from Nodeca project)";
    inflate_1$2 = {
      inflateReset: inflateReset_1,
      inflateReset2: inflateReset2_1,
      inflateResetKeep: inflateResetKeep_1,
      inflateInit: inflateInit_1,
      inflateInit2: inflateInit2_1,
      inflate: inflate_2$1,
      inflateEnd: inflateEnd_1,
      inflateGetHeader: inflateGetHeader_1,
      inflateSetDictionary: inflateSetDictionary_1,
      inflateInfo
    };
    gzheader = GZheader;
    toString = Object.prototype.toString;
    ({
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = constants$2);
    Inflate$1.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended) return false;
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = inflate_1$2.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = inflate_1$2.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = inflate_1$2.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          inflate_1$2.inflateReset(strm);
          status = inflate_1$2.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0) continue;
        if (status === Z_STREAM_END) {
          status = inflate_1$2.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Inflate$1.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate$1.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = common.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    Inflate_1$1 = Inflate$1;
    inflate_2 = inflate$1;
    inflateRaw_1$1 = inflateRaw$1;
    ungzip$1 = inflate$1;
    constants = constants$2;
    inflate_1$1 = {
      Inflate: Inflate_1$1,
      inflate: inflate_2,
      inflateRaw: inflateRaw_1$1,
      ungzip: ungzip$1,
      constants
    };
    ({ Deflate, deflate, deflateRaw, gzip } = deflate_1$1);
    ({ Inflate, inflate, inflateRaw, ungzip } = inflate_1$1);
    Inflate_1 = Inflate;
    inflate_1 = inflate;
  }
});

// node_modules/fast-png/lib-esm/helpers/crc.js
function updateCrc(currentCrc, data, length) {
  let c2 = currentCrc;
  for (let n = 0; n < length; n++) {
    c2 = crcTable2[(c2 ^ data[n]) & 255] ^ c2 >>> 8;
  }
  return c2;
}
function crc(data, length) {
  return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;
}
function checkCrc(buffer, crcLength, chunkName) {
  const expectedCrc = buffer.readUint32();
  const actualCrc = crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - crcLength - 4, crcLength), crcLength);
  if (actualCrc !== expectedCrc) {
    throw new Error(`CRC mismatch for chunk ${chunkName}. Expected ${expectedCrc}, found ${actualCrc}`);
  }
}
var crcTable2, initialCrc;
var init_crc = __esm({
  "node_modules/fast-png/lib-esm/helpers/crc.js"() {
    "use strict";
    crcTable2 = [];
    for (let n = 0; n < 256; n++) {
      let c2 = n;
      for (let k3 = 0; k3 < 8; k3++) {
        if (c2 & 1) {
          c2 = 3988292384 ^ c2 >>> 1;
        } else {
          c2 = c2 >>> 1;
        }
      }
      crcTable2[n] = c2;
    }
    initialCrc = 4294967295;
  }
});

// node_modules/fast-png/lib-esm/helpers/unfilter.js
function unfilterNone(currentLine, newLine, bytesPerLine) {
  for (let i2 = 0; i2 < bytesPerLine; i2++) {
    newLine[i2] = currentLine[i2];
  }
}
function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {
  let i2 = 0;
  for (; i2 < bytesPerPixel; i2++) {
    newLine[i2] = currentLine[i2];
  }
  for (; i2 < bytesPerLine; i2++) {
    newLine[i2] = currentLine[i2] + newLine[i2 - bytesPerPixel] & 255;
  }
}
function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {
  let i2 = 0;
  if (prevLine.length === 0) {
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2];
    }
  } else {
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2] + prevLine[i2] & 255;
    }
  }
}
function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
  let i2 = 0;
  if (prevLine.length === 0) {
    for (; i2 < bytesPerPixel; i2++) {
      newLine[i2] = currentLine[i2];
    }
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2] + (newLine[i2 - bytesPerPixel] >> 1) & 255;
    }
  } else {
    for (; i2 < bytesPerPixel; i2++) {
      newLine[i2] = currentLine[i2] + (prevLine[i2] >> 1) & 255;
    }
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2] + (newLine[i2 - bytesPerPixel] + prevLine[i2] >> 1) & 255;
    }
  }
}
function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
  let i2 = 0;
  if (prevLine.length === 0) {
    for (; i2 < bytesPerPixel; i2++) {
      newLine[i2] = currentLine[i2];
    }
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2] + newLine[i2 - bytesPerPixel] & 255;
    }
  } else {
    for (; i2 < bytesPerPixel; i2++) {
      newLine[i2] = currentLine[i2] + prevLine[i2] & 255;
    }
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2] + paethPredictor(newLine[i2 - bytesPerPixel], prevLine[i2], prevLine[i2 - bytesPerPixel]) & 255;
    }
  }
}
function paethPredictor(a2, b3, c2) {
  const p2 = a2 + b3 - c2;
  const pa = Math.abs(p2 - a2);
  const pb = Math.abs(p2 - b3);
  const pc = Math.abs(p2 - c2);
  if (pa <= pb && pa <= pc)
    return a2;
  else if (pb <= pc)
    return b3;
  else
    return c2;
}
var init_unfilter = __esm({
  "node_modules/fast-png/lib-esm/helpers/unfilter.js"() {
    "use strict";
  }
});

// node_modules/fast-png/lib-esm/helpers/applyUnfilter.js
function applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel) {
  switch (filterType) {
    case 0:
      unfilterNone(currentLine, newLine, passLineBytes);
      break;
    case 1:
      unfilterSub(currentLine, newLine, passLineBytes, bytesPerPixel);
      break;
    case 2:
      unfilterUp(currentLine, newLine, prevLine, passLineBytes);
      break;
    case 3:
      unfilterAverage(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      break;
    case 4:
      unfilterPaeth(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      break;
    default:
      throw new Error(`Unsupported filter: ${filterType}`);
  }
}
var init_applyUnfilter = __esm({
  "node_modules/fast-png/lib-esm/helpers/applyUnfilter.js"() {
    "use strict";
    init_unfilter();
  }
});

// node_modules/fast-png/lib-esm/helpers/decodeInterlaceAdam7.js
function decodeInterlaceAdam7(params) {
  const { data, width, height, channels, depth } = params;
  const passes = [
    { x: 0, y: 0, xStep: 8, yStep: 8 },
    // Pass 1
    { x: 4, y: 0, xStep: 8, yStep: 8 },
    // Pass 2
    { x: 0, y: 4, xStep: 4, yStep: 8 },
    // Pass 3
    { x: 2, y: 0, xStep: 4, yStep: 4 },
    // Pass 4
    { x: 0, y: 2, xStep: 2, yStep: 4 },
    // Pass 5
    { x: 1, y: 0, xStep: 2, yStep: 2 },
    // Pass 6
    { x: 0, y: 1, xStep: 1, yStep: 2 }
    // Pass 7
  ];
  const bytesPerPixel = Math.ceil(depth / 8) * channels;
  const resultData = new Uint8Array(height * width * bytesPerPixel);
  let offset = 0;
  for (let passIndex = 0; passIndex < 7; passIndex++) {
    const pass = passes[passIndex];
    const passWidth = Math.ceil((width - pass.x) / pass.xStep);
    const passHeight = Math.ceil((height - pass.y) / pass.yStep);
    if (passWidth <= 0 || passHeight <= 0)
      continue;
    const passLineBytes = passWidth * bytesPerPixel;
    const prevLine = new Uint8Array(passLineBytes);
    for (let y3 = 0; y3 < passHeight; y3++) {
      const filterType = data[offset++];
      const currentLine = data.subarray(offset, offset + passLineBytes);
      offset += passLineBytes;
      const newLine = new Uint8Array(passLineBytes);
      applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      prevLine.set(newLine);
      for (let x3 = 0; x3 < passWidth; x3++) {
        const outputX = pass.x + x3 * pass.xStep;
        const outputY = pass.y + y3 * pass.yStep;
        if (outputX >= width || outputY >= height)
          continue;
        for (let i2 = 0; i2 < bytesPerPixel; i2++) {
          resultData[(outputY * width + outputX) * bytesPerPixel + i2] = newLine[x3 * bytesPerPixel + i2];
        }
      }
    }
  }
  if (depth === 16) {
    const uint16Data = new Uint16Array(resultData.buffer);
    if (osIsLittleEndian) {
      for (let k3 = 0; k3 < uint16Data.length; k3++) {
        uint16Data[k3] = swap16(uint16Data[k3]);
      }
    }
    return uint16Data;
  } else {
    return resultData;
  }
}
function swap16(val) {
  return (val & 255) << 8 | val >> 8 & 255;
}
var uint16, uint8, osIsLittleEndian;
var init_decodeInterlaceAdam7 = __esm({
  "node_modules/fast-png/lib-esm/helpers/decodeInterlaceAdam7.js"() {
    "use strict";
    init_applyUnfilter();
    uint16 = new Uint16Array([255]);
    uint8 = new Uint8Array(uint16.buffer);
    osIsLittleEndian = uint8[0] === 255;
  }
});

// node_modules/fast-png/lib-esm/helpers/decodeInterlaceNull.js
function decodeInterlaceNull(params) {
  const { data, width, height, channels, depth } = params;
  const bytesPerPixel = Math.ceil(depth / 8) * channels;
  const bytesPerLine = Math.ceil(depth / 8 * channels * width);
  const newData = new Uint8Array(height * bytesPerLine);
  let prevLine = empty;
  let offset = 0;
  let currentLine;
  let newLine;
  for (let i2 = 0; i2 < height; i2++) {
    currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);
    newLine = newData.subarray(i2 * bytesPerLine, (i2 + 1) * bytesPerLine);
    switch (data[offset]) {
      case 0:
        unfilterNone(currentLine, newLine, bytesPerLine);
        break;
      case 1:
        unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);
        break;
      case 2:
        unfilterUp(currentLine, newLine, prevLine, bytesPerLine);
        break;
      case 3:
        unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
        break;
      case 4:
        unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
        break;
      default:
        throw new Error(`Unsupported filter: ${data[offset]}`);
    }
    prevLine = newLine;
    offset += bytesPerLine + 1;
  }
  if (depth === 16) {
    const uint16Data = new Uint16Array(newData.buffer);
    if (osIsLittleEndian2) {
      for (let k3 = 0; k3 < uint16Data.length; k3++) {
        uint16Data[k3] = swap162(uint16Data[k3]);
      }
    }
    return uint16Data;
  } else {
    return newData;
  }
}
function swap162(val) {
  return (val & 255) << 8 | val >> 8 & 255;
}
var uint162, uint82, osIsLittleEndian2, empty;
var init_decodeInterlaceNull = __esm({
  "node_modules/fast-png/lib-esm/helpers/decodeInterlaceNull.js"() {
    "use strict";
    init_unfilter();
    uint162 = new Uint16Array([255]);
    uint82 = new Uint8Array(uint162.buffer);
    osIsLittleEndian2 = uint82[0] === 255;
    empty = new Uint8Array(0);
  }
});

// node_modules/fast-png/lib-esm/helpers/signature.js
function checkSignature(buffer) {
  if (!hasPngSignature(buffer.readBytes(pngSignature.length))) {
    throw new Error("wrong PNG signature");
  }
}
function hasPngSignature(array) {
  if (array.length < pngSignature.length) {
    return false;
  }
  for (let i2 = 0; i2 < pngSignature.length; i2++) {
    if (array[i2] !== pngSignature[i2]) {
      return false;
    }
  }
  return true;
}
var pngSignature;
var init_signature = __esm({
  "node_modules/fast-png/lib-esm/helpers/signature.js"() {
    "use strict";
    pngSignature = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);
  }
});

// node_modules/fast-png/lib-esm/helpers/text.js
function validateKeyword(keyword) {
  validateLatin1(keyword);
  if (keyword.length === 0 || keyword.length > 79) {
    throw new Error("keyword length must be between 1 and 79");
  }
}
function validateLatin1(text) {
  if (!latin1Regex.test(text)) {
    throw new Error("invalid latin1 text");
  }
}
function decodetEXt(text, buffer, length) {
  const keyword = readKeyword(buffer);
  text[keyword] = readLatin1(buffer, length - keyword.length - 1);
}
function readKeyword(buffer) {
  buffer.mark();
  while (buffer.readByte() !== NULL) {
  }
  const end = buffer.offset;
  buffer.reset();
  const keyword = latin1Decoder.decode(buffer.readBytes(end - buffer.offset - 1));
  buffer.skip(1);
  validateKeyword(keyword);
  return keyword;
}
function readLatin1(buffer, length) {
  return latin1Decoder.decode(buffer.readBytes(length));
}
var textChunkName, NULL, latin1Decoder, latin1Regex;
var init_text2 = __esm({
  "node_modules/fast-png/lib-esm/helpers/text.js"() {
    "use strict";
    init_crc();
    textChunkName = "tEXt";
    NULL = 0;
    latin1Decoder = new TextDecoder("latin1");
    latin1Regex = /^[\u0000-\u00FF]*$/;
  }
});

// node_modules/fast-png/lib-esm/internalTypes.js
var ColorType, CompressionMethod, FilterMethod, InterlaceMethod, DisposeOpType, BlendOpType;
var init_internalTypes = __esm({
  "node_modules/fast-png/lib-esm/internalTypes.js"() {
    "use strict";
    ColorType = {
      UNKNOWN: -1,
      GREYSCALE: 0,
      TRUECOLOUR: 2,
      INDEXED_COLOUR: 3,
      GREYSCALE_ALPHA: 4,
      TRUECOLOUR_ALPHA: 6
    };
    CompressionMethod = {
      UNKNOWN: -1,
      DEFLATE: 0
    };
    FilterMethod = {
      UNKNOWN: -1,
      ADAPTIVE: 0
    };
    InterlaceMethod = {
      UNKNOWN: -1,
      NO_INTERLACE: 0,
      ADAM7: 1
    };
    DisposeOpType = {
      NONE: 0,
      BACKGROUND: 1,
      PREVIOUS: 2
    };
    BlendOpType = {
      SOURCE: 0,
      OVER: 1
    };
  }
});

// node_modules/fast-png/lib-esm/PngDecoder.js
function checkBitDepth(value) {
  if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {
    throw new Error(`invalid bit depth: ${value}`);
  }
  return value;
}
var PngDecoder;
var init_PngDecoder = __esm({
  "node_modules/fast-png/lib-esm/PngDecoder.js"() {
    "use strict";
    init_IOBuffer();
    init_pako_esm();
    init_crc();
    init_decodeInterlaceAdam7();
    init_decodeInterlaceNull();
    init_signature();
    init_text2();
    init_internalTypes();
    PngDecoder = class extends IOBuffer {
      _checkCrc;
      _inflator;
      _png;
      _apng;
      _end;
      _hasPalette;
      _palette;
      _hasTransparency;
      _transparency;
      _compressionMethod;
      _filterMethod;
      _interlaceMethod;
      _colorType;
      _isAnimated;
      _numberOfFrames;
      _numberOfPlays;
      _frames;
      _writingDataChunks;
      constructor(data, options = {}) {
        super(data);
        const { checkCrc: checkCrc2 = false } = options;
        this._checkCrc = checkCrc2;
        this._inflator = new Inflate_1();
        this._png = {
          width: -1,
          height: -1,
          channels: -1,
          data: new Uint8Array(0),
          depth: 1,
          text: {}
        };
        this._apng = {
          width: -1,
          height: -1,
          channels: -1,
          depth: 1,
          numberOfFrames: 1,
          numberOfPlays: 0,
          text: {},
          frames: []
        };
        this._end = false;
        this._hasPalette = false;
        this._palette = [];
        this._hasTransparency = false;
        this._transparency = new Uint16Array(0);
        this._compressionMethod = CompressionMethod.UNKNOWN;
        this._filterMethod = FilterMethod.UNKNOWN;
        this._interlaceMethod = InterlaceMethod.UNKNOWN;
        this._colorType = ColorType.UNKNOWN;
        this._isAnimated = false;
        this._numberOfFrames = 1;
        this._numberOfPlays = 0;
        this._frames = [];
        this._writingDataChunks = false;
        this.setBigEndian();
      }
      decode() {
        checkSignature(this);
        while (!this._end) {
          const length = this.readUint32();
          const type = this.readChars(4);
          this.decodeChunk(length, type);
        }
        this.decodeImage();
        return this._png;
      }
      decodeApng() {
        checkSignature(this);
        while (!this._end) {
          const length = this.readUint32();
          const type = this.readChars(4);
          this.decodeApngChunk(length, type);
        }
        this.decodeApngImage();
        return this._apng;
      }
      // https://www.w3.org/TR/PNG/#5Chunk-layout
      decodeChunk(length, type) {
        const offset = this.offset;
        switch (type) {
          // 11.2 Critical chunks
          case "IHDR":
            this.decodeIHDR();
            break;
          case "PLTE":
            this.decodePLTE(length);
            break;
          case "IDAT":
            this.decodeIDAT(length);
            break;
          case "IEND":
            this._end = true;
            break;
          // 11.3 Ancillary chunks
          case "tRNS":
            this.decodetRNS(length);
            break;
          case "iCCP":
            this.decodeiCCP(length);
            break;
          case textChunkName:
            decodetEXt(this._png.text, this, length);
            break;
          case "pHYs":
            this.decodepHYs();
            break;
          default:
            this.skip(length);
            break;
        }
        if (this.offset - offset !== length) {
          throw new Error(`Length mismatch while decoding chunk ${type}`);
        }
        if (this._checkCrc) {
          checkCrc(this, length + 4, type);
        } else {
          this.skip(4);
        }
      }
      decodeApngChunk(length, type) {
        const offset = this.offset;
        if (type !== "fdAT" && type !== "IDAT" && this._writingDataChunks) {
          this.pushDataToFrame();
        }
        switch (type) {
          case "acTL":
            this.decodeACTL();
            break;
          case "fcTL":
            this.decodeFCTL();
            break;
          case "fdAT":
            this.decodeFDAT(length);
            break;
          default:
            this.decodeChunk(length, type);
            this.offset = offset + length;
            break;
        }
        if (this.offset - offset !== length) {
          throw new Error(`Length mismatch while decoding chunk ${type}`);
        }
        if (this._checkCrc) {
          checkCrc(this, length + 4, type);
        } else {
          this.skip(4);
        }
      }
      // https://www.w3.org/TR/PNG/#11IHDR
      decodeIHDR() {
        const image = this._png;
        image.width = this.readUint32();
        image.height = this.readUint32();
        image.depth = checkBitDepth(this.readUint8());
        const colorType = this.readUint8();
        this._colorType = colorType;
        let channels;
        switch (colorType) {
          case ColorType.GREYSCALE:
            channels = 1;
            break;
          case ColorType.TRUECOLOUR:
            channels = 3;
            break;
          case ColorType.INDEXED_COLOUR:
            channels = 1;
            break;
          case ColorType.GREYSCALE_ALPHA:
            channels = 2;
            break;
          case ColorType.TRUECOLOUR_ALPHA:
            channels = 4;
            break;
          // Kept for exhaustiveness.
          // eslint-disable-next-line unicorn/no-useless-switch-case
          case ColorType.UNKNOWN:
          default:
            throw new Error(`Unknown color type: ${colorType}`);
        }
        this._png.channels = channels;
        this._compressionMethod = this.readUint8();
        if (this._compressionMethod !== CompressionMethod.DEFLATE) {
          throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
        }
        this._filterMethod = this.readUint8();
        this._interlaceMethod = this.readUint8();
      }
      decodeACTL() {
        this._numberOfFrames = this.readUint32();
        this._numberOfPlays = this.readUint32();
        this._isAnimated = true;
      }
      decodeFCTL() {
        const image = {
          sequenceNumber: this.readUint32(),
          width: this.readUint32(),
          height: this.readUint32(),
          xOffset: this.readUint32(),
          yOffset: this.readUint32(),
          delayNumber: this.readUint16(),
          delayDenominator: this.readUint16(),
          disposeOp: this.readUint8(),
          blendOp: this.readUint8(),
          data: new Uint8Array(0)
        };
        this._frames.push(image);
      }
      // https://www.w3.org/TR/PNG/#11PLTE
      decodePLTE(length) {
        if (length % 3 !== 0) {
          throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);
        }
        const l4 = length / 3;
        this._hasPalette = true;
        const palette = [];
        this._palette = palette;
        for (let i2 = 0; i2 < l4; i2++) {
          palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);
        }
      }
      // https://www.w3.org/TR/PNG/#11IDAT
      decodeIDAT(length) {
        this._writingDataChunks = true;
        const dataLength = length;
        const dataOffset = this.offset + this.byteOffset;
        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
        if (this._inflator.err) {
          throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        }
        this.skip(length);
      }
      decodeFDAT(length) {
        this._writingDataChunks = true;
        let dataLength = length;
        let dataOffset = this.offset + this.byteOffset;
        dataOffset += 4;
        dataLength -= 4;
        this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
        if (this._inflator.err) {
          throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        }
        this.skip(length);
      }
      // https://www.w3.org/TR/PNG/#11tRNS
      decodetRNS(length) {
        switch (this._colorType) {
          case ColorType.GREYSCALE:
          case ColorType.TRUECOLOUR: {
            if (length % 2 !== 0) {
              throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);
            }
            if (length / 2 > this._png.width * this._png.height) {
              throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);
            }
            this._hasTransparency = true;
            this._transparency = new Uint16Array(length / 2);
            for (let i2 = 0; i2 < length / 2; i2++) {
              this._transparency[i2] = this.readUint16();
            }
            break;
          }
          case ColorType.INDEXED_COLOUR: {
            if (length > this._palette.length) {
              throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);
            }
            let i2 = 0;
            for (; i2 < length; i2++) {
              const alpha = this.readByte();
              this._palette[i2].push(alpha);
            }
            for (; i2 < this._palette.length; i2++) {
              this._palette[i2].push(255);
            }
            break;
          }
          // Kept for exhaustiveness.
          /* eslint-disable unicorn/no-useless-switch-case */
          case ColorType.UNKNOWN:
          case ColorType.GREYSCALE_ALPHA:
          case ColorType.TRUECOLOUR_ALPHA:
          default: {
            throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
          }
        }
      }
      // https://www.w3.org/TR/PNG/#11iCCP
      decodeiCCP(length) {
        const name = readKeyword(this);
        const compressionMethod = this.readUint8();
        if (compressionMethod !== CompressionMethod.DEFLATE) {
          throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);
        }
        const compressedProfile = this.readBytes(length - name.length - 2);
        this._png.iccEmbeddedProfile = {
          name,
          profile: inflate_1(compressedProfile)
        };
      }
      // https://www.w3.org/TR/PNG/#11pHYs
      decodepHYs() {
        const ppuX = this.readUint32();
        const ppuY = this.readUint32();
        const unitSpecifier = this.readByte();
        this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };
      }
      decodeApngImage() {
        this._apng.width = this._png.width;
        this._apng.height = this._png.height;
        this._apng.channels = this._png.channels;
        this._apng.depth = this._png.depth;
        this._apng.numberOfFrames = this._numberOfFrames;
        this._apng.numberOfPlays = this._numberOfPlays;
        this._apng.text = this._png.text;
        this._apng.resolution = this._png.resolution;
        for (let i2 = 0; i2 < this._numberOfFrames; i2++) {
          const newFrame = {
            sequenceNumber: this._frames[i2].sequenceNumber,
            delayNumber: this._frames[i2].delayNumber,
            delayDenominator: this._frames[i2].delayDenominator,
            data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels)
          };
          const frame = this._frames.at(i2);
          if (frame) {
            frame.data = decodeInterlaceNull({
              data: frame.data,
              width: frame.width,
              height: frame.height,
              channels: this._apng.channels,
              depth: this._apng.depth
            });
            if (this._hasPalette) {
              this._apng.palette = this._palette;
            }
            if (this._hasTransparency) {
              this._apng.transparency = this._transparency;
            }
            if (i2 === 0 || frame.xOffset === 0 && frame.yOffset === 0 && frame.width === this._png.width && frame.height === this._png.height) {
              newFrame.data = frame.data;
            } else {
              const prevFrame = this._apng.frames.at(i2 - 1);
              this.disposeFrame(frame, prevFrame, newFrame);
              this.addFrameDataToCanvas(newFrame, frame);
            }
            this._apng.frames.push(newFrame);
          }
        }
        return this._apng;
      }
      disposeFrame(frame, prevFrame, imageFrame) {
        switch (frame.disposeOp) {
          case DisposeOpType.NONE:
            break;
          case DisposeOpType.BACKGROUND:
            for (let row = 0; row < this._png.height; row++) {
              for (let col = 0; col < this._png.width; col++) {
                const index = (row * frame.width + col) * this._png.channels;
                for (let channel = 0; channel < this._png.channels; channel++) {
                  imageFrame.data[index + channel] = 0;
                }
              }
            }
            break;
          case DisposeOpType.PREVIOUS:
            imageFrame.data.set(prevFrame.data);
            break;
          default:
            throw new Error("Unknown disposeOp");
        }
      }
      addFrameDataToCanvas(imageFrame, frame) {
        const maxValue = 1 << this._png.depth;
        const calculatePixelIndices = (row, col) => {
          const index = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) * this._png.channels;
          const frameIndex = (row * frame.width + col) * this._png.channels;
          return { index, frameIndex };
        };
        switch (frame.blendOp) {
          case BlendOpType.SOURCE:
            for (let row = 0; row < frame.height; row++) {
              for (let col = 0; col < frame.width; col++) {
                const { index, frameIndex } = calculatePixelIndices(row, col);
                for (let channel = 0; channel < this._png.channels; channel++) {
                  imageFrame.data[index + channel] = frame.data[frameIndex + channel];
                }
              }
            }
            break;
          // https://www.w3.org/TR/png-3/#13Alpha-channel-processing
          case BlendOpType.OVER:
            for (let row = 0; row < frame.height; row++) {
              for (let col = 0; col < frame.width; col++) {
                const { index, frameIndex } = calculatePixelIndices(row, col);
                for (let channel = 0; channel < this._png.channels; channel++) {
                  const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;
                  const foregroundValue = channel % (this._png.channels - 1) === 0 ? 1 : frame.data[frameIndex + channel];
                  const value = Math.floor(sourceAlpha * foregroundValue + (1 - sourceAlpha) * imageFrame.data[index + channel]);
                  imageFrame.data[index + channel] += value;
                }
              }
            }
            break;
          default:
            throw new Error("Unknown blendOp");
        }
      }
      decodeImage() {
        if (this._inflator.err) {
          throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        }
        const data = this._isAnimated ? (this._frames?.at(0)).data : this._inflator.result;
        if (this._filterMethod !== FilterMethod.ADAPTIVE) {
          throw new Error(`Filter method ${this._filterMethod} not supported`);
        }
        if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {
          this._png.data = decodeInterlaceNull({
            data,
            width: this._png.width,
            height: this._png.height,
            channels: this._png.channels,
            depth: this._png.depth
          });
        } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {
          this._png.data = decodeInterlaceAdam7({
            data,
            width: this._png.width,
            height: this._png.height,
            channels: this._png.channels,
            depth: this._png.depth
          });
        } else {
          throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
        }
        if (this._hasPalette) {
          this._png.palette = this._palette;
        }
        if (this._hasTransparency) {
          this._png.transparency = this._transparency;
        }
      }
      pushDataToFrame() {
        const result = this._inflator.result;
        const lastFrame = this._frames.at(-1);
        if (lastFrame) {
          lastFrame.data = result;
        } else {
          this._frames.push({
            sequenceNumber: 0,
            width: this._png.width,
            height: this._png.height,
            xOffset: 0,
            yOffset: 0,
            delayNumber: 0,
            delayDenominator: 0,
            disposeOp: DisposeOpType.NONE,
            blendOp: BlendOpType.SOURCE,
            data: result
          });
        }
        this._inflator = new Inflate_1();
        this._writingDataChunks = false;
      }
    };
  }
});

// node_modules/fast-png/lib-esm/PngEncoder.js
var init_PngEncoder = __esm({
  "node_modules/fast-png/lib-esm/PngEncoder.js"() {
    "use strict";
    init_IOBuffer();
    init_pako_esm();
    init_crc();
    init_signature();
    init_text2();
    init_internalTypes();
  }
});

// node_modules/fast-png/lib-esm/types.js
var ResolutionUnitSpecifier;
var init_types = __esm({
  "node_modules/fast-png/lib-esm/types.js"() {
    "use strict";
    (function(ResolutionUnitSpecifier2) {
      ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["UNKNOWN"] = 0] = "UNKNOWN";
      ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["METRE"] = 1] = "METRE";
    })(ResolutionUnitSpecifier || (ResolutionUnitSpecifier = {}));
  }
});

// node_modules/fast-png/lib-esm/convertIndexedToRgb.js
var init_convertIndexedToRgb = __esm({
  "node_modules/fast-png/lib-esm/convertIndexedToRgb.js"() {
    "use strict";
  }
});

// node_modules/fast-png/lib-esm/index.js
function decodePng(data, options) {
  const decoder = new PngDecoder(data, options);
  return decoder.decode();
}
var init_lib_esm = __esm({
  "node_modules/fast-png/lib-esm/index.js"() {
    "use strict";
    init_PngDecoder();
    init_PngEncoder();
    init_signature();
    init_types();
    init_convertIndexedToRgb();
  }
});

// node_modules/jspdf/dist/jspdf.es.min.js
function a() {
  i.console && "function" == typeof i.console.log && i.console.log.apply(i.console, arguments);
}
function s(t2, e, n) {
  var r = new XMLHttpRequest();
  r.open("GET", t2), r.responseType = "blob", r.onload = function() {
    l3(r.response, e, n);
  }, r.onerror = function() {
    o.error("could not download file");
  }, r.send();
}
function u(t2) {
  var e = new XMLHttpRequest();
  e.open("HEAD", t2, false);
  try {
    e.send();
  } catch (n) {
  }
  return e.status >= 200 && e.status <= 299;
}
function c(t2) {
  try {
    t2.dispatchEvent(new MouseEvent("click"));
  } catch (n) {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t2.dispatchEvent(e);
  }
}
function h(t2) {
  var e;
  t2 = t2 || "", this.ok = false, "#" == t2.charAt(0) && (t2 = t2.substr(1, 6)), t2 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t2 = (t2 = t2.replace(/ /g, "")).toLowerCase()] || t2;
  for (var n = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t3) {
    return [parseInt(t3[1]), parseInt(t3[2]), parseInt(t3[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t3) {
    return [parseInt(t3[1], 16), parseInt(t3[2], 16), parseInt(t3[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t3) {
    return [parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16)];
  } }], r = 0; r < n.length; r++) {
    var i2 = n[r].re, a2 = n[r].process, o2 = i2.exec(t2);
    o2 && (e = a2(o2), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t3 = this.r.toString(16), e2 = this.g.toString(16), n2 = this.b.toString(16);
    return 1 == t3.length && (t3 = "0" + t3), 1 == e2.length && (e2 = "0" + e2), 1 == n2.length && (n2 = "0" + n2), "#" + t3 + e2 + n2;
  };
}
function p(t2, e) {
  var n = t2[0], r = t2[1], i2 = t2[2], a2 = t2[3];
  n = m2(n, r, i2, a2, e[0], 7, -680876936), a2 = m2(a2, n, r, i2, e[1], 12, -389564586), i2 = m2(i2, a2, n, r, e[2], 17, 606105819), r = m2(r, i2, a2, n, e[3], 22, -1044525330), n = m2(n, r, i2, a2, e[4], 7, -176418897), a2 = m2(a2, n, r, i2, e[5], 12, 1200080426), i2 = m2(i2, a2, n, r, e[6], 17, -1473231341), r = m2(r, i2, a2, n, e[7], 22, -45705983), n = m2(n, r, i2, a2, e[8], 7, 1770035416), a2 = m2(a2, n, r, i2, e[9], 12, -1958414417), i2 = m2(i2, a2, n, r, e[10], 17, -42063), r = m2(r, i2, a2, n, e[11], 22, -1990404162), n = m2(n, r, i2, a2, e[12], 7, 1804603682), a2 = m2(a2, n, r, i2, e[13], 12, -40341101), i2 = m2(i2, a2, n, r, e[14], 17, -1502002290), n = v2(n, r = m2(r, i2, a2, n, e[15], 22, 1236535329), i2, a2, e[1], 5, -165796510), a2 = v2(a2, n, r, i2, e[6], 9, -1069501632), i2 = v2(i2, a2, n, r, e[11], 14, 643717713), r = v2(r, i2, a2, n, e[0], 20, -373897302), n = v2(n, r, i2, a2, e[5], 5, -701558691), a2 = v2(a2, n, r, i2, e[10], 9, 38016083), i2 = v2(i2, a2, n, r, e[15], 14, -660478335), r = v2(r, i2, a2, n, e[4], 20, -405537848), n = v2(n, r, i2, a2, e[9], 5, 568446438), a2 = v2(a2, n, r, i2, e[14], 9, -1019803690), i2 = v2(i2, a2, n, r, e[3], 14, -187363961), r = v2(r, i2, a2, n, e[8], 20, 1163531501), n = v2(n, r, i2, a2, e[13], 5, -1444681467), a2 = v2(a2, n, r, i2, e[2], 9, -51403784), i2 = v2(i2, a2, n, r, e[7], 14, 1735328473), n = b2(n, r = v2(r, i2, a2, n, e[12], 20, -1926607734), i2, a2, e[5], 4, -378558), a2 = b2(a2, n, r, i2, e[8], 11, -2022574463), i2 = b2(i2, a2, n, r, e[11], 16, 1839030562), r = b2(r, i2, a2, n, e[14], 23, -35309556), n = b2(n, r, i2, a2, e[1], 4, -1530992060), a2 = b2(a2, n, r, i2, e[4], 11, 1272893353), i2 = b2(i2, a2, n, r, e[7], 16, -155497632), r = b2(r, i2, a2, n, e[10], 23, -1094730640), n = b2(n, r, i2, a2, e[13], 4, 681279174), a2 = b2(a2, n, r, i2, e[0], 11, -358537222), i2 = b2(i2, a2, n, r, e[3], 16, -722521979), r = b2(r, i2, a2, n, e[6], 23, 76029189), n = b2(n, r, i2, a2, e[9], 4, -640364487), a2 = b2(a2, n, r, i2, e[12], 11, -421815835), i2 = b2(i2, a2, n, r, e[15], 16, 530742520), n = y2(n, r = b2(r, i2, a2, n, e[2], 23, -995338651), i2, a2, e[0], 6, -198630844), a2 = y2(a2, n, r, i2, e[7], 10, 1126891415), i2 = y2(i2, a2, n, r, e[14], 15, -1416354905), r = y2(r, i2, a2, n, e[5], 21, -57434055), n = y2(n, r, i2, a2, e[12], 6, 1700485571), a2 = y2(a2, n, r, i2, e[3], 10, -1894986606), i2 = y2(i2, a2, n, r, e[10], 15, -1051523), r = y2(r, i2, a2, n, e[1], 21, -2054922799), n = y2(n, r, i2, a2, e[8], 6, 1873313359), a2 = y2(a2, n, r, i2, e[15], 10, -30611744), i2 = y2(i2, a2, n, r, e[6], 15, -1560198380), r = y2(r, i2, a2, n, e[13], 21, 1309151649), n = y2(n, r, i2, a2, e[4], 6, -145523070), a2 = y2(a2, n, r, i2, e[11], 10, -1120210379), i2 = y2(i2, a2, n, r, e[2], 15, 718787259), r = y2(r, i2, a2, n, e[9], 21, -343485551), t2[0] = P3(n, t2[0]), t2[1] = P3(r, t2[1]), t2[2] = P3(i2, t2[2]), t2[3] = P3(a2, t2[3]);
}
function g(t2, e, n, r, i2, a2) {
  return e = P3(P3(e, t2), P3(r, a2)), P3(e << i2 | e >>> 32 - i2, n);
}
function m2(t2, e, n, r, i2, a2, o2) {
  return g(e & n | ~e & r, t2, e, i2, a2, o2);
}
function v2(t2, e, n, r, i2, a2, o2) {
  return g(e & r | n & ~r, t2, e, i2, a2, o2);
}
function b2(t2, e, n, r, i2, a2, o2) {
  return g(e ^ n ^ r, t2, e, i2, a2, o2);
}
function y2(t2, e, n, r, i2, a2, o2) {
  return g(n ^ (e | ~r), t2, e, i2, a2, o2);
}
function w2(t2) {
  var e, n = t2.length, r = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= t2.length; e += 64) p(r, N3(t2.substring(e - 64, e)));
  t2 = t2.substring(e - 64);
  var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < t2.length; e++) i2[e >> 2] |= t2.charCodeAt(e) << (e % 4 << 3);
  if (i2[e >> 2] |= 128 << (e % 4 << 3), e > 55) for (p(r, i2), e = 0; e < 16; e++) i2[e] = 0;
  return i2[14] = 8 * n, p(r, i2), r;
}
function N3(t2) {
  var e, n = [];
  for (e = 0; e < 64; e += 4) n[e >> 2] = t2.charCodeAt(e) + (t2.charCodeAt(e + 1) << 8) + (t2.charCodeAt(e + 2) << 16) + (t2.charCodeAt(e + 3) << 24);
  return n;
}
function x2(t2) {
  for (var e = "", n = 0; n < 4; n++) e += L3[t2 >> 8 * n + 4 & 15] + L3[t2 >> 8 * n & 15];
  return e;
}
function A2(t2) {
  return String.fromCharCode(255 & t2, (65280 & t2) >> 8, (16711680 & t2) >> 16, (4278190080 & t2) >> 24);
}
function S3(t2) {
  return w2(t2).map(A2).join("");
}
function P3(t2, e) {
  if (_2) {
    var n = (65535 & t2) + (65535 & e);
    return (t2 >> 16) + (e >> 16) + (n >> 16) << 16 | 65535 & n;
  }
  return t2 + e & 4294967295;
}
function k2(t2, e) {
  var n, r, i2, a2;
  if (t2 !== n) {
    for (var o2 = (i2 = t2, a2 = 1 + (256 / t2.length | 0), new Array(a2 + 1).join(i2)), s2 = [], u2 = 0; u2 < 256; u2++) s2[u2] = u2;
    var c2 = 0;
    for (u2 = 0; u2 < 256; u2++) {
      var l4 = s2[u2];
      c2 = (c2 + l4 + o2.charCodeAt(u2)) % 256, s2[u2] = s2[c2], s2[c2] = l4;
    }
    n = t2, r = s2;
  } else s2 = r;
  var h2 = e.length, f2 = 0, d3 = 0, p2 = "";
  for (u2 = 0; u2 < h2; u2++) d3 = (d3 + (l4 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d3], s2[d3] = l4, o2 = s2[(s2[f2] + s2[d3]) % 256], p2 += String.fromCharCode(e.charCodeAt(u2) ^ o2);
  return p2;
}
function I3(t2, e, n, r) {
  this.v = 1, this.r = 2;
  var i2 = 192;
  t2.forEach(function(t3) {
    if (void 0 !== F13.perm) throw new Error("Invalid permission: " + t3);
    i2 += F13[t3];
  }), this.padding = "(\xBFN^Nu\x8AAd\0NV\xFF\xFA\b..\0\xB6\xD0h>\x80/\f\xA9\xFEdSiz";
  var a2 = (e + this.padding).substr(0, 32), o2 = (n + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = S3(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(r)).substr(0, 5), this.U = k2(this.encryptionKey, this.padding);
}
function j2(t2) {
  if (/[^\u0000-\u00ff]/.test(t2)) throw new Error("Invalid PDF Name Object: " + t2 + ", Only accept ASCII characters.");
  for (var e = "", n = t2.length, r = 0; r < n; r++) {
    var i2 = t2.charCodeAt(r);
    e += i2 < 33 || 35 === i2 || 37 === i2 || 40 === i2 || 41 === i2 || 47 === i2 || 60 === i2 || 62 === i2 || 91 === i2 || 93 === i2 || 123 === i2 || 125 === i2 || i2 > 126 ? "#" + ("0" + i2.toString(16)).slice(-2) : t2[r];
  }
  return e;
}
function C3(e) {
  if ("object" !== _typeof(e)) throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var n = {};
  this.subscribe = function(t2, e2, r) {
    if (r = r || false, "string" != typeof t2 || "function" != typeof e2 || "boolean" != typeof r) throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    n.hasOwnProperty(t2) || (n[t2] = {});
    var i2 = Math.random().toString(35);
    return n[t2][i2] = [e2, !!r], i2;
  }, this.unsubscribe = function(t2) {
    for (var e2 in n) if (n[e2][t2]) return delete n[e2][t2], 0 === Object.keys(n[e2]).length && delete n[e2], true;
    return false;
  }, this.publish = function(t2) {
    if (n.hasOwnProperty(t2)) {
      var r = Array.prototype.slice.call(arguments, 1), a2 = [];
      for (var s2 in n[t2]) {
        var u2 = n[t2][s2];
        try {
          u2[0].apply(e, r);
        } catch (c2) {
          i.console && o.error("jsPDF PubSub Error", c2.message, c2);
        }
        u2[1] && a2.push(s2);
      }
      a2.length && a2.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return n;
  };
}
function O2(t2) {
  if (!(this instanceof O2)) return new O2(t2);
  var e = "opacity,stroke-opacity".split(",");
  for (var n in t2) t2.hasOwnProperty(n) && e.indexOf(n) >= 0 && (this[n] = t2[n]);
  this.id = "", this.objectNumber = -1;
}
function B3(t2, e) {
  this.gState = t2, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function M3(t2, e, n, r, i2) {
  if (!(this instanceof M3)) return new M3(t2, e, n, r, i2);
  this.type = "axial" === t2 ? 2 : 3, this.coords = e, this.colors = n, B3.call(this, r, i2);
}
function q2(t2, e, n, r, i2) {
  if (!(this instanceof q2)) return new q2(t2, e, n, r, i2);
  this.boundingBox = t2, this.xStep = e, this.yStep = n, this.stream = "", this.cloneIndex = 0, B3.call(this, r, i2);
}
function E3(e) {
  var n, r = "string" == typeof arguments[0] ? arguments[0] : "p", a2 = arguments[1], s2 = arguments[2], u2 = arguments[3], c2 = [], f2 = 1, p2 = 16, g2 = "S", m3 = null;
  "object" === _typeof(e = e || {}) && (r = e.orientation, a2 = e.unit || a2, s2 = e.format || s2, u2 = e.compress || e.compressPdf || u2, null !== (m3 = e.encryption || null) && (m3.userPassword = m3.userPassword || "", m3.ownerPassword = m3.ownerPassword || "", m3.userPermissions = m3.userPermissions || []), f2 = "number" == typeof e.userUnit ? Math.abs(e.userUnit) : 1, void 0 !== e.precision && (n = e.precision), void 0 !== e.floatPrecision && (p2 = e.floatPrecision), g2 = e.defaultPathOperation || "S"), c2 = e.filters || (true === u2 ? ["FlateEncode"] : c2), a2 = a2 || "mm", r = ("" + (r || "P")).toLowerCase();
  var v3 = e.putOnlyUsedFonts || false, b3 = {}, y3 = { internal: {}, __private__: {} };
  y3.__private__.PubSub = C3;
  var w3 = "1.3", N4 = y3.__private__.getPdfVersion = function() {
    return w3;
  };
  y3.__private__.setPdfVersion = function(t2) {
    w3 = t2;
  };
  var L4 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y3.__private__.getPageFormats = function() {
    return L4;
  };
  var x3 = y3.__private__.getPageFormat = function(t2) {
    return L4[t2];
  };
  s2 = s2 || "a4";
  var A3 = "compat", S4 = "advanced", _3 = A3;
  function P4() {
    this.saveGraphicsState(), lt2(new Wt2(St2, 0, 0, -St2, 0, _n() * St2).toString() + " cm"), this.setFontSize(this.getFontSize() / St2), g2 = "n", _3 = S4;
  }
  function k3() {
    this.restoreGraphicsState(), g2 = "S", _3 = A3;
  }
  var F14 = y3.__private__.combineFontStyleAndFontWeight = function(t2, e2) {
    if ("bold" == t2 && "normal" == e2 || "bold" == t2 && 400 == e2 || "normal" == t2 && "italic" == e2 || "bold" == t2 && "italic" == e2) throw new Error("Invalid Combination of fontweight and fontstyle");
    return e2 && (t2 = 400 == e2 || "normal" === e2 ? "italic" === t2 ? "italic" : "normal" : 700 != e2 && "bold" !== e2 || "normal" !== t2 ? (700 == e2 ? "bold" : e2) + "" + t2 : "bold"), t2;
  };
  y3.advancedAPI = function(t2) {
    var e2 = _3 === A3;
    return e2 && P4.call(this), "function" != typeof t2 || (t2(this), e2 && k3.call(this)), this;
  }, y3.compatAPI = function(t2) {
    var e2 = _3 === S4;
    return e2 && k3.call(this), "function" != typeof t2 || (t2(this), e2 && P4.call(this)), this;
  }, y3.isAdvancedAPI = function() {
    return _3 === S4;
  };
  var B4, R3 = function(t2) {
    if (_3 !== S4) throw new Error(t2 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D4 = y3.roundToPrecision = y3.__private__.roundToPrecision = function(t2, e2) {
    var r2 = n || e2;
    if (isNaN(t2) || isNaN(r2)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t2.toFixed(r2).replace(/0+$/, "");
  };
  B4 = y3.hpf = y3.__private__.hpf = "number" == typeof p2 ? function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D4(t2, p2);
  } : "smart" === p2 ? function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D4(t2, t2 > -1 && t2 < 1 ? 16 : 5);
  } : function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D4(t2, 16);
  };
  var T4 = y3.f2 = y3.__private__.f2 = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.f2");
    return D4(t2, 2);
  }, z3 = y3.__private__.f3 = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.f3");
    return D4(t2, 3);
  }, U4 = y3.scale = y3.__private__.scale = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.scale");
    return _3 === A3 ? t2 * St2 : _3 === S4 ? t2 : void 0;
  }, H3 = function(t2) {
    return U4((function(t3) {
      return _3 === A3 ? _n() - t3 : _3 === S4 ? t3 : void 0;
    })(t2));
  };
  y3.__private__.setPrecision = y3.setPrecision = function(t2) {
    "number" == typeof parseInt(t2, 10) && (n = parseInt(t2, 10));
  };
  var W4, V4 = "00000000000000000000000000000000", G4 = y3.__private__.getFileId = function() {
    return V4;
  }, Y3 = y3.__private__.setFileId = function(t2) {
    return V4 = void 0 !== t2 && /^[a-fA-F0-9]{32}$/.test(t2) ? t2.toUpperCase() : V4.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), null !== m3 && (je3 = new I3(m3.userPermissions, m3.userPassword, m3.ownerPassword, V4)), V4;
  };
  y3.setFileId = function(t2) {
    return Y3(t2), this;
  }, y3.getFileId = function() {
    return G4();
  };
  var J4 = y3.__private__.convertDateToPDFDate = function(t2) {
    var e2 = t2.getTimezoneOffset(), n2 = e2 < 0 ? "+" : "-", r2 = Math.floor(Math.abs(e2 / 60)), i2 = Math.abs(e2 % 60), a3 = [n2, Q4(r2), "'", Q4(i2), "'"].join("");
    return ["D:", t2.getFullYear(), Q4(t2.getMonth() + 1), Q4(t2.getDate()), Q4(t2.getHours()), Q4(t2.getMinutes()), Q4(t2.getSeconds()), a3].join("");
  }, X4 = y3.__private__.convertPDFDateToDate = function(t2) {
    var e2 = parseInt(t2.substr(2, 4), 10), n2 = parseInt(t2.substr(6, 2), 10) - 1, r2 = parseInt(t2.substr(8, 2), 10), i2 = parseInt(t2.substr(10, 2), 10), a3 = parseInt(t2.substr(12, 2), 10), o2 = parseInt(t2.substr(14, 2), 10);
    return new Date(e2, n2, r2, i2, a3, o2, 0);
  }, K4 = y3.__private__.setCreationDate = function(t2) {
    var e2;
    if (void 0 === t2 && (t2 = /* @__PURE__ */ new Date()), t2 instanceof Date) e2 = J4(t2);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t2)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e2 = t2;
    }
    return W4 = e2;
  }, Z3 = y3.__private__.getCreationDate = function(t2) {
    var e2 = W4;
    return "jsDate" === t2 && (e2 = X4(W4)), e2;
  };
  y3.setCreationDate = function(t2) {
    return K4(t2), this;
  }, y3.getCreationDate = function(t2) {
    return Z3(t2);
  };
  var $3, Q4 = y3.__private__.padd2 = function(t2) {
    return ("0" + parseInt(t2)).slice(-2);
  }, tt2 = y3.__private__.padd2Hex = function(t2) {
    return ("00" + (t2 = t2.toString())).substr(t2.length);
  }, et3 = 0, nt2 = [], rt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ut2 = rt2;
  y3.__private__.setCustomOutputDestination = function(t2) {
    st2 = true, ut2 = t2;
  };
  var ct2 = function(t2) {
    st2 || (ut2 = t2);
  };
  y3.__private__.resetCustomOutputDestination = function() {
    st2 = false, ut2 = rt2;
  };
  var lt2 = y3.__private__.out = function(t2) {
    return t2 = t2.toString(), it2 += t2.length + 1, ut2.push(t2), ut2;
  }, ht2 = y3.__private__.write = function(t2) {
    return lt2(1 === arguments.length ? t2.toString() : Array.prototype.join.call(arguments, " "));
  }, ft2 = y3.__private__.getArrayBuffer = function(t2) {
    for (var e2 = t2.length, n2 = new ArrayBuffer(e2), r2 = new Uint8Array(n2); e2--; ) r2[e2] = t2.charCodeAt(e2);
    return n2;
  }, dt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y3.__private__.getStandardFonts = function() {
    return dt2;
  };
  var pt2 = e.fontSize || 16;
  y3.__private__.setFontSize = y3.setFontSize = function(t2) {
    return pt2 = _3 === S4 ? t2 / St2 : t2, this;
  };
  var gt2, mt2 = y3.__private__.getFontSize = y3.getFontSize = function() {
    return _3 === A3 ? pt2 : pt2 * St2;
  }, vt2 = e.R2L || false;
  y3.__private__.setR2L = y3.setR2L = function(t2) {
    return vt2 = t2, this;
  }, y3.__private__.getR2L = y3.getR2L = function() {
    return vt2;
  };
  var bt2, yt2 = y3.__private__.setZoomMode = function(t2) {
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t2)) gt2 = t2;
    else if (isNaN(t2)) {
      if (-1 === [void 0, null, "fullwidth", "fullheight", "fullpage", "original"].indexOf(t2)) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t2 + '" is not recognized.');
      gt2 = t2;
    } else gt2 = parseInt(t2, 10);
  };
  y3.__private__.getZoomMode = function() {
    return gt2;
  };
  var wt2, Nt3 = y3.__private__.setPageMode = function(t2) {
    if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t2)) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t2 + '" is not recognized.');
    bt2 = t2;
  };
  y3.__private__.getPageMode = function() {
    return bt2;
  };
  var Lt2 = y3.__private__.setLayoutMode = function(t2) {
    if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t2)) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t2 + '" is not recognized.');
    wt2 = t2;
  };
  y3.__private__.getLayoutMode = function() {
    return wt2;
  }, y3.__private__.setDisplayMode = y3.setDisplayMode = function(t2, e2, n2) {
    return yt2(t2), Lt2(e2), Nt3(n2), this;
  };
  var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y3.__private__.getDocumentProperty = function(t2) {
    if (-1 === Object.keys(xt2).indexOf(t2)) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt2[t2];
  }, y3.__private__.getDocumentProperties = function() {
    return xt2;
  }, y3.__private__.setDocumentProperties = y3.setProperties = y3.setDocumentProperties = function(t2) {
    for (var e2 in xt2) xt2.hasOwnProperty(e2) && t2[e2] && (xt2[e2] = t2[e2]);
    return this;
  }, y3.__private__.setDocumentProperty = function(t2, e2) {
    if (-1 === Object.keys(xt2).indexOf(t2)) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt2[t2] = e2;
  };
  var At2, St2, _t2, Pt2, kt2, Ft3 = {}, It2 = {}, jt2 = [], Ct2 = {}, Ot2 = {}, Bt2 = {}, Mt2 = {}, qt2 = null, Et2 = 0, Rt2 = [], Dt2 = new C3(y3), Tt2 = e.hotfixes || [], zt2 = {}, Ut3 = {}, Ht3 = [], Wt2 = function t2(e2, n2, r2, i2, a3, o2) {
    if (!(this instanceof t2)) return new t2(e2, n2, r2, i2, a3, o2);
    isNaN(e2) && (e2 = 1), isNaN(n2) && (n2 = 0), isNaN(r2) && (r2 = 0), isNaN(i2) && (i2 = 1), isNaN(a3) && (a3 = 0), isNaN(o2) && (o2 = 0), this._matrix = [e2, n2, r2, i2, a3, o2];
  };
  Object.defineProperty(Wt2.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Wt2.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Wt2.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Wt2.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Wt2.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Wt2.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Wt2.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t2) {
    this._matrix[0] = t2;
  } }), Object.defineProperty(Wt2.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t2) {
    this._matrix[1] = t2;
  } }), Object.defineProperty(Wt2.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t2) {
    this._matrix[2] = t2;
  } }), Object.defineProperty(Wt2.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t2) {
    this._matrix[3] = t2;
  } }), Object.defineProperty(Wt2.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t2) {
    this._matrix[4] = t2;
  } }), Object.defineProperty(Wt2.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t2) {
    this._matrix[5] = t2;
  } }), Object.defineProperty(Wt2.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Wt2.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Wt2.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Wt2.prototype, "isIdentity", { get: function() {
    return 1 === this.sx && 0 === this.shy && 0 === this.shx && 1 === this.sy && 0 === this.tx && 0 === this.ty;
  } }), Wt2.prototype.join = function(t2) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(B4).join(t2);
  }, Wt2.prototype.multiply = function(t2) {
    var e2 = t2.sx * this.sx + t2.shy * this.shx, n2 = t2.sx * this.shy + t2.shy * this.sy, r2 = t2.shx * this.sx + t2.sy * this.shx, i2 = t2.shx * this.shy + t2.sy * this.sy, a3 = t2.tx * this.sx + t2.ty * this.shx + this.tx, o2 = t2.tx * this.shy + t2.ty * this.sy + this.ty;
    return new Wt2(e2, n2, r2, i2, a3, o2);
  }, Wt2.prototype.decompose = function() {
    var t2 = this.sx, e2 = this.shy, n2 = this.shx, r2 = this.sy, i2 = this.tx, a3 = this.ty, o2 = Math.sqrt(t2 * t2 + e2 * e2), s3 = (t2 /= o2) * n2 + (e2 /= o2) * r2;
    n2 -= t2 * s3, r2 -= e2 * s3;
    var u3 = Math.sqrt(n2 * n2 + r2 * r2);
    return s3 /= u3, t2 * (r2 /= u3) < e2 * (n2 /= u3) && (t2 = -t2, e2 = -e2, s3 = -s3, o2 = -o2), { scale: new Wt2(o2, 0, 0, u3, 0, 0), translate: new Wt2(1, 0, 0, 1, i2, a3), rotate: new Wt2(t2, e2, -e2, t2, 0, 0), skew: new Wt2(1, 0, s3, 1, 0, 0) };
  }, Wt2.prototype.toString = function(t2) {
    return this.join(" ");
  }, Wt2.prototype.inversed = function() {
    var t2 = this.sx, e2 = this.shy, n2 = this.shx, r2 = this.sy, i2 = this.tx, a3 = this.ty, o2 = 1 / (t2 * r2 - e2 * n2), s3 = r2 * o2, u3 = -e2 * o2, c3 = -n2 * o2, l4 = t2 * o2;
    return new Wt2(s3, u3, c3, l4, -s3 * i2 - c3 * a3, -u3 * i2 - l4 * a3);
  }, Wt2.prototype.applyToPoint = function(t2) {
    var e2 = t2.x * this.sx + t2.y * this.shx + this.tx, n2 = t2.x * this.shy + t2.y * this.sy + this.ty;
    return new gn(e2, n2);
  }, Wt2.prototype.applyToRectangle = function(t2) {
    var e2 = this.applyToPoint(t2), n2 = this.applyToPoint(new gn(t2.x + t2.w, t2.y + t2.h));
    return new mn(e2.x, e2.y, n2.x - e2.x, n2.y - e2.y);
  }, Wt2.prototype.clone = function() {
    var t2 = this.sx, e2 = this.shy, n2 = this.shx, r2 = this.sy, i2 = this.tx, a3 = this.ty;
    return new Wt2(t2, e2, n2, r2, i2, a3);
  }, y3.Matrix = Wt2;
  var Vt2 = y3.matrixMult = function(t2, e2) {
    return e2.multiply(t2);
  }, Gt3 = new Wt2(1, 0, 0, 1, 0, 0);
  y3.unitMatrix = y3.identityMatrix = Gt3;
  var Yt2 = function(t2, e2) {
    if (!Ot2[t2]) {
      var n2 = (e2 instanceof M3 ? "Sh" : "P") + (Object.keys(Ct2).length + 1).toString(10);
      e2.id = n2, Ot2[t2] = n2, Ct2[n2] = e2, Dt2.publish("addPattern", e2);
    }
  };
  y3.ShadingPattern = M3, y3.TilingPattern = q2, y3.addShadingPattern = function(t2, e2) {
    return R3("addShadingPattern()"), Yt2(t2, e2), this;
  }, y3.beginTilingPattern = function(t2) {
    R3("beginTilingPattern()"), bn(t2.boundingBox[0], t2.boundingBox[1], t2.boundingBox[2] - t2.boundingBox[0], t2.boundingBox[3] - t2.boundingBox[1], t2.matrix);
  }, y3.endTilingPattern = function(t2, e2) {
    R3("endTilingPattern()"), e2.stream = ot2[$3].join("\n"), Yt2(t2, e2), Dt2.publish("endTilingPattern", e2), Ht3.pop().restore();
  };
  var Jt2, Xt2 = y3.__private__.newObject = function() {
    var t2 = Kt2();
    return Zt3(t2, true), t2;
  }, Kt2 = y3.__private__.newObjectDeferred = function() {
    return et3++, nt2[et3] = function() {
      return it2;
    }, et3;
  }, Zt3 = function(t2, e2) {
    return e2 = "boolean" == typeof e2 && e2, nt2[t2] = it2, e2 && lt2(t2 + " 0 obj"), t2;
  }, $t2 = y3.__private__.newAdditionalObject = function() {
    var t2 = { objId: Kt2(), content: "" };
    return at2.push(t2), t2;
  }, Qt3 = Kt2(), te2 = Kt2(), ee2 = y3.__private__.decodeColorString = function(t2) {
    var e2 = t2.split(" ");
    if (2 !== e2.length || "g" !== e2[1] && "G" !== e2[1]) 5 !== e2.length || "k" !== e2[4] && "K" !== e2[4] || (e2 = [(1 - e2[0]) * (1 - e2[3]), (1 - e2[1]) * (1 - e2[3]), (1 - e2[2]) * (1 - e2[3]), "r"]);
    else {
      var n2 = parseFloat(e2[0]);
      e2 = [n2, n2, n2, "r"];
    }
    for (var r2 = "#", i2 = 0; i2 < 3; i2++) r2 += ("0" + Math.floor(255 * parseFloat(e2[i2])).toString(16)).slice(-2);
    return r2;
  }, ne3 = y3.__private__.encodeColorString = function(e2) {
    var n2;
    "string" == typeof e2 && (e2 = { ch1: e2 });
    var r2 = e2.ch1, i2 = e2.ch2, a3 = e2.ch3, o2 = e2.ch4, s3 = "draw" === e2.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if ("string" == typeof r2 && "#" !== r2.charAt(0)) {
      var u3 = new h(r2);
      if (u3.ok) r2 = u3.toHex();
      else if (!/^\d*\.?\d*$/.test(r2)) throw new Error('Invalid color "' + r2 + '" passed to jsPDF.encodeColorString.');
    }
    if ("string" == typeof r2 && /^#[0-9A-Fa-f]{3}$/.test(r2) && (r2 = "#" + r2[1] + r2[1] + r2[2] + r2[2] + r2[3] + r2[3]), "string" == typeof r2 && /^#[0-9A-Fa-f]{6}$/.test(r2)) {
      var c3 = parseInt(r2.substr(1), 16);
      r2 = c3 >> 16 & 255, i2 = c3 >> 8 & 255, a3 = 255 & c3;
    }
    if (void 0 === i2 || void 0 === o2 && r2 === i2 && i2 === a3) n2 = "string" == typeof r2 ? r2 + " " + s3[0] : 2 === e2.precision ? T4(r2 / 255) + " " + s3[0] : z3(r2 / 255) + " " + s3[0];
    else if (void 0 === o2 || "object" === _typeof(o2)) {
      if (o2 && !isNaN(o2.a) && 0 === o2.a) return ["1.", "1.", "1.", s3[1]].join(" ");
      n2 = "string" == typeof r2 ? [r2, i2, a3, s3[1]].join(" ") : 2 === e2.precision ? [T4(r2 / 255), T4(i2 / 255), T4(a3 / 255), s3[1]].join(" ") : [z3(r2 / 255), z3(i2 / 255), z3(a3 / 255), s3[1]].join(" ");
    } else n2 = "string" == typeof r2 ? [r2, i2, a3, o2, s3[2]].join(" ") : 2 === e2.precision ? [T4(r2), T4(i2), T4(a3), T4(o2), s3[2]].join(" ") : [z3(r2), z3(i2), z3(a3), z3(o2), s3[2]].join(" ");
    return n2;
  }, re3 = y3.__private__.getFilters = function() {
    return c2;
  }, ie3 = y3.__private__.putStream = function(t2) {
    var e2 = (t2 = t2 || {}).data || "", n2 = t2.filters || re3(), r2 = t2.alreadyAppliedFilters || [], i2 = t2.addLength1 || false, a3 = e2.length, o2 = t2.objectId, s3 = function(t3) {
      return t3;
    };
    if (null !== m3 && void 0 === o2) throw new Error("ObjectId must be passed to putStream for file encryption");
    null !== m3 && (s3 = je3.encryptor(o2, 0));
    var u3 = {};
    true === n2 && (n2 = ["FlateEncode"]);
    var c3 = t2.additionalKeyValues || [], l4 = (u3 = void 0 !== E3.API.processDataByFilters ? E3.API.processDataByFilters(e2, n2) : { data: e2, reverseChain: [] }).reverseChain + (Array.isArray(r2) ? r2.join(" ") : r2.toString());
    if (0 !== u3.data.length && (c3.push({ key: "Length", value: u3.data.length }), true === i2 && c3.push({ key: "Length1", value: a3 })), 0 != l4.length) if (l4.split("/").length - 1 == 1) c3.push({ key: "Filter", value: l4 });
    else {
      c3.push({ key: "Filter", value: "[" + l4 + "]" });
      for (var h2 = 0; h2 < c3.length; h2 += 1) if ("DecodeParms" === c3[h2].key) {
        for (var f3 = [], d3 = 0; d3 < u3.reverseChain.split("/").length - 1; d3 += 1) f3.push("null");
        f3.push(c3[h2].value), c3[h2].value = "[" + f3.join(" ") + "]";
      }
    }
    lt2("<<");
    for (var p3 = 0; p3 < c3.length; p3++) lt2("/" + c3[p3].key + " " + c3[p3].value);
    lt2(">>"), 0 !== u3.data.length && (lt2("stream"), lt2(s3(u3.data)), lt2("endstream"));
  }, ae3 = y3.__private__.putPage = function(t2) {
    var e2 = t2.number, n2 = t2.data, r2 = t2.objId, i2 = t2.contentsObjId;
    Zt3(r2, true), lt2("<</Type /Page"), lt2("/Parent " + t2.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t2.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(B4(t2.mediaBox.bottomLeftX)) + " " + parseFloat(B4(t2.mediaBox.bottomLeftY)) + " " + B4(t2.mediaBox.topRightX) + " " + B4(t2.mediaBox.topRightY) + "]"), null !== t2.cropBox && lt2("/CropBox [" + B4(t2.cropBox.bottomLeftX) + " " + B4(t2.cropBox.bottomLeftY) + " " + B4(t2.cropBox.topRightX) + " " + B4(t2.cropBox.topRightY) + "]"), null !== t2.bleedBox && lt2("/BleedBox [" + B4(t2.bleedBox.bottomLeftX) + " " + B4(t2.bleedBox.bottomLeftY) + " " + B4(t2.bleedBox.topRightX) + " " + B4(t2.bleedBox.topRightY) + "]"), null !== t2.trimBox && lt2("/TrimBox [" + B4(t2.trimBox.bottomLeftX) + " " + B4(t2.trimBox.bottomLeftY) + " " + B4(t2.trimBox.topRightX) + " " + B4(t2.trimBox.topRightY) + "]"), null !== t2.artBox && lt2("/ArtBox [" + B4(t2.artBox.bottomLeftX) + " " + B4(t2.artBox.bottomLeftY) + " " + B4(t2.artBox.topRightX) + " " + B4(t2.artBox.topRightY) + "]"), "number" == typeof t2.userUnit && 1 !== t2.userUnit && lt2("/UserUnit " + t2.userUnit), Dt2.publish("putPage", { objId: r2, pageContext: Rt2[e2], pageNumber: e2, page: n2 }), lt2("/Contents " + i2 + " 0 R"), lt2(">>"), lt2("endobj");
    var a3 = n2.join("\n");
    return _3 === S4 && (a3 += "\nQ"), Zt3(i2, true), ie3({ data: a3, filters: re3(), objectId: i2 }), lt2("endobj"), r2;
  }, oe3 = y3.__private__.putPages = function() {
    var t2, e2, n2 = [];
    for (t2 = 1; t2 <= Et2; t2++) Rt2[t2].objId = Kt2(), Rt2[t2].contentsObjId = Kt2();
    for (t2 = 1; t2 <= Et2; t2++) n2.push(ae3({ number: t2, data: ot2[t2], objId: Rt2[t2].objId, contentsObjId: Rt2[t2].contentsObjId, mediaBox: Rt2[t2].mediaBox, cropBox: Rt2[t2].cropBox, bleedBox: Rt2[t2].bleedBox, trimBox: Rt2[t2].trimBox, artBox: Rt2[t2].artBox, userUnit: Rt2[t2].userUnit, rootDictionaryObjId: Qt3, resourceDictionaryObjId: te2 }));
    Zt3(Qt3, true), lt2("<</Type /Pages");
    var r2 = "/Kids [";
    for (e2 = 0; e2 < Et2; e2++) r2 += n2[e2] + " 0 R ";
    lt2(r2 + "]"), lt2("/Count " + Et2), lt2(">>"), lt2("endobj"), Dt2.publish("postPutPages");
  }, se3 = function(t2) {
    Dt2.publish("putFont", { font: t2, out: lt2, newObject: Xt2, putStream: ie3 }), true !== t2.isAlreadyPutted && (t2.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + j2(t2.postScriptName)), lt2("/Subtype /Type1"), "string" == typeof t2.encoding && lt2("/Encoding /" + t2.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
  }, ue3 = function(t2) {
    t2.objectNumber = Xt2();
    var e2 = [];
    e2.push({ key: "Type", value: "/XObject" }), e2.push({ key: "Subtype", value: "/Form" }), e2.push({ key: "BBox", value: "[" + [B4(t2.x), B4(t2.y), B4(t2.x + t2.width), B4(t2.y + t2.height)].join(" ") + "]" }), e2.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" });
    var n2 = t2.pages[1].join("\n");
    ie3({ data: n2, additionalKeyValues: e2, objectId: t2.objectNumber }), lt2("endobj");
  }, ce3 = function(t2, e2) {
    e2 || (e2 = 21);
    var n2 = Xt2(), r2 = (function(t3, e3) {
      var n3, r3 = [], i3 = 1 / (e3 - 1);
      for (n3 = 0; n3 < 1; n3 += i3) r3.push(n3);
      if (r3.push(1), 0 != t3[0].offset) {
        var a4 = { offset: 0, color: t3[0].color };
        t3.unshift(a4);
      }
      if (1 != t3[t3.length - 1].offset) {
        var o2 = { offset: 1, color: t3[t3.length - 1].color };
        t3.push(o2);
      }
      for (var s3 = "", u3 = 0, c3 = 0; c3 < r3.length; c3++) {
        for (n3 = r3[c3]; n3 > t3[u3 + 1].offset; ) u3++;
        var l4 = t3[u3].offset, h2 = (n3 - l4) / (t3[u3 + 1].offset - l4), f3 = t3[u3].color, d3 = t3[u3 + 1].color;
        s3 += tt2(Math.round((1 - h2) * f3[0] + h2 * d3[0]).toString(16)) + tt2(Math.round((1 - h2) * f3[1] + h2 * d3[1]).toString(16)) + tt2(Math.round((1 - h2) * f3[2] + h2 * d3[2]).toString(16));
      }
      return s3.trim();
    })(t2.colors, e2), i2 = [];
    i2.push({ key: "FunctionType", value: "0" }), i2.push({ key: "Domain", value: "[0.0 1.0]" }), i2.push({ key: "Size", value: "[" + e2 + "]" }), i2.push({ key: "BitsPerSample", value: "8" }), i2.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i2.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie3({ data: r2, additionalKeyValues: i2, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: n2 }), lt2("endobj"), t2.objectNumber = Xt2(), lt2("<< /ShadingType " + t2.type), lt2("/ColorSpace /DeviceRGB");
    var a3 = "/Coords [" + B4(parseFloat(t2.coords[0])) + " " + B4(parseFloat(t2.coords[1])) + " ";
    2 === t2.type ? a3 += B4(parseFloat(t2.coords[2])) + " " + B4(parseFloat(t2.coords[3])) : a3 += B4(parseFloat(t2.coords[2])) + " " + B4(parseFloat(t2.coords[3])) + " " + B4(parseFloat(t2.coords[4])) + " " + B4(parseFloat(t2.coords[5])), lt2(a3 += "]"), t2.matrix && lt2("/Matrix [" + t2.matrix.toString() + "]"), lt2("/Function " + n2 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
  }, le3 = function(t2, e2) {
    var n2 = Kt2(), r2 = Xt2();
    e2.push({ resourcesOid: n2, objectOid: r2 }), t2.objectNumber = r2;
    var i2 = [];
    i2.push({ key: "Type", value: "/Pattern" }), i2.push({ key: "PatternType", value: "1" }), i2.push({ key: "PaintType", value: "1" }), i2.push({ key: "TilingType", value: "1" }), i2.push({ key: "BBox", value: "[" + t2.boundingBox.map(B4).join(" ") + "]" }), i2.push({ key: "XStep", value: B4(t2.xStep) }), i2.push({ key: "YStep", value: B4(t2.yStep) }), i2.push({ key: "Resources", value: n2 + " 0 R" }), t2.matrix && i2.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" }), ie3({ data: t2.stream, additionalKeyValues: i2, objectId: t2.objectNumber }), lt2("endobj");
  }, he3 = function(t2) {
    for (var e2 in t2.objectNumber = Xt2(), lt2("<<"), t2) switch (e2) {
      case "opacity":
        lt2("/ca " + T4(t2[e2]));
        break;
      case "stroke-opacity":
        lt2("/CA " + T4(t2[e2]));
    }
    lt2(">>"), lt2("endobj");
  }, fe3 = function(t2) {
    Zt3(t2.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), (function() {
      for (var t3 in lt2("/Font <<"), Ft3) Ft3.hasOwnProperty(t3) && (false === v3 || true === v3 && b3.hasOwnProperty(t3)) && lt2("/" + t3 + " " + Ft3[t3].objectNumber + " 0 R");
      lt2(">>");
    })(), (function() {
      if (Object.keys(Ct2).length > 0) {
        for (var t3 in lt2("/Shading <<"), Ct2) Ct2.hasOwnProperty(t3) && Ct2[t3] instanceof M3 && Ct2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Ct2[t3].objectNumber + " 0 R");
        Dt2.publish("putShadingPatternDict"), lt2(">>");
      }
    })(), (function(t3) {
      if (Object.keys(Ct2).length > 0) {
        for (var e2 in lt2("/Pattern <<"), Ct2) Ct2.hasOwnProperty(e2) && Ct2[e2] instanceof y3.TilingPattern && Ct2[e2].objectNumber >= 0 && Ct2[e2].objectNumber < t3 && lt2("/" + e2 + " " + Ct2[e2].objectNumber + " 0 R");
        Dt2.publish("putTilingPatternDict"), lt2(">>");
      }
    })(t2.objectOid), (function() {
      if (Object.keys(Bt2).length > 0) {
        var t3;
        for (t3 in lt2("/ExtGState <<"), Bt2) Bt2.hasOwnProperty(t3) && Bt2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Bt2[t3].objectNumber + " 0 R");
        Dt2.publish("putGStateDict"), lt2(">>");
      }
    })(), (function() {
      for (var t3 in lt2("/XObject <<"), zt2) zt2.hasOwnProperty(t3) && zt2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + zt2[t3].objectNumber + " 0 R");
      Dt2.publish("putXobjectDict"), lt2(">>");
    })(), lt2(">>"), lt2("endobj");
  }, de3 = function(t2) {
    It2[t2.fontName] = It2[t2.fontName] || {}, It2[t2.fontName][t2.fontStyle] = t2.id;
  }, pe3 = function(t2, e2, n2, r2, i2) {
    var a3 = { id: "F" + (Object.keys(Ft3).length + 1).toString(10), postScriptName: t2, fontName: e2, fontStyle: n2, encoding: r2, isStandardFont: i2 || false, metadata: {} };
    return Dt2.publish("addFont", { font: a3, instance: this }), Ft3[a3.id] = a3, de3(a3), a3.id;
  }, ge3 = y3.__private__.pdfEscape = y3.pdfEscape = function(t2, e2) {
    return (function(t3, e3) {
      var n2, r2, i2, a3, o2, s3, u3, c3, l4;
      if (i2 = (e3 = e3 || {}).sourceEncoding || "Unicode", o2 = e3.outputEncoding, (e3.autoencode || o2) && Ft3[At2].metadata && Ft3[At2].metadata[i2] && Ft3[At2].metadata[i2].encoding && (a3 = Ft3[At2].metadata[i2].encoding, !o2 && Ft3[At2].encoding && (o2 = Ft3[At2].encoding), !o2 && a3.codePages && (o2 = a3.codePages[0]), "string" == typeof o2 && (o2 = a3[o2]), o2)) {
        for (u3 = false, s3 = [], n2 = 0, r2 = t3.length; n2 < r2; n2++) (c3 = o2[t3.charCodeAt(n2)]) ? s3.push(String.fromCharCode(c3)) : s3.push(t3[n2]), s3[n2].charCodeAt(0) >> 8 && (u3 = true);
        t3 = s3.join("");
      }
      for (n2 = t3.length; void 0 === u3 && 0 !== n2; ) t3.charCodeAt(n2 - 1) >> 8 && (u3 = true), n2--;
      if (!u3) return t3;
      for (s3 = e3.noBOM ? [] : [254, 255], n2 = 0, r2 = t3.length; n2 < r2; n2++) {
        if ((l4 = (c3 = t3.charCodeAt(n2)) >> 8) >> 8) throw new Error("Character at position " + n2 + " of string '" + t3 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
        s3.push(l4), s3.push(c3 - (l4 << 8));
      }
      return String.fromCharCode.apply(void 0, s3);
    })(t2, e2).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, me2 = y3.__private__.beginPage = function(t2) {
    ot2[++Et2] = [], Rt2[Et2] = { objId: 0, contentsObjId: 0, userUnit: Number(f2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t2[0]), topRightY: Number(t2[1]) } }, ye3(Et2), ct2(ot2[$3]);
  }, ve3 = function(t2, e2) {
    var n2, i2, a3;
    switch (r = e2 || r, "string" == typeof t2 && (n2 = x3(t2.toLowerCase()), Array.isArray(n2) && (i2 = n2[0], a3 = n2[1])), Array.isArray(t2) && (i2 = t2[0] * St2, a3 = t2[1] * St2), isNaN(i2) && (i2 = s2[0], a3 = s2[1]), (i2 > 14400 || a3 > 14400) && (o.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), i2 = Math.min(14400, i2), a3 = Math.min(14400, a3)), s2 = [i2, a3], r.substr(0, 1)) {
      case "l":
        a3 > i2 && (s2 = [a3, i2]);
        break;
      case "p":
        i2 > a3 && (s2 = [a3, i2]);
    }
    me2(s2), Ze2(Xe2), lt2(on), 0 !== fn && lt2(fn + " J"), 0 !== dn && lt2(dn + " j"), Dt2.publish("addPage", { pageNumber: Et2 });
  }, be3 = function(t2) {
    t2 > 0 && t2 <= Et2 && (ot2.splice(t2, 1), Rt2.splice(t2, 1), Et2--, $3 > Et2 && ($3 = Et2), this.setPage($3));
  }, ye3 = function(t2) {
    t2 > 0 && t2 <= Et2 && ($3 = t2);
  }, we3 = y3.__private__.getNumberOfPages = y3.getNumberOfPages = function() {
    return ot2.length - 1;
  }, Ne3 = function(t2, e2, n2) {
    var r2, i2 = void 0;
    return n2 = n2 || {}, t2 = void 0 !== t2 ? t2 : Ft3[At2].fontName, e2 = void 0 !== e2 ? e2 : Ft3[At2].fontStyle, r2 = t2.toLowerCase(), void 0 !== It2[r2] && void 0 !== It2[r2][e2] ? i2 = It2[r2][e2] : void 0 !== It2[t2] && void 0 !== It2[t2][e2] ? i2 = It2[t2][e2] : false === n2.disableWarning && o.warn("Unable to look up font label for font '" + t2 + "', '" + e2 + "'. Refer to getFontList() for available fonts."), i2 || n2.noFallback || null == (i2 = It2.times[e2]) && (i2 = It2.times.normal), i2;
  }, Le3 = y3.__private__.putInfo = function() {
    var t2 = Xt2(), e2 = function(t3) {
      return t3;
    };
    for (var n2 in null !== m3 && (e2 = je3.encryptor(t2, 0)), lt2("<<"), lt2("/Producer (" + ge3(e2("jsPDF " + E3.version)) + ")"), xt2) xt2.hasOwnProperty(n2) && xt2[n2] && lt2("/" + n2.substr(0, 1).toUpperCase() + n2.substr(1) + " (" + ge3(e2(xt2[n2])) + ")");
    lt2("/CreationDate (" + ge3(e2(W4)) + ")"), lt2(">>"), lt2("endobj");
  }, xe3 = y3.__private__.putCatalog = function(t2) {
    var e2 = (t2 = t2 || {}).rootDictionaryObjId || Qt3;
    switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e2 + " 0 R"), gt2 || (gt2 = "fullwidth"), gt2) {
      case "fullwidth":
        lt2("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt2("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt2("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt2("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var n2 = "" + gt2;
        "%" === n2.substr(n2.length - 1) && (gt2 = parseInt(gt2) / 100), "number" == typeof gt2 && lt2("/OpenAction [3 0 R /XYZ null null " + T4(gt2) + "]");
    }
    switch (wt2 || (wt2 = "continuous"), wt2) {
      case "continuous":
        lt2("/PageLayout /OneColumn");
        break;
      case "single":
        lt2("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt2("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt2("/PageLayout /TwoColumnRight");
    }
    bt2 && lt2("/PageMode /" + bt2), Dt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
  }, Ae3 = y3.__private__.putTrailer = function() {
    lt2("trailer"), lt2("<<"), lt2("/Size " + (et3 + 1)), lt2("/Root " + et3 + " 0 R"), lt2("/Info " + (et3 - 1) + " 0 R"), null !== m3 && lt2("/Encrypt " + je3.oid + " 0 R"), lt2("/ID [ <" + V4 + "> <" + V4 + "> ]"), lt2(">>");
  }, Se3 = y3.__private__.putHeader = function() {
    lt2("%PDF-" + w3), lt2("%\xBA\xDF\xAC\xE0");
  }, _e3 = y3.__private__.putXRef = function() {
    var t2 = "0000000000";
    lt2("xref"), lt2("0 " + (et3 + 1)), lt2("0000000000 65535 f ");
    for (var e2 = 1; e2 <= et3; e2++) "function" == typeof nt2[e2] ? lt2((t2 + nt2[e2]()).slice(-10) + " 00000 n ") : void 0 !== nt2[e2] ? lt2((t2 + nt2[e2]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
  }, Pe3 = y3.__private__.buildDocument = function() {
    var t2;
    et3 = 0, it2 = 0, rt2 = [], nt2 = [], at2 = [], Qt3 = Kt2(), te2 = Kt2(), ct2(rt2), Dt2.publish("buildDocument"), Se3(), oe3(), (function() {
      Dt2.publish("putAdditionalObjects");
      for (var t3 = 0; t3 < at2.length; t3++) {
        var e3 = at2[t3];
        Zt3(e3.objId, true), lt2(e3.content), lt2("endobj");
      }
      Dt2.publish("postPutAdditionalObjects");
    })(), t2 = [], (function() {
      for (var t3 in Ft3) Ft3.hasOwnProperty(t3) && (false === v3 || true === v3 && b3.hasOwnProperty(t3)) && se3(Ft3[t3]);
    })(), (function() {
      var t3;
      for (t3 in Bt2) Bt2.hasOwnProperty(t3) && he3(Bt2[t3]);
    })(), (function() {
      for (var t3 in zt2) zt2.hasOwnProperty(t3) && ue3(zt2[t3]);
    })(), (function(t3) {
      var e3;
      for (e3 in Ct2) Ct2.hasOwnProperty(e3) && (Ct2[e3] instanceof M3 ? ce3(Ct2[e3]) : Ct2[e3] instanceof q2 && le3(Ct2[e3], t3));
    })(t2), Dt2.publish("putResources"), t2.forEach(fe3), fe3({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Dt2.publish("postPutResources"), null !== m3 && (je3.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + je3.v), lt2("/R " + je3.r), lt2("/U <" + je3.toHexString(je3.U) + ">"), lt2("/O <" + je3.toHexString(je3.O) + ">"), lt2("/P " + je3.P), lt2(">>"), lt2("endobj")), Le3(), xe3();
    var e2 = it2;
    return _e3(), Ae3(), lt2("startxref"), lt2("" + e2), lt2("%%EOF"), ct2(ot2[$3]), rt2.join("\n");
  }, ke3 = y3.__private__.getBlob = function(t2) {
    return new Blob([ft2(t2)], { type: "application/pdf" });
  }, Fe3 = y3.output = y3.__private__.output = (Jt2 = function(t2, e2) {
    switch ("string" == typeof (e2 = e2 || {}) ? e2 = { filename: e2 } : e2.filename = e2.filename || "generated.pdf", t2) {
      case void 0:
        return Pe3();
      case "save":
        y3.save(e2.filename);
        break;
      case "arraybuffer":
        return ft2(Pe3());
      case "blob":
        return ke3(Pe3());
      case "bloburi":
      case "bloburl":
        if (void 0 !== i.URL && "function" == typeof i.URL.createObjectURL) return i.URL && i.URL.createObjectURL(ke3(Pe3())) || void 0;
        o.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var n2 = "", r2 = Pe3();
        try {
          n2 = d2(r2);
        } catch (m4) {
          n2 = d2(unescape(encodeURIComponent(r2)));
        }
        return "data:application/pdf;filename=" + e2.filename + ";base64," + n2;
      case "pdfobjectnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(i)) {
          var a3 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s3 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          e2.pdfObjectUrl && (a3 = e2.pdfObjectUrl, s3 = "");
          var u3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + a3 + '"' + s3 + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e2) + ");<\/script></body></html>", c3 = i.open();
          return null !== c3 && c3.document.write(u3), c3;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(i)) {
          var l4 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e2.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e2.filename + '" width="500px" height="400px" /></body></html>', h2 = i.open();
          if (null !== h2) {
            h2.document.write(l4);
            var f3 = this;
            h2.document.documentElement.querySelector("#pdfViewer").onload = function() {
              h2.document.title = e2.filename, h2.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(f3.output("bloburl"));
            };
          }
          return h2;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if ("[object Window]" !== Object.prototype.toString.call(i)) throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var p3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e2) + '"></iframe></body></html>', g3 = i.open();
        if (null !== g3 && (g3.document.write(p3), g3.document.title = e2.filename), g3 || "undefined" == typeof safari) return g3;
        break;
      case "datauri":
      case "dataurl":
        return i.document.location.href = this.output("datauristring", e2);
      default:
        return null;
    }
  }, Jt2.foo = function() {
    try {
      return Jt2.apply(this, arguments);
    } catch (n2) {
      var t2 = n2.stack || "";
      ~t2.indexOf(" at ") && (t2 = t2.split(" at ")[1]);
      var e2 = "Error in function " + t2.split("\n")[0].split("<")[0] + ": " + n2.message;
      if (!i.console) throw new Error(e2);
      i.console.error(e2, n2), i.alert && alert(e2);
    }
  }, Jt2.foo.bar = Jt2, Jt2.foo), Ie3 = function(t2) {
    return true === Array.isArray(Tt2) && Tt2.indexOf(t2) > -1;
  };
  switch (a2) {
    case "pt":
      St2 = 1;
      break;
    case "mm":
      St2 = 72 / 25.4;
      break;
    case "cm":
      St2 = 72 / 2.54;
      break;
    case "in":
      St2 = 72;
      break;
    case "px":
      St2 = 1 == Ie3("px_scaling") ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      St2 = 12;
      break;
    case "ex":
      St2 = 6;
      break;
    default:
      if ("number" != typeof a2) throw new Error("Invalid unit: " + a2);
      St2 = a2;
  }
  var je3 = null;
  K4(), Y3();
  var Ce2 = y3.__private__.getPageInfo = y3.getPageInfo = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt2[t2].objId, pageNumber: t2, pageContext: Rt2[t2] };
  }, Oe2 = y3.__private__.getPageInfoByObjId = function(t2) {
    if (isNaN(t2) || t2 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e2 in Rt2) if (Rt2[e2].objId === t2) break;
    return Ce2(e2);
  }, Be2 = y3.__private__.getCurrentPageInfo = y3.getCurrentPageInfo = function() {
    return { objId: Rt2[$3].objId, pageNumber: $3, pageContext: Rt2[$3] };
  };
  y3.addPage = function() {
    return ve3.apply(this, arguments), this;
  }, y3.setPage = function() {
    return ye3.apply(this, arguments), ct2.call(this, ot2[$3]), this;
  }, y3.insertPage = function(t2) {
    return this.addPage(), this.movePage($3, t2), this;
  }, y3.movePage = function(t2, e2) {
    var n2, r2;
    if (t2 > e2) {
      n2 = ot2[t2], r2 = Rt2[t2];
      for (var i2 = t2; i2 > e2; i2--) ot2[i2] = ot2[i2 - 1], Rt2[i2] = Rt2[i2 - 1];
      ot2[e2] = n2, Rt2[e2] = r2, this.setPage(e2);
    } else if (t2 < e2) {
      n2 = ot2[t2], r2 = Rt2[t2];
      for (var a3 = t2; a3 < e2; a3++) ot2[a3] = ot2[a3 + 1], Rt2[a3] = Rt2[a3 + 1];
      ot2[e2] = n2, Rt2[e2] = r2, this.setPage(e2);
    }
    return this;
  }, y3.deletePage = function() {
    return be3.apply(this, arguments), this;
  }, y3.__private__.text = y3.text = function(e2, n2, r2, i2, a3) {
    var o2, s3, u3, c3, l4, h2, f3, d3, p3, g3 = (i2 = i2 || {}).scope || this;
    if ("number" == typeof e2 && "number" == typeof n2 && ("string" == typeof r2 || Array.isArray(r2))) {
      var m4 = r2;
      r2 = n2, n2 = e2, e2 = m4;
    }
    if (arguments[3] instanceof Wt2 == 0 ? (u3 = arguments[4], c3 = arguments[5], "object" === _typeof(f3 = arguments[3]) && null !== f3 || ("string" == typeof u3 && (c3 = u3, u3 = null), "string" == typeof f3 && (c3 = f3, f3 = null), "number" == typeof f3 && (u3 = f3, f3 = null), i2 = { flags: f3, angle: u3, align: c3 })) : (R3("The transform parameter of text() with a Matrix value"), p3 = a3), isNaN(n2) || isNaN(r2) || null == e2) throw new Error("Invalid arguments passed to jsPDF.text");
    if (0 === e2.length) return g3;
    var v4, y4 = "", w4 = "number" == typeof i2.lineHeightFactor ? i2.lineHeightFactor : Je2, N5 = g3.internal.scaleFactor;
    function L5(t2) {
      return t2 = t2.split("	").join(Array(i2.TabLen || 9).join(" ")), ge3(t2, f3);
    }
    function x4(t2) {
      for (var e3, n3 = t2.concat(), r3 = [], i3 = n3.length; i3--; ) "string" == typeof (e3 = n3.shift()) ? r3.push(e3) : Array.isArray(t2) && (1 === e3.length || void 0 === e3[1] && void 0 === e3[2]) ? r3.push(e3[0]) : r3.push([e3[0], e3[1], e3[2]]);
      return r3;
    }
    function A4(t2, e3) {
      var n3;
      if ("string" == typeof t2) n3 = e3(t2)[0];
      else if (Array.isArray(t2)) {
        for (var r3, i3, a4 = t2.concat(), o3 = [], s4 = a4.length; s4--; ) "string" == typeof (r3 = a4.shift()) ? o3.push(e3(r3)[0]) : Array.isArray(r3) && "string" == typeof r3[0] && (i3 = e3(r3[0], r3[1], r3[2]), o3.push([i3[0], i3[1], i3[2]]));
        n3 = o3;
      }
      return n3;
    }
    var P5 = false, k4 = true;
    if ("string" == typeof e2) P5 = true;
    else if (Array.isArray(e2)) {
      var F15 = e2.concat();
      s3 = [];
      for (var I4, j3 = F15.length; j3--; ) ("string" != typeof (I4 = F15.shift()) || Array.isArray(I4) && "string" != typeof I4[0]) && (k4 = false);
      P5 = k4;
    }
    if (false === P5) throw new Error('Type of text must be string or Array. "' + e2 + '" is not recognized.');
    "string" == typeof e2 && (e2 = e2.match(/[\r?\n]/) ? e2.split(/\r\n|\r|\n/g) : [e2]);
    var C4 = pt2 / g3.internal.scaleFactor, O3 = C4 * (w4 - 1);
    switch (i2.baseline) {
      case "bottom":
        r2 -= O3;
        break;
      case "top":
        r2 += C4 - O3;
        break;
      case "hanging":
        r2 += C4 - 2 * O3;
        break;
      case "middle":
        r2 += C4 / 2 - O3;
    }
    if ((h2 = i2.maxWidth || 0) > 0 && ("string" == typeof e2 ? e2 = g3.splitTextToSize(e2, h2) : "[object Array]" === Object.prototype.toString.call(e2) && (e2 = e2.reduce(function(t2, e3) {
      return t2.concat(g3.splitTextToSize(e3, h2));
    }, []))), o2 = { text: e2, x: n2, y: r2, options: i2, mutex: { pdfEscape: ge3, activeFontKey: At2, fonts: Ft3, activeFontSize: pt2 } }, Dt2.publish("preProcessText", o2), e2 = o2.text, u3 = (i2 = o2.options).angle, p3 instanceof Wt2 == 0 && u3 && "number" == typeof u3) {
      u3 *= Math.PI / 180, 0 === i2.rotationDirection && (u3 = -u3), _3 === S4 && (u3 = -u3);
      var M4 = Math.cos(u3), q3 = Math.sin(u3);
      p3 = new Wt2(M4, q3, -q3, M4, 0, 0);
    } else u3 && u3 instanceof Wt2 && (p3 = u3);
    _3 !== S4 || p3 || (p3 = Gt3), void 0 !== (l4 = i2.charSpace || ln2) && (y4 += B4(U4(l4)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d3 = i2.horizontalScale) && (y4 += B4(100 * d3) + " Tz\n"), i2.lang;
    var E4 = -1, D5 = void 0 !== i2.renderingMode ? i2.renderingMode : i2.stroke, T5 = g3.internal.getCurrentPageInfo().pageContext;
    switch (D5) {
      case 0:
      case false:
      case "fill":
        E4 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        E4 = 1;
        break;
      case 2:
      case "fillThenStroke":
        E4 = 2;
        break;
      case 3:
      case "invisible":
        E4 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        E4 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        E4 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        E4 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        E4 = 7;
    }
    var z4 = void 0 !== T5.usedRenderingMode ? T5.usedRenderingMode : -1;
    -1 !== E4 ? y4 += E4 + " Tr\n" : -1 !== z4 && (y4 += "0 Tr\n"), -1 !== E4 && (T5.usedRenderingMode = E4), c3 = i2.align || "left";
    var H4, W5 = pt2 * w4, V5 = g3.internal.pageSize.getWidth(), G5 = Ft3[At2];
    l4 = i2.charSpace || ln2, h2 = i2.maxWidth || 0, f3 = Object.assign({ autoencode: true, noBOM: true }, i2.flags);
    var Y4 = [], J5 = function(t2) {
      return g3.getStringUnitWidth(t2, { font: G5, charSpace: l4, fontSize: pt2, doKerning: false }) * pt2 / N5;
    };
    if ("[object Array]" === Object.prototype.toString.call(e2)) {
      var X5;
      s3 = x4(e2), "left" !== c3 && (H4 = s3.map(J5));
      var K5, Z4 = 0;
      if ("right" === c3) {
        n2 -= H4[0], e2 = [], j3 = s3.length;
        for (var $4 = 0; $4 < j3; $4++) 0 === $4 ? (K5 = en(n2), X5 = nn(r2)) : (K5 = U4(Z4 - H4[$4]), X5 = -W5), e2.push([s3[$4], K5, X5]), Z4 = H4[$4];
      } else if ("center" === c3) {
        n2 -= H4[0] / 2, e2 = [], j3 = s3.length;
        for (var Q5 = 0; Q5 < j3; Q5++) 0 === Q5 ? (K5 = en(n2), X5 = nn(r2)) : (K5 = U4((Z4 - H4[Q5]) / 2), X5 = -W5), e2.push([s3[Q5], K5, X5]), Z4 = H4[Q5];
      } else if ("left" === c3) {
        e2 = [], j3 = s3.length;
        for (var tt3 = 0; tt3 < j3; tt3++) e2.push(s3[tt3]);
      } else if ("justify" === c3 && "Identity-H" === G5.encoding) {
        e2 = [], j3 = s3.length, h2 = 0 !== h2 ? h2 : V5;
        for (var et4 = 0, nt3 = 0; nt3 < j3; nt3++) if (X5 = 0 === nt3 ? nn(r2) : -W5, K5 = 0 === nt3 ? en(n2) : et4, nt3 < j3 - 1) {
          var rt3 = U4((h2 - H4[nt3]) / (s3[nt3].split(" ").length - 1)), it3 = s3[nt3].split(" ");
          e2.push([it3[0] + " ", K5, X5]), et4 = 0;
          for (var at3 = 1; at3 < it3.length; at3++) {
            var ot3 = (J5(it3[at3 - 1] + " " + it3[at3]) - J5(it3[at3])) * N5 + rt3;
            at3 == it3.length - 1 ? e2.push([it3[at3], ot3, 0]) : e2.push([it3[at3] + " ", ot3, 0]), et4 -= ot3;
          }
        } else e2.push([s3[nt3], K5, X5]);
        e2.push(["", et4, 0]);
      } else {
        if ("justify" !== c3) throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (e2 = [], j3 = s3.length, h2 = 0 !== h2 ? h2 : V5, nt3 = 0; nt3 < j3; nt3++) {
          X5 = 0 === nt3 ? nn(r2) : -W5, K5 = 0 === nt3 ? en(n2) : 0;
          var st3 = s3[nt3].split(" ").length - 1, ut3 = st3 > 0 ? (h2 - H4[nt3]) / st3 : 0;
          nt3 < j3 - 1 ? Y4.push(B4(U4(ut3))) : Y4.push(0), e2.push([s3[nt3], K5, X5]);
        }
      }
    }
    true === ("boolean" == typeof i2.R2L ? i2.R2L : vt2) && (e2 = A4(e2, function(t2, e3, n3) {
      return [t2.split("").reverse().join(""), e3, n3];
    })), o2 = { text: e2, x: n2, y: r2, options: i2, mutex: { pdfEscape: ge3, activeFontKey: At2, fonts: Ft3, activeFontSize: pt2 } }, Dt2.publish("postProcessText", o2), e2 = o2.text, v4 = o2.mutex.isHex || false;
    var ct3 = Ft3[At2].encoding;
    "WinAnsiEncoding" !== ct3 && "StandardEncoding" !== ct3 || (e2 = A4(e2, function(t2, e3, n3) {
      return [L5(t2), e3, n3];
    })), s3 = x4(e2), e2 = [];
    for (var ht3, ft3, dt3, gt3 = Array.isArray(s3[0]) ? 1 : 0, mt3 = "", bt3 = function(t2, e3, n3) {
      var r3 = "";
      return n3 instanceof Wt2 ? (n3 = "number" == typeof i2.angle ? Vt2(n3, new Wt2(1, 0, 0, 1, t2, e3)) : Vt2(new Wt2(1, 0, 0, 1, t2, e3), n3), _3 === S4 && (n3 = Vt2(new Wt2(1, 0, 0, -1, 0, 0), n3)), r3 = n3.join(" ") + " Tm\n") : r3 = B4(t2) + " " + B4(e3) + " Td\n", r3;
    }, yt3 = 0; yt3 < s3.length; yt3++) {
      switch (mt3 = "", gt3) {
        case 1:
          dt3 = (v4 ? "<" : "(") + s3[yt3][0] + (v4 ? ">" : ")"), ht3 = parseFloat(s3[yt3][1]), ft3 = parseFloat(s3[yt3][2]);
          break;
        case 0:
          dt3 = (v4 ? "<" : "(") + s3[yt3] + (v4 ? ">" : ")"), ht3 = en(n2), ft3 = nn(r2);
      }
      void 0 !== Y4 && void 0 !== Y4[yt3] && (mt3 = Y4[yt3] + " Tw\n"), 0 === yt3 ? e2.push(mt3 + bt3(ht3, ft3, p3) + dt3) : 0 === gt3 ? e2.push(mt3 + dt3) : 1 === gt3 && e2.push(mt3 + bt3(ht3, ft3, p3) + dt3);
    }
    e2 = 0 === gt3 ? e2.join(" Tj\nT* ") : e2.join(" Tj\n"), e2 += " Tj\n";
    var wt3 = "BT\n/";
    return wt3 += At2 + " " + pt2 + " Tf\n", wt3 += B4(pt2 * w4) + " TL\n", wt3 += un + "\n", wt3 += y4, wt3 += e2, lt2(wt3 += "ET"), b3[At2] = true, g3;
  };
  var Me2 = y3.__private__.clip = y3.clip = function(t2) {
    return lt2("evenodd" === t2 ? "W*" : "W"), this;
  };
  y3.clipEvenOdd = function() {
    return Me2("evenodd");
  }, y3.__private__.discardPath = y3.discardPath = function() {
    return lt2("n"), this;
  };
  var qe2 = y3.__private__.isValidStyle = function(t2) {
    var e2 = false;
    return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t2) && (e2 = true), e2;
  };
  y3.__private__.setDefaultPathOperation = y3.setDefaultPathOperation = function(t2) {
    return qe2(t2) && (g2 = t2), this;
  };
  var Ee2 = y3.__private__.getStyle = y3.getStyle = function(t2) {
    var e2 = g2;
    switch (t2) {
      case "D":
      case "S":
        e2 = "S";
        break;
      case "F":
        e2 = "f";
        break;
      case "FD":
      case "DF":
        e2 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e2 = t2;
    }
    return e2;
  }, Re2 = y3.close = function() {
    return lt2("h"), this;
  };
  y3.stroke = function() {
    return lt2("S"), this;
  }, y3.fill = function(t2) {
    return De2("f", t2), this;
  }, y3.fillEvenOdd = function(t2) {
    return De2("f*", t2), this;
  }, y3.fillStroke = function(t2) {
    return De2("B", t2), this;
  }, y3.fillStrokeEvenOdd = function(t2) {
    return De2("B*", t2), this;
  };
  var De2 = function(e2, n2) {
    "object" === _typeof(n2) ? Ue2(n2, e2) : lt2(e2);
  }, Te2 = function(t2) {
    null === t2 || _3 === S4 && void 0 === t2 || (t2 = Ee2(t2), lt2(t2));
  };
  function ze2(t2, e2, n2, r2, i2) {
    var a3 = new q2(e2 || this.boundingBox, n2 || this.xStep, r2 || this.yStep, this.gState, i2 || this.matrix);
    a3.stream = this.stream;
    var o2 = t2 + "$$" + this.cloneIndex++ + "$$";
    return Yt2(o2, a3), a3;
  }
  var Ue2 = function(t2, e2) {
    var n2 = Ot2[t2.key], r2 = Ct2[n2];
    if (r2 instanceof M3) lt2("q"), lt2(He2(e2)), r2.gState && y3.setGState(r2.gState), lt2(t2.matrix.toString() + " cm"), lt2("/" + n2 + " sh"), lt2("Q");
    else if (r2 instanceof q2) {
      var i2 = new Wt2(1, 0, 0, -1, 0, _n());
      t2.matrix && (i2 = i2.multiply(t2.matrix || Gt3), n2 = ze2.call(r2, t2.key, t2.boundingBox, t2.xStep, t2.yStep, i2).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + n2 + " scn"), r2.gState && y3.setGState(r2.gState), lt2(e2), lt2("Q");
    }
  }, He2 = function(t2) {
    switch (t2) {
      case "f":
      case "F":
      case "n":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
      case "S":
        return "W S";
      case "B*":
        return "W* S";
    }
  }, We2 = y3.moveTo = function(t2, e2) {
    return lt2(B4(U4(t2)) + " " + B4(H3(e2)) + " m"), this;
  }, Ve2 = y3.lineTo = function(t2, e2) {
    return lt2(B4(U4(t2)) + " " + B4(H3(e2)) + " l"), this;
  }, Ge2 = y3.curveTo = function(t2, e2, n2, r2, i2, a3) {
    return lt2([B4(U4(t2)), B4(H3(e2)), B4(U4(n2)), B4(H3(r2)), B4(U4(i2)), B4(H3(a3)), "c"].join(" ")), this;
  };
  y3.__private__.line = y3.line = function(t2, e2, n2, r2, i2) {
    if (isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2) || !qe2(i2)) throw new Error("Invalid arguments passed to jsPDF.line");
    return _3 === A3 ? this.lines([[n2 - t2, r2 - e2]], t2, e2, [1, 1], i2 || "S") : this.lines([[n2 - t2, r2 - e2]], t2, e2, [1, 1]).stroke();
  }, y3.__private__.lines = y3.lines = function(t2, e2, n2, r2, i2, a3) {
    var o2, s3, u3, c3, l4, h2, f3, d3, p3, g3, m4, v4;
    if ("number" == typeof t2 && (v4 = n2, n2 = e2, e2 = t2, t2 = v4), r2 = r2 || [1, 1], a3 = a3 || false, isNaN(e2) || isNaN(n2) || !Array.isArray(t2) || !Array.isArray(r2) || !qe2(i2) || "boolean" != typeof a3) throw new Error("Invalid arguments passed to jsPDF.lines");
    for (We2(e2, n2), o2 = r2[0], s3 = r2[1], c3 = t2.length, g3 = e2, m4 = n2, u3 = 0; u3 < c3; u3++) 2 === (l4 = t2[u3]).length ? (g3 = l4[0] * o2 + g3, m4 = l4[1] * s3 + m4, Ve2(g3, m4)) : (h2 = l4[0] * o2 + g3, f3 = l4[1] * s3 + m4, d3 = l4[2] * o2 + g3, p3 = l4[3] * s3 + m4, g3 = l4[4] * o2 + g3, m4 = l4[5] * s3 + m4, Ge2(h2, f3, d3, p3, g3, m4));
    return a3 && Re2(), Te2(i2), this;
  }, y3.path = function(t2) {
    for (var e2 = 0; e2 < t2.length; e2++) {
      var n2 = t2[e2], r2 = n2.c;
      switch (n2.op) {
        case "m":
          We2(r2[0], r2[1]);
          break;
        case "l":
          Ve2(r2[0], r2[1]);
          break;
        case "c":
          Ge2.apply(this, r2);
          break;
        case "h":
          Re2();
      }
    }
    return this;
  }, y3.__private__.rect = y3.rect = function(t2, e2, n2, r2, i2) {
    if (isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2) || !qe2(i2)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return _3 === A3 && (r2 = -r2), lt2([B4(U4(t2)), B4(H3(e2)), B4(U4(n2)), B4(U4(r2)), "re"].join(" ")), Te2(i2), this;
  }, y3.__private__.triangle = y3.triangle = function(t2, e2, n2, r2, i2, a3, o2) {
    if (isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2) || isNaN(i2) || isNaN(a3) || !qe2(o2)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[n2 - t2, r2 - e2], [i2 - n2, a3 - r2], [t2 - i2, e2 - a3]], t2, e2, [1, 1], o2, true), this;
  }, y3.__private__.roundedRect = y3.roundedRect = function(t2, e2, n2, r2, i2, a3, o2) {
    if (isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2) || isNaN(i2) || isNaN(a3) || !qe2(o2)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s3 = 4 / 3 * (Math.SQRT2 - 1);
    return i2 = Math.min(i2, 0.5 * n2), a3 = Math.min(a3, 0.5 * r2), this.lines([[n2 - 2 * i2, 0], [i2 * s3, 0, i2, a3 - a3 * s3, i2, a3], [0, r2 - 2 * a3], [0, a3 * s3, -i2 * s3, a3, -i2, a3], [2 * i2 - n2, 0], [-i2 * s3, 0, -i2, -a3 * s3, -i2, -a3], [0, 2 * a3 - r2], [0, -a3 * s3, i2 * s3, -a3, i2, -a3]], t2 + i2, e2, [1, 1], o2, true), this;
  }, y3.__private__.ellipse = y3.ellipse = function(t2, e2, n2, r2, i2) {
    if (isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2) || !qe2(i2)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a3 = 4 / 3 * (Math.SQRT2 - 1) * n2, o2 = 4 / 3 * (Math.SQRT2 - 1) * r2;
    return We2(t2 + n2, e2), Ge2(t2 + n2, e2 - o2, t2 + a3, e2 - r2, t2, e2 - r2), Ge2(t2 - a3, e2 - r2, t2 - n2, e2 - o2, t2 - n2, e2), Ge2(t2 - n2, e2 + o2, t2 - a3, e2 + r2, t2, e2 + r2), Ge2(t2 + a3, e2 + r2, t2 + n2, e2 + o2, t2 + n2, e2), Te2(i2), this;
  }, y3.__private__.circle = y3.circle = function(t2, e2, n2, r2) {
    if (isNaN(t2) || isNaN(e2) || isNaN(n2) || !qe2(r2)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t2, e2, n2, n2, r2);
  }, y3.setFont = function(t2, e2, n2) {
    return n2 && (e2 = F14(e2, n2)), At2 = Ne3(t2, e2, { disableWarning: false }), this;
  };
  var Ye = y3.__private__.getFont = y3.getFont = function() {
    return Ft3[Ne3.apply(y3, arguments)];
  };
  y3.__private__.getFontList = y3.getFontList = function() {
    var t2, e2, n2 = {};
    for (t2 in It2) if (It2.hasOwnProperty(t2)) for (e2 in n2[t2] = [], It2[t2]) It2[t2].hasOwnProperty(e2) && n2[t2].push(e2);
    return n2;
  }, y3.addFont = function(t2, e2, n2, r2, i2) {
    var a3 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && -1 !== a3.indexOf(arguments[3]) ? i2 = arguments[3] : arguments[3] && -1 == a3.indexOf(arguments[3]) && (n2 = F14(n2, r2)), pe3.call(this, t2, e2, n2, i2 = i2 || "Identity-H");
  };
  var Je2, Xe2 = e.lineWidth || 0.200025, Ke2 = y3.__private__.getLineWidth = y3.getLineWidth = function() {
    return Xe2;
  }, Ze2 = y3.__private__.setLineWidth = y3.setLineWidth = function(t2) {
    return Xe2 = t2, lt2(B4(U4(t2)) + " w"), this;
  };
  y3.__private__.setLineDash = E3.API.setLineDash = E3.API.setLineDashPattern = function(t2, e2) {
    if (t2 = t2 || [], e2 = e2 || 0, isNaN(e2) || !Array.isArray(t2)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t2 = t2.map(function(t3) {
      return B4(U4(t3));
    }).join(" "), e2 = B4(U4(e2)), lt2("[" + t2 + "] " + e2 + " d"), this;
  };
  var $e2 = y3.__private__.getLineHeight = y3.getLineHeight = function() {
    return pt2 * Je2;
  };
  y3.__private__.getLineHeight = y3.getLineHeight = function() {
    return pt2 * Je2;
  };
  var Qe2 = y3.__private__.setLineHeightFactor = y3.setLineHeightFactor = function(t2) {
    return "number" == typeof (t2 = t2 || 1.15) && (Je2 = t2), this;
  }, tn = y3.__private__.getLineHeightFactor = y3.getLineHeightFactor = function() {
    return Je2;
  };
  Qe2(e.lineHeight);
  var en = y3.__private__.getHorizontalCoordinate = function(t2) {
    return U4(t2);
  }, nn = y3.__private__.getVerticalCoordinate = function(t2) {
    return _3 === S4 ? t2 : Rt2[$3].mediaBox.topRightY - Rt2[$3].mediaBox.bottomLeftY - U4(t2);
  }, rn = y3.__private__.getHorizontalCoordinateString = y3.getHorizontalCoordinateString = function(t2) {
    return B4(en(t2));
  }, an = y3.__private__.getVerticalCoordinateString = y3.getVerticalCoordinateString = function(t2) {
    return B4(nn(t2));
  }, on = e.strokeColor || "0 G";
  y3.__private__.getStrokeColor = y3.getDrawColor = function() {
    return ee2(on);
  }, y3.__private__.setStrokeColor = y3.setDrawColor = function(t2, e2, n2, r2) {
    return on = ne3({ ch1: t2, ch2: e2, ch3: n2, ch4: r2, pdfColorType: "draw", precision: 2 }), lt2(on), this;
  };
  var sn = e.fillColor || "0 g";
  y3.__private__.getFillColor = y3.getFillColor = function() {
    return ee2(sn);
  }, y3.__private__.setFillColor = y3.setFillColor = function(t2, e2, n2, r2) {
    return sn = ne3({ ch1: t2, ch2: e2, ch3: n2, ch4: r2, pdfColorType: "fill", precision: 2 }), lt2(sn), this;
  };
  var un = e.textColor || "0 g", cn = y3.__private__.getTextColor = y3.getTextColor = function() {
    return ee2(un);
  };
  y3.__private__.setTextColor = y3.setTextColor = function(t2, e2, n2, r2) {
    return un = ne3({ ch1: t2, ch2: e2, ch3: n2, ch4: r2, pdfColorType: "text", precision: 3 }), this;
  };
  var ln2 = e.charSpace, hn = y3.__private__.getCharSpace = y3.getCharSpace = function() {
    return parseFloat(ln2 || 0);
  };
  y3.__private__.setCharSpace = y3.setCharSpace = function(t2) {
    if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return ln2 = t2, this;
  };
  var fn = 0;
  y3.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y3.__private__.setLineCap = y3.setLineCap = function(t2) {
    var e2 = y3.CapJoinStyles[t2];
    if (void 0 === e2) throw new Error("Line cap style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return fn = e2, lt2(e2 + " J"), this;
  };
  var dn = 0;
  y3.__private__.setLineJoin = y3.setLineJoin = function(t2) {
    var e2 = y3.CapJoinStyles[t2];
    if (void 0 === e2) throw new Error("Line join style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return dn = e2, lt2(e2 + " j"), this;
  }, y3.__private__.setLineMiterLimit = y3.__private__.setMiterLimit = y3.setLineMiterLimit = y3.setMiterLimit = function(t2) {
    if (t2 = t2 || 0, isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt2(B4(U4(t2)) + " M"), this;
  }, y3.GState = O2, y3.setGState = function(t2) {
    (t2 = "string" == typeof t2 ? Bt2[Mt2[t2]] : pn(null, t2)).equals(qt2) || (lt2("/" + t2.id + " gs"), qt2 = t2);
  };
  var pn = function(t2, e2) {
    if (!t2 || !Mt2[t2]) {
      var n2 = false;
      for (var r2 in Bt2) if (Bt2.hasOwnProperty(r2) && Bt2[r2].equals(e2)) {
        n2 = true;
        break;
      }
      if (n2) e2 = Bt2[r2];
      else {
        var i2 = "GS" + (Object.keys(Bt2).length + 1).toString(10);
        Bt2[i2] = e2, e2.id = i2;
      }
      return t2 && (Mt2[t2] = e2.id), Dt2.publish("addGState", e2), e2;
    }
  };
  y3.addGState = function(t2, e2) {
    return pn(t2, e2), this;
  }, y3.saveGraphicsState = function() {
    return lt2("q"), jt2.push({ key: At2, size: pt2, color: un }), this;
  }, y3.restoreGraphicsState = function() {
    lt2("Q");
    var t2 = jt2.pop();
    return At2 = t2.key, pt2 = t2.size, un = t2.color, qt2 = null, this;
  }, y3.setCurrentTransformationMatrix = function(t2) {
    return lt2(t2.toString() + " cm"), this;
  }, y3.comment = function(t2) {
    return lt2("#" + t2), this;
  };
  var gn = function(t2, e2) {
    var n2 = t2 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return n2;
    }, set: function(t3) {
      isNaN(t3) || (n2 = parseFloat(t3));
    } });
    var r2 = e2 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return r2;
    }, set: function(t3) {
      isNaN(t3) || (r2 = parseFloat(t3));
    } });
    var i2 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i2;
    }, set: function(t3) {
      i2 = t3.toString();
    } }), this;
  }, mn = function(t2, e2, n2, r2) {
    gn.call(this, t2, e2), this.type = "rect";
    var i2 = n2 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i2;
    }, set: function(t3) {
      isNaN(t3) || (i2 = parseFloat(t3));
    } });
    var a3 = r2 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a3;
    }, set: function(t3) {
      isNaN(t3) || (a3 = parseFloat(t3));
    } }), this;
  }, vn = function() {
    this.page = Et2, this.currentPage = $3, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = _t2, this.y = Pt2, this.matrix = kt2, this.width = wn($3), this.height = Ln($3), this.outputDestination = ut2, this.id = "", this.objectNumber = -1;
  };
  vn.prototype.restore = function() {
    Et2 = this.page, $3 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, _t2 = this.x, Pt2 = this.y, kt2 = this.matrix, Nn($3, this.width), xn($3, this.height), ut2 = this.outputDestination;
  };
  var bn = function(t2, e2, n2, r2, i2) {
    Ht3.push(new vn()), Et2 = $3 = 0, ot2 = [], _t2 = t2, Pt2 = e2, kt2 = i2, me2([n2, r2]);
  };
  for (var yn in y3.beginFormObject = function(t2, e2, n2, r2, i2) {
    return bn(t2, e2, n2, r2, i2), this;
  }, y3.endFormObject = function(t2) {
    return (function(t3) {
      if (Ut3[t3]) Ht3.pop().restore();
      else {
        var e2 = new vn(), n2 = "Xo" + (Object.keys(zt2).length + 1).toString(10);
        e2.id = n2, Ut3[t3] = n2, zt2[n2] = e2, Dt2.publish("addFormObject", e2), Ht3.pop().restore();
      }
    })(t2), this;
  }, y3.doFormObject = function(t2, e2) {
    var n2 = zt2[Ut3[t2]];
    return lt2("q"), lt2(e2.toString() + " cm"), lt2("/" + n2.id + " Do"), lt2("Q"), this;
  }, y3.getFormObject = function(t2) {
    var e2 = zt2[Ut3[t2]];
    return { x: e2.x, y: e2.y, width: e2.width, height: e2.height, matrix: e2.matrix };
  }, y3.save = function(t2, e2) {
    return t2 = t2 || "generated.pdf", (e2 = e2 || {}).returnPromise = e2.returnPromise || false, false === e2.returnPromise ? (l3(ke3(Pe3()), t2), "function" == typeof l3.unload && i.setTimeout && setTimeout(l3.unload, 911), this) : new Promise(function(e3, n2) {
      try {
        var r2 = l3(ke3(Pe3()), t2);
        "function" == typeof l3.unload && i.setTimeout && setTimeout(l3.unload, 911), e3(r2);
      } catch (a3) {
        n2(a3.message);
      }
    });
  }, E3.API) E3.API.hasOwnProperty(yn) && ("events" === yn && E3.API.events.length ? (function(t2, e2) {
    var n2, r2, i2;
    for (i2 = e2.length - 1; -1 !== i2; i2--) n2 = e2[i2][0], r2 = e2[i2][1], t2.subscribe.apply(t2, [n2].concat("function" == typeof r2 ? [r2] : r2));
  })(Dt2, E3.API.events) : y3[yn] = E3.API[yn]);
  function wn(t2) {
    return Rt2[t2].mediaBox.topRightX - Rt2[t2].mediaBox.bottomLeftX;
  }
  function Nn(t2, e2) {
    Rt2[t2].mediaBox.topRightX = e2 + Rt2[t2].mediaBox.bottomLeftX;
  }
  function Ln(t2) {
    return Rt2[t2].mediaBox.topRightY - Rt2[t2].mediaBox.bottomLeftY;
  }
  function xn(t2, e2) {
    Rt2[t2].mediaBox.topRightY = e2 + Rt2[t2].mediaBox.bottomLeftY;
  }
  var An = y3.getPageWidth = function(t2) {
    return wn(t2 = t2 || $3) / St2;
  }, Sn = y3.setPageWidth = function(t2, e2) {
    Nn(t2, e2 * St2);
  }, _n = y3.getPageHeight = function(t2) {
    return Ln(t2 = t2 || $3) / St2;
  }, Pn = y3.setPageHeight = function(t2, e2) {
    xn(t2, e2 * St2);
  };
  return y3.internal = { pdfEscape: ge3, getStyle: Ee2, getFont: Ye, getFontSize: mt2, getCharSpace: hn, getTextColor: cn, getLineHeight: $e2, getLineHeightFactor: tn, getLineWidth: Ke2, write: ht2, getHorizontalCoordinate: en, getVerticalCoordinate: nn, getCoordinateString: rn, getVerticalCoordinateString: an, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt3, getFilters: re3, putStream: ie3, events: Dt2, scaleFactor: St2, pageSize: { getWidth: function() {
    return An($3);
  }, setWidth: function(t2) {
    Sn($3, t2);
  }, getHeight: function() {
    return _n($3);
  }, setHeight: function(t2) {
    Pn($3, t2);
  } }, encryptionOptions: m3, encryption: je3, getEncryptor: function(t2) {
    return null !== m3 ? je3.encryptor(t2, 0) : function(t3) {
      return t3;
    };
  }, output: Fe3, getNumberOfPages: we3, pages: ot2, out: lt2, f2: T4, f3: z3, getPageInfo: Ce2, getPageInfoByObjId: Oe2, getCurrentPageInfo: Be2, getPDFVersion: N4, Point: gn, Rectangle: mn, Matrix: Wt2, hasHotfix: Ie3 }, Object.defineProperty(y3.internal.pageSize, "width", { get: function() {
    return An($3);
  }, set: function(t2) {
    Sn($3, t2);
  }, enumerable: true, configurable: true }), Object.defineProperty(y3.internal.pageSize, "height", { get: function() {
    return _n($3);
  }, set: function(t2) {
    Pn($3, t2);
  }, enumerable: true, configurable: true }), (function(t2) {
    for (var e2 = 0, n2 = dt2.length; e2 < n2; e2++) {
      var r2 = pe3.call(this, t2[e2][0], t2[e2][1], t2[e2][2], dt2[e2][3], true);
      false === v3 && (b3[r2] = true);
      var i2 = t2[e2][0].split("-");
      de3({ id: r2, fontName: i2[0], fontStyle: i2[1] || "" });
    }
    Dt2.publish("addFonts", { fonts: Ft3, dictionary: It2 });
  }).call(y3, dt2), At2 = "F1", ve3(s2, r), Dt2.publish("initialized"), y3;
}
function _t(t2) {
  return t2.reduce(function(t3, e, n) {
    return t3[e] = n, t3;
  }, {});
}
function Ct(t2) {
  var e = t2.family.replace(/"|'/g, "").toLowerCase(), n = (function(t3) {
    return Pt[t3 = t3 || "normal"] ? t3 : "normal";
  })(t2.style), r = (function(t3) {
    return t3 ? "number" == typeof t3 ? t3 >= 100 && t3 <= 900 && t3 % 100 == 0 ? t3 : 400 : /^\d00$/.test(t3) ? parseInt(t3) : "bold" === t3 ? 700 : 400 : 400;
  })(t2.weight), i2 = (function(t3) {
    return "number" == typeof Ft2[t3 = t3 || "normal"] ? t3 : "normal";
  })(t2.stretch);
  return { family: e, style: n, weight: r, stretch: i2, src: t2.src || [], ref: t2.ref || { name: e, style: [i2, n, r].join(" ") } };
}
function Ot(t2, e, n, r) {
  var i2;
  for (i2 = n; i2 >= 0 && i2 < e.length; i2 += r) if (t2[e[i2]]) return t2[e[i2]];
  for (i2 = n; i2 >= 0 && i2 < e.length; i2 -= r) if (t2[e[i2]]) return t2[e[i2]];
}
function qt(t2) {
  return [t2.stretch, t2.style, t2.weight, t2.family].join(" ");
}
function Et(t2) {
  return t2.trimLeft();
}
function Rt(t2, e) {
  for (var n = 0; n < t2.length; ) {
    if (t2.charAt(n) === e) return [t2.substring(0, n), t2.substring(n + 1)];
    n += 1;
  }
  return null;
}
function Dt(t2) {
  var e = t2.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return null === e ? null : [e[0], t2.substring(e[0].length)];
}
function Xt(t2, n, r, i2, a2) {
  var o2 = 4, s2 = $t;
  switch (a2) {
    case E3.API.image_compression.FAST:
      o2 = 1, s2 = Zt2;
      break;
    case E3.API.image_compression.MEDIUM:
      o2 = 6, s2 = Qt2;
      break;
    case E3.API.image_compression.SLOW:
      o2 = 9, s2 = te;
  }
  t2 = (function(t3, e, n2, r2) {
    for (var i3, a3 = t3.length / e, o3 = new Uint8Array(t3.length + a3), s3 = [Kt, Zt2, $t, Qt2, te], u3 = 0; u3 < a3; u3 += 1) {
      var c2 = u3 * e, l4 = t3.subarray(c2, c2 + e);
      if (r2) o3.set(r2(l4, n2, i3), c2 + u3);
      else {
        for (var h2 = s3.length, f2 = [], d3 = 0; d3 < h2; d3 += 1) f2[d3] = s3[d3](l4, n2, i3);
        var p2 = ne2(f2.concat());
        o3.set(f2[p2], c2 + u3);
      }
      i3 = l4;
    }
    return o3;
  })(t2, n, Math.ceil(r * i2 / 8), s2);
  var u2 = zlibSync(t2, { level: o2 });
  return E3.API.__addimage__.arrayBufferToBinaryString(u2);
}
function Kt(t2) {
  var e = Array.apply([], t2);
  return e.unshift(0), e;
}
function Zt2(t2, e) {
  var n = t2.length, r = [];
  r[0] = 1;
  for (var i2 = 0; i2 < n; i2 += 1) {
    var a2 = t2[i2 - e] || 0;
    r[i2 + 1] = t2[i2] - a2 + 256 & 255;
  }
  return r;
}
function $t(t2, e, n) {
  var r = t2.length, i2 = [];
  i2[0] = 2;
  for (var a2 = 0; a2 < r; a2 += 1) {
    var o2 = n && n[a2] || 0;
    i2[a2 + 1] = t2[a2] - o2 + 256 & 255;
  }
  return i2;
}
function Qt2(t2, e, n) {
  var r = t2.length, i2 = [];
  i2[0] = 3;
  for (var a2 = 0; a2 < r; a2 += 1) {
    var o2 = t2[a2 - e] || 0, s2 = n && n[a2] || 0;
    i2[a2 + 1] = t2[a2] + 256 - (o2 + s2 >>> 1) & 255;
  }
  return i2;
}
function te(t2, e, n) {
  var r = t2.length, i2 = [];
  i2[0] = 4;
  for (var a2 = 0; a2 < r; a2 += 1) {
    var o2 = ee(t2[a2 - e] || 0, n && n[a2] || 0, n && n[a2 - e] || 0);
    i2[a2 + 1] = t2[a2] - o2 + 256 & 255;
  }
  return i2;
}
function ee(t2, e, n) {
  if (t2 === e && e === n) return t2;
  var r = Math.abs(e - n), i2 = Math.abs(t2 - n), a2 = Math.abs(t2 + e - n - n);
  return r <= i2 && r <= a2 ? t2 : i2 <= a2 ? e : n;
}
function ne2(t2) {
  var e = t2.map(function(t3) {
    return t3.reduce(function(t4, e2) {
      return t4 + Math.abs(e2);
    }, 0);
  });
  return e.indexOf(Math.min.apply(null, e));
}
function re2(t2, e, n) {
  var r = e * n, i2 = Math.floor(r / 8), a2 = 16 - (r - 8 * i2 + n), o2 = (1 << n) - 1;
  return ae2(t2, i2) >> a2 & o2;
}
function ie2(t2, e, n, r) {
  var i2 = n * r, a2 = Math.floor(i2 / 8), o2 = 16 - (i2 - 8 * a2 + r), s2 = (1 << r) - 1, u2 = (e & s2) << o2;
  !(function(t3, e2, n2) {
    if (e2 + 1 < t3.byteLength) t3.setUint16(e2, n2, false);
    else {
      var r2 = n2 >> 8 & 255;
      t3.setUint8(e2, r2);
    }
  })(t2, a2, ae2(t2, a2) & ~(s2 << o2) & 65535 | u2);
}
function ae2(t2, e) {
  return e + 1 < t2.byteLength ? t2.getUint16(e, false) : t2.getUint8(e) << 8;
}
function oe2(t2) {
  var e = 0;
  if (71 !== t2[e++] || 73 !== t2[e++] || 70 !== t2[e++] || 56 !== t2[e++] || 56 != (t2[e++] + 1 & 253) || 97 !== t2[e++]) throw new Error("Invalid GIF 87a/89a header.");
  var n = t2[e++] | t2[e++] << 8, r = t2[e++] | t2[e++] << 8, i2 = t2[e++], a2 = i2 >> 7, o2 = 1 << 1 + (7 & i2);
  t2[e++], t2[e++];
  var s2 = null, u2 = null;
  a2 && (s2 = e, u2 = o2, e += 3 * o2);
  var c2 = true, l4 = [], h2 = 0, f2 = null, d3 = 0, p2 = null;
  for (this.width = n, this.height = r; c2 && e < t2.length; ) switch (t2[e++]) {
    case 33:
      switch (t2[e++]) {
        case 255:
          if (11 !== t2[e] || 78 == t2[e + 1] && 69 == t2[e + 2] && 84 == t2[e + 3] && 83 == t2[e + 4] && 67 == t2[e + 5] && 65 == t2[e + 6] && 80 == t2[e + 7] && 69 == t2[e + 8] && 50 == t2[e + 9] && 46 == t2[e + 10] && 48 == t2[e + 11] && 3 == t2[e + 12] && 1 == t2[e + 13] && 0 == t2[e + 16]) e += 14, p2 = t2[e++] | t2[e++] << 8, e++;
          else for (e += 12; ; ) {
            if (!((P4 = t2[e++]) >= 0)) throw Error("Invalid block size");
            if (0 === P4) break;
            e += P4;
          }
          break;
        case 249:
          if (4 !== t2[e++] || 0 !== t2[e + 4]) throw new Error("Invalid graphics extension block.");
          var g2 = t2[e++];
          h2 = t2[e++] | t2[e++] << 8, f2 = t2[e++], 1 & g2 || (f2 = null), d3 = g2 >> 2 & 7, e++;
          break;
        case 254:
          for (; ; ) {
            if (!((P4 = t2[e++]) >= 0)) throw Error("Invalid block size");
            if (0 === P4) break;
            e += P4;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + t2[e - 1].toString(16));
      }
      break;
    case 44:
      var m3 = t2[e++] | t2[e++] << 8, v3 = t2[e++] | t2[e++] << 8, b3 = t2[e++] | t2[e++] << 8, y3 = t2[e++] | t2[e++] << 8, w3 = t2[e++], N4 = w3 >> 6 & 1, L4 = 1 << 1 + (7 & w3), x3 = s2, A3 = u2, S4 = false;
      w3 >> 7 && (S4 = true, x3 = e, A3 = L4, e += 3 * L4);
      var _3 = e;
      for (e++; ; ) {
        var P4;
        if (!((P4 = t2[e++]) >= 0)) throw Error("Invalid block size");
        if (0 === P4) break;
        e += P4;
      }
      l4.push({ x: m3, y: v3, width: b3, height: y3, has_local_palette: S4, palette_offset: x3, palette_size: A3, data_offset: _3, data_length: e - _3, transparent_index: f2, interlaced: !!N4, delay: h2, disposal: d3 });
      break;
    case 59:
      c2 = false;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + t2[e - 1].toString(16));
  }
  this.numFrames = function() {
    return l4.length;
  }, this.loopCount = function() {
    return p2;
  }, this.frameInfo = function(t3) {
    if (t3 < 0 || t3 >= l4.length) throw new Error("Frame index out of range.");
    return l4[t3];
  }, this.decodeAndBlitFrameBGRA = function(e2, r2) {
    var i3 = this.frameInfo(e2), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    se2(t2, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, u3 = i3.transparent_index;
    null === u3 && (u3 = 256);
    var c3 = i3.width, l5 = n - c3, h3 = c3, f3 = 4 * (i3.y * n + i3.x), d4 = 4 * ((i3.y + i3.height) * n + i3.x), p3 = f3, g3 = 4 * l5;
    true === i3.interlaced && (g3 += 4 * n * 7);
    for (var m4 = 8, v4 = 0, b4 = o3.length; v4 < b4; ++v4) {
      var y4 = o3[v4];
      if (0 === h3 && (h3 = c3, (p3 += g3) >= d4 && (g3 = 4 * l5 + 4 * n * (m4 - 1), p3 = f3 + (c3 + l5) * (m4 << 1), m4 >>= 1)), y4 === u3) p3 += 4;
      else {
        var w4 = t2[s3 + 3 * y4], N5 = t2[s3 + 3 * y4 + 1], L5 = t2[s3 + 3 * y4 + 2];
        r2[p3++] = L5, r2[p3++] = N5, r2[p3++] = w4, r2[p3++] = 255;
      }
      --h3;
    }
  }, this.decodeAndBlitFrameRGBA = function(e2, r2) {
    var i3 = this.frameInfo(e2), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    se2(t2, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, u3 = i3.transparent_index;
    null === u3 && (u3 = 256);
    var c3 = i3.width, l5 = n - c3, h3 = c3, f3 = 4 * (i3.y * n + i3.x), d4 = 4 * ((i3.y + i3.height) * n + i3.x), p3 = f3, g3 = 4 * l5;
    true === i3.interlaced && (g3 += 4 * n * 7);
    for (var m4 = 8, v4 = 0, b4 = o3.length; v4 < b4; ++v4) {
      var y4 = o3[v4];
      if (0 === h3 && (h3 = c3, (p3 += g3) >= d4 && (g3 = 4 * l5 + 4 * n * (m4 - 1), p3 = f3 + (c3 + l5) * (m4 << 1), m4 >>= 1)), y4 === u3) p3 += 4;
      else {
        var w4 = t2[s3 + 3 * y4], N5 = t2[s3 + 3 * y4 + 1], L5 = t2[s3 + 3 * y4 + 2];
        r2[p3++] = w4, r2[p3++] = N5, r2[p3++] = L5, r2[p3++] = 255;
      }
      --h3;
    }
  };
}
function se2(t2, e, n, r) {
  for (var i2 = t2[e++], a2 = 1 << i2, s2 = a2 + 1, u2 = s2 + 1, c2 = i2 + 1, l4 = (1 << c2) - 1, h2 = 0, f2 = 0, d3 = 0, p2 = t2[e++], g2 = new Int32Array(4096), m3 = null; ; ) {
    for (; h2 < 16 && 0 !== p2; ) f2 |= t2[e++] << h2, h2 += 8, 1 === p2 ? p2 = t2[e++] : --p2;
    if (h2 < c2) break;
    var v3 = f2 & l4;
    if (f2 >>= c2, h2 -= c2, v3 !== a2) {
      if (v3 === s2) break;
      for (var b3 = v3 < u2 ? v3 : m3, y3 = 0, w3 = b3; w3 > a2; ) w3 = g2[w3] >> 8, ++y3;
      var N4 = w3;
      if (d3 + y3 + (b3 !== v3 ? 1 : 0) > r) return void o.log("Warning, gif stream longer than expected.");
      n[d3++] = N4;
      var L4 = d3 += y3;
      for (b3 !== v3 && (n[d3++] = N4), w3 = b3; y3--; ) w3 = g2[w3], n[--L4] = 255 & w3, w3 >>= 8;
      null !== m3 && u2 < 4096 && (g2[u2++] = m3 << 8 | N4, u2 >= l4 + 1 && c2 < 12 && (++c2, l4 = l4 << 1 | 1)), m3 = v3;
    } else u2 = s2 + 1, l4 = (1 << (c2 = i2 + 1)) - 1, m3 = null;
  }
  return d3 !== r && o.log("Warning, gif stream shorter than expected."), n;
}
function ue2(t2) {
  var e, n, r, i2, a2, o2 = Math.floor, s2 = new Array(64), u2 = new Array(64), c2 = new Array(64), l4 = new Array(64), h2 = new Array(65535), f2 = new Array(65535), d3 = new Array(64), p2 = new Array(64), g2 = [], m3 = 0, v3 = 7, b3 = new Array(64), y3 = new Array(64), w3 = new Array(64), N4 = new Array(256), L4 = new Array(2048), x3 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], A3 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S4 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _3 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P4 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k3 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], F14 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], I4 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], j3 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function C4(t3, e2) {
    for (var n2 = 0, r2 = 0, i3 = new Array(), a3 = 1; a3 <= 16; a3++) {
      for (var o3 = 1; o3 <= t3[a3]; o3++) i3[e2[r2]] = [], i3[e2[r2]][0] = n2, i3[e2[r2]][1] = a3, r2++, n2++;
      n2 *= 2;
    }
    return i3;
  }
  function O3(t3) {
    for (var e2 = t3[0], n2 = t3[1] - 1; n2 >= 0; ) e2 & 1 << n2 && (m3 |= 1 << v3), n2--, --v3 < 0 && (255 == m3 ? (B4(255), B4(0)) : B4(m3), v3 = 7, m3 = 0);
  }
  function B4(t3) {
    g2.push(t3);
  }
  function M4(t3) {
    B4(t3 >> 8 & 255), B4(255 & t3);
  }
  function q3(t3, e2, n2, r2, i3) {
    for (var a3, o3 = i3[0], s3 = i3[240], u3 = (function(t4, e3) {
      var n3, r3, i4, a4, o4, s4, u4, c4, l6, h3, f3 = 0;
      for (l6 = 0; l6 < 8; ++l6) {
        n3 = t4[f3], r3 = t4[f3 + 1], i4 = t4[f3 + 2], a4 = t4[f3 + 3], o4 = t4[f3 + 4], s4 = t4[f3 + 5], u4 = t4[f3 + 6];
        var p3 = n3 + (c4 = t4[f3 + 7]), g4 = n3 - c4, m5 = r3 + u4, v5 = r3 - u4, b5 = i4 + s4, y5 = i4 - s4, w5 = a4 + o4, N5 = a4 - o4, L5 = p3 + w5, x4 = p3 - w5, A4 = m5 + b5, S5 = m5 - b5;
        t4[f3] = L5 + A4, t4[f3 + 4] = L5 - A4;
        var _4 = 0.707106781 * (S5 + x4);
        t4[f3 + 2] = x4 + _4, t4[f3 + 6] = x4 - _4;
        var P5 = 0.382683433 * ((L5 = N5 + y5) - (S5 = v5 + g4)), k4 = 0.5411961 * L5 + P5, F15 = 1.306562965 * S5 + P5, I5 = 0.707106781 * (A4 = y5 + v5), j4 = g4 + I5, C5 = g4 - I5;
        t4[f3 + 5] = C5 + k4, t4[f3 + 3] = C5 - k4, t4[f3 + 1] = j4 + F15, t4[f3 + 7] = j4 - F15, f3 += 8;
      }
      for (f3 = 0, l6 = 0; l6 < 8; ++l6) {
        n3 = t4[f3], r3 = t4[f3 + 8], i4 = t4[f3 + 16], a4 = t4[f3 + 24], o4 = t4[f3 + 32], s4 = t4[f3 + 40], u4 = t4[f3 + 48];
        var O4 = n3 + (c4 = t4[f3 + 56]), B5 = n3 - c4, M5 = r3 + u4, q4 = r3 - u4, E5 = i4 + s4, R3 = i4 - s4, D4 = a4 + o4, T4 = a4 - o4, z3 = O4 + D4, U4 = O4 - D4, H3 = M5 + E5, W4 = M5 - E5;
        t4[f3] = z3 + H3, t4[f3 + 32] = z3 - H3;
        var V4 = 0.707106781 * (W4 + U4);
        t4[f3 + 16] = U4 + V4, t4[f3 + 48] = U4 - V4;
        var G4 = 0.382683433 * ((z3 = T4 + R3) - (W4 = q4 + B5)), Y3 = 0.5411961 * z3 + G4, J4 = 1.306562965 * W4 + G4, X4 = 0.707106781 * (H3 = R3 + q4), K4 = B5 + X4, Z3 = B5 - X4;
        t4[f3 + 40] = Z3 + Y3, t4[f3 + 24] = Z3 - Y3, t4[f3 + 8] = K4 + J4, t4[f3 + 56] = K4 - J4, f3++;
      }
      for (l6 = 0; l6 < 64; ++l6) h3 = t4[l6] * e3[l6], d3[l6] = h3 > 0 ? h3 + 0.5 | 0 : h3 - 0.5 | 0;
      return d3;
    })(t3, e2), c3 = 0; c3 < 64; ++c3) p2[x3[c3]] = u3[c3];
    var l5 = p2[0] - n2;
    n2 = p2[0], 0 == l5 ? O3(r2[0]) : (O3(r2[f2[a3 = 32767 + l5]]), O3(h2[a3]));
    for (var g3 = 63; g3 > 0 && 0 == p2[g3]; ) g3--;
    if (0 == g3) return O3(o3), n2;
    for (var m4, v4 = 1; v4 <= g3; ) {
      for (var b4 = v4; 0 == p2[v4] && v4 <= g3; ) ++v4;
      var y4 = v4 - b4;
      if (y4 >= 16) {
        m4 = y4 >> 4;
        for (var w4 = 1; w4 <= m4; ++w4) O3(s3);
        y4 &= 15;
      }
      a3 = 32767 + p2[v4], O3(i3[(y4 << 4) + f2[a3]]), O3(h2[a3]), v4++;
    }
    return 63 != g3 && O3(o3), n2;
  }
  function E4(t3) {
    t3 = Math.min(Math.max(t3, 1), 100), a2 != t3 && ((function(t4) {
      for (var e2 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], n2 = 0; n2 < 64; n2++) {
        var r2 = o2((e2[n2] * t4 + 50) / 100);
        r2 = Math.min(Math.max(r2, 1), 255), s2[x3[n2]] = r2;
      }
      for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
        var h3 = o2((i3[a3] * t4 + 50) / 100);
        h3 = Math.min(Math.max(h3, 1), 255), u2[x3[a3]] = h3;
      }
      for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d4 = 0, p3 = 0; p3 < 8; p3++) for (var g3 = 0; g3 < 8; g3++) c2[d4] = 1 / (s2[x3[d4]] * f3[p3] * f3[g3] * 8), l4[d4] = 1 / (u2[x3[d4]] * f3[p3] * f3[g3] * 8), d4++;
    })(t3 < 50 ? Math.floor(5e3 / t3) : Math.floor(200 - 2 * t3)), a2 = t3);
  }
  this.encode = function(t3, a3) {
    a3 && E4(a3), g2 = new Array(), m3 = 0, v3 = 7, M4(65496), M4(65504), M4(16), B4(74), B4(70), B4(73), B4(70), B4(0), B4(1), B4(1), B4(0), M4(1), M4(1), B4(0), B4(0), (function() {
      M4(65499), M4(132), B4(0);
      for (var t4 = 0; t4 < 64; t4++) B4(s2[t4]);
      B4(1);
      for (var e2 = 0; e2 < 64; e2++) B4(u2[e2]);
    })(), (function(t4, e2) {
      M4(65472), M4(17), B4(8), M4(e2), M4(t4), B4(3), B4(1), B4(17), B4(0), B4(2), B4(17), B4(1), B4(3), B4(17), B4(1);
    })(t3.width, t3.height), (function() {
      M4(65476), M4(418), B4(0);
      for (var t4 = 0; t4 < 16; t4++) B4(A3[t4 + 1]);
      for (var e2 = 0; e2 <= 11; e2++) B4(S4[e2]);
      B4(16);
      for (var n2 = 0; n2 < 16; n2++) B4(_3[n2 + 1]);
      for (var r2 = 0; r2 <= 161; r2++) B4(P4[r2]);
      B4(1);
      for (var i3 = 0; i3 < 16; i3++) B4(k3[i3 + 1]);
      for (var a4 = 0; a4 <= 11; a4++) B4(F14[a4]);
      B4(17);
      for (var o4 = 0; o4 < 16; o4++) B4(I4[o4 + 1]);
      for (var s3 = 0; s3 <= 161; s3++) B4(j3[s3]);
    })(), M4(65498), M4(12), B4(3), B4(1), B4(0), B4(2), B4(17), B4(3), B4(17), B4(0), B4(63), B4(0);
    var o3 = 0, h3 = 0, f3 = 0;
    m3 = 0, v3 = 7, this.encode.displayName = "_encode_";
    for (var d4, p3, N5, x4, C5, R3, D4, T4, z3, U4 = t3.data, H3 = t3.width, W4 = t3.height, V4 = 4 * H3, G4 = 0; G4 < W4; ) {
      for (d4 = 0; d4 < V4; ) {
        for (C5 = V4 * G4 + d4, D4 = -1, T4 = 0, z3 = 0; z3 < 64; z3++) R3 = C5 + (T4 = z3 >> 3) * V4 + (D4 = 4 * (7 & z3)), G4 + T4 >= W4 && (R3 -= V4 * (G4 + 1 + T4 - W4)), d4 + D4 >= V4 && (R3 -= d4 + D4 - V4 + 4), p3 = U4[R3++], N5 = U4[R3++], x4 = U4[R3++], b3[z3] = (L4[p3] + L4[N5 + 256 | 0] + L4[x4 + 512 | 0] >> 16) - 128, y3[z3] = (L4[p3 + 768 | 0] + L4[N5 + 1024 | 0] + L4[x4 + 1280 | 0] >> 16) - 128, w3[z3] = (L4[p3 + 1280 | 0] + L4[N5 + 1536 | 0] + L4[x4 + 1792 | 0] >> 16) - 128;
        o3 = q3(b3, c2, o3, e, r), h3 = q3(y3, l4, h3, n, i2), f3 = q3(w3, l4, f3, n, i2), d4 += 32;
      }
      G4 += 8;
    }
    if (v3 >= 0) {
      var Y3 = [];
      Y3[1] = v3 + 1, Y3[0] = (1 << v3 + 1) - 1, O3(Y3);
    }
    return M4(65497), new Uint8Array(g2);
  }, t2 = t2 || 50, (function() {
    for (var t3 = String.fromCharCode, e2 = 0; e2 < 256; e2++) N4[e2] = t3(e2);
  })(), e = C4(A3, S4), n = C4(k3, F14), r = C4(_3, P4), i2 = C4(I4, j3), (function() {
    for (var t3 = 1, e2 = 2, n2 = 1; n2 <= 15; n2++) {
      for (var r2 = t3; r2 < e2; r2++) f2[32767 + r2] = n2, h2[32767 + r2] = [], h2[32767 + r2][1] = n2, h2[32767 + r2][0] = r2;
      for (var i3 = -(e2 - 1); i3 <= -t3; i3++) f2[32767 + i3] = n2, h2[32767 + i3] = [], h2[32767 + i3][1] = n2, h2[32767 + i3][0] = e2 - 1 + i3;
      t3 <<= 1, e2 <<= 1;
    }
  })(), (function() {
    for (var t3 = 0; t3 < 256; t3++) L4[t3] = 19595 * t3, L4[t3 + 256 | 0] = 38470 * t3, L4[t3 + 512 | 0] = 7471 * t3 + 32768, L4[t3 + 768 | 0] = -11059 * t3, L4[t3 + 1024 | 0] = -21709 * t3, L4[t3 + 1280 | 0] = 32768 * t3 + 8421375, L4[t3 + 1536 | 0] = -27439 * t3, L4[t3 + 1792 | 0] = -5329 * t3;
  })(), E4(t2);
}
function ce2(t2, e) {
  if (this.pos = 0, this.buffer = t2, this.datav = new DataView(t2.buffer), this.is_with_alpha = !!e, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag)) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function le2(t2) {
  function e(t3) {
    if (!t3) throw Error("assert :P");
  }
  function n(t3, e2, n2) {
    for (var r2 = 0; 4 > r2; r2++) if (t3[e2 + r2] != n2.charCodeAt(r2)) return true;
    return false;
  }
  function r(t3, e2, n2, r2, i3) {
    for (var a3 = 0; a3 < i3; a3++) t3[e2 + a3] = n2[r2 + a3];
  }
  function i2(t3, e2, n2, r2) {
    for (var i3 = 0; i3 < r2; i3++) t3[e2 + i3] = n2;
  }
  function a2(t3) {
    return new Int32Array(t3);
  }
  function o2(t3, e2) {
    for (var n2 = [], r2 = 0; r2 < t3; r2++) n2.push(new e2());
    return n2;
  }
  function s2(t3, e2) {
    var n2 = [];
    return (function t4(n3, r2, i3) {
      for (var a3 = i3[r2], o3 = 0; o3 < a3 && (n3.push(i3.length > r2 + 1 ? [] : new e2()), !(i3.length < r2 + 1)); o3++) t4(n3[o3], r2 + 1, i3);
    })(n2, 0, t3), n2;
  }
  var u2 = function() {
    var t3 = this;
    function u3(t4, e2) {
      for (var n2 = 1 << e2 - 1 >>> 0; t4 & n2; ) n2 >>>= 1;
      return n2 ? (t4 & n2 - 1) + n2 : t4;
    }
    function c3(t4, n2, r2, i3, a3) {
      e(!(i3 % r2));
      do {
        t4[n2 + (i3 -= r2)] = a3;
      } while (0 < i3);
    }
    function l5(t4, n2, r2, i3, o3) {
      if (e(2328 >= o3), 512 >= o3) var s3 = a2(512);
      else if (null == (s3 = a2(o3))) return 0;
      return (function(t5, n3, r3, i4, o4, s4) {
        var l6, f4, d5 = n3, p4 = 1 << r3, g4 = a2(16), m5 = a2(16);
        for (e(0 != o4), e(null != i4), e(null != t5), e(0 < r3), f4 = 0; f4 < o4; ++f4) {
          if (15 < i4[f4]) return 0;
          ++g4[i4[f4]];
        }
        if (g4[0] == o4) return 0;
        for (m5[1] = 0, l6 = 1; 15 > l6; ++l6) {
          if (g4[l6] > 1 << l6) return 0;
          m5[l6 + 1] = m5[l6] + g4[l6];
        }
        for (f4 = 0; f4 < o4; ++f4) l6 = i4[f4], 0 < i4[f4] && (s4[m5[l6]++] = f4);
        if (1 == m5[15]) return (i4 = new h3()).g = 0, i4.value = s4[0], c3(t5, d5, 1, p4, i4), p4;
        var v5, b5 = -1, y5 = p4 - 1, w5 = 0, N6 = 1, L6 = 1, x5 = 1 << r3;
        for (f4 = 0, l6 = 1, o4 = 2; l6 <= r3; ++l6, o4 <<= 1) {
          if (N6 += L6 <<= 1, 0 > (L6 -= g4[l6])) return 0;
          for (; 0 < g4[l6]; --g4[l6]) (i4 = new h3()).g = l6, i4.value = s4[f4++], c3(t5, d5 + w5, o4, x5, i4), w5 = u3(w5, l6);
        }
        for (l6 = r3 + 1, o4 = 2; 15 >= l6; ++l6, o4 <<= 1) {
          if (N6 += L6 <<= 1, 0 > (L6 -= g4[l6])) return 0;
          for (; 0 < g4[l6]; --g4[l6]) {
            if (i4 = new h3(), (w5 & y5) != b5) {
              for (d5 += x5, v5 = 1 << (b5 = l6) - r3; 15 > b5 && !(0 >= (v5 -= g4[b5])); ) ++b5, v5 <<= 1;
              p4 += x5 = 1 << (v5 = b5 - r3), t5[n3 + (b5 = w5 & y5)].g = v5 + r3, t5[n3 + b5].value = d5 - n3 - b5;
            }
            i4.g = l6 - r3, i4.value = s4[f4++], c3(t5, d5 + (w5 >> r3), o4, x5, i4), w5 = u3(w5, l6);
          }
        }
        return N6 != 2 * m5[15] - 1 ? 0 : p4;
      })(t4, n2, r2, i3, o3, s3);
    }
    function h3() {
      this.value = this.g = 0;
    }
    function f3() {
      this.value = this.g = 0;
    }
    function d4() {
      this.G = o2(5, h3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Rn, f3);
    }
    function p3(t4, n2, r2, i3) {
      e(null != t4), e(null != n2), e(2147483648 > i3), t4.Ca = 254, t4.I = 0, t4.b = -8, t4.Ka = 0, t4.oa = n2, t4.pa = r2, t4.Jd = n2, t4.Yc = r2 + i3, t4.Zc = 4 <= i3 ? r2 + i3 - 4 + 1 : r2, _3(t4);
    }
    function g3(t4, e2) {
      for (var n2 = 0; 0 < e2--; ) n2 |= k3(t4, 128) << e2;
      return n2;
    }
    function m4(t4, e2) {
      var n2 = g3(t4, e2);
      return P4(t4) ? -n2 : n2;
    }
    function v4(t4, n2, r2, i3) {
      var a3, o3 = 0;
      for (e(null != t4), e(null != n2), e(4294967288 > i3), t4.Sb = i3, t4.Ra = 0, t4.u = 0, t4.h = 0, 4 < i3 && (i3 = 4), a3 = 0; a3 < i3; ++a3) o3 += n2[r2 + a3] << 8 * a3;
      t4.Ra = o3, t4.bb = i3, t4.oa = n2, t4.pa = r2;
    }
    function b4(t4) {
      for (; 8 <= t4.u && t4.bb < t4.Sb; ) t4.Ra >>>= 8, t4.Ra += t4.oa[t4.pa + t4.bb] << zn - 8 >>> 0, ++t4.bb, t4.u -= 8;
      x4(t4) && (t4.h = 1, t4.u = 0);
    }
    function y4(t4, n2) {
      if (e(0 <= n2), !t4.h && n2 <= Tn) {
        var r2 = L5(t4) & Dn[n2];
        return t4.u += n2, b4(t4), r2;
      }
      return t4.h = 1, t4.u = 0;
    }
    function w4() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N5() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L5(t4) {
      return t4.Ra >>> (t4.u & zn - 1) >>> 0;
    }
    function x4(t4) {
      return e(t4.bb <= t4.Sb), t4.h || t4.bb == t4.Sb && t4.u > zn;
    }
    function A4(t4, e2) {
      t4.u = e2, t4.h = x4(t4);
    }
    function S4(t4) {
      t4.u >= Un && (e(t4.u >= Un), b4(t4));
    }
    function _3(t4) {
      e(null != t4 && null != t4.oa), t4.pa < t4.Zc ? (t4.I = (t4.oa[t4.pa++] | t4.I << 8) >>> 0, t4.b += 8) : (e(null != t4 && null != t4.oa), t4.pa < t4.Yc ? (t4.b += 8, t4.I = t4.oa[t4.pa++] | t4.I << 8) : t4.Ka ? t4.b = 0 : (t4.I <<= 8, t4.b += 8, t4.Ka = 1));
    }
    function P4(t4) {
      return g3(t4, 1);
    }
    function k3(t4, e2) {
      var n2 = t4.Ca;
      0 > t4.b && _3(t4);
      var r2 = t4.b, i3 = n2 * e2 >>> 8, a3 = (t4.I >>> r2 > i3) + 0;
      for (a3 ? (n2 -= i3, t4.I -= i3 + 1 << r2 >>> 0) : n2 = i3 + 1, r2 = n2, i3 = 0; 256 <= r2; ) i3 += 8, r2 >>= 8;
      return r2 = 7 ^ i3 + Hn[r2], t4.b -= r2, t4.Ca = (n2 << r2) - 1, a3;
    }
    function F14(t4, e2, n2) {
      t4[e2 + 0] = n2 >> 24 & 255, t4[e2 + 1] = n2 >> 16 & 255, t4[e2 + 2] = n2 >> 8 & 255, t4[e2 + 3] = 255 & n2;
    }
    function I4(t4, e2) {
      return t4[e2 + 0] | t4[e2 + 1] << 8;
    }
    function j3(t4, e2) {
      return I4(t4, e2) | t4[e2 + 2] << 16;
    }
    function C4(t4, e2) {
      return I4(t4, e2) | I4(t4, e2 + 2) << 16;
    }
    function O3(t4, n2) {
      var r2 = 1 << n2;
      return e(null != t4), e(0 < n2), t4.X = a2(r2), null == t4.X ? 0 : (t4.Mb = 32 - n2, t4.Xa = n2, 1);
    }
    function B4(t4, n2) {
      e(null != t4), e(null != n2), e(t4.Xa == n2.Xa), r(n2.X, 0, t4.X, 0, 1 << n2.Xa);
    }
    function M4() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function q3(t4, n2, r2, i3) {
      e(null != r2), e(null != i3);
      var a3 = r2[0], o3 = i3[0];
      return 0 == a3 && (a3 = (t4 * o3 + n2 / 2) / n2), 0 == o3 && (o3 = (n2 * a3 + t4 / 2) / t4), 0 >= a3 || 0 >= o3 ? 0 : (r2[0] = a3, i3[0] = o3, 1);
    }
    function E4(t4, e2) {
      return t4 + (1 << e2) - 1 >>> e2;
    }
    function R3(t4, e2) {
      return ((4278255360 & t4) + (4278255360 & e2) >>> 0 & 4278255360) + ((16711935 & t4) + (16711935 & e2) >>> 0 & 16711935) >>> 0;
    }
    function D4(e2, n2) {
      t3[n2] = function(n3, r2, i3, a3, o3, s3, u4) {
        var c4;
        for (c4 = 0; c4 < o3; ++c4) {
          var l6 = t3[e2](s3[u4 + c4 - 1], i3, a3 + c4);
          s3[u4 + c4] = R3(n3[r2 + c4], l6);
        }
      };
    }
    function T4() {
      this.ud = this.hd = this.jd = 0;
    }
    function z3(t4, e2) {
      return ((4278124286 & (t4 ^ e2)) >>> 1) + (t4 & e2) >>> 0;
    }
    function U4(t4) {
      return 0 <= t4 && 256 > t4 ? t4 : 0 > t4 ? 0 : 255 < t4 ? 255 : void 0;
    }
    function H3(t4, e2) {
      return U4(t4 + (t4 - e2 + 0.5 >> 1));
    }
    function W4(t4, e2, n2) {
      return Math.abs(e2 - n2) - Math.abs(t4 - n2);
    }
    function V4(t4, e2, n2, r2, i3, a3, o3) {
      for (r2 = a3[o3 - 1], n2 = 0; n2 < i3; ++n2) a3[o3 + n2] = r2 = R3(t4[e2 + n2], r2);
    }
    function G4(t4, e2, n2, r2, i3) {
      var a3;
      for (a3 = 0; a3 < n2; ++a3) {
        var o3 = t4[e2 + a3], s3 = o3 >> 8 & 255, u4 = 16711935 & (u4 = (u4 = 16711935 & o3) + ((s3 << 16) + s3));
        r2[i3 + a3] = (4278255360 & o3) + u4 >>> 0;
      }
    }
    function Y3(t4, e2) {
      e2.jd = 255 & t4, e2.hd = t4 >> 8 & 255, e2.ud = t4 >> 16 & 255;
    }
    function J4(t4, e2, n2, r2, i3, a3) {
      var o3;
      for (o3 = 0; o3 < r2; ++o3) {
        var s3 = e2[n2 + o3], u4 = s3 >>> 8, c4 = s3, l6 = 255 & (l6 = (l6 = s3 >>> 16) + ((t4.jd << 24 >> 24) * (u4 << 24 >> 24) >>> 5));
        c4 = 255 & (c4 = (c4 += (t4.hd << 24 >> 24) * (u4 << 24 >> 24) >>> 5) + ((t4.ud << 24 >> 24) * (l6 << 24 >> 24) >>> 5)), i3[a3 + o3] = (4278255360 & s3) + (l6 << 16) + c4;
      }
    }
    function X4(e2, n2, r2, i3, a3) {
      t3[n2] = function(t4, e3, n3, r3, o3, s3, u4, c4, l6) {
        for (r3 = u4; r3 < c4; ++r3) for (u4 = 0; u4 < l6; ++u4) o3[s3++] = a3(n3[i3(t4[e3++])]);
      }, t3[e2] = function(e3, n3, o3, s3, u4, c4, l6) {
        var h4 = 8 >> e3.b, f4 = e3.Ea, d5 = e3.K[0], p4 = e3.w;
        if (8 > h4) for (e3 = (1 << e3.b) - 1, p4 = (1 << h4) - 1; n3 < o3; ++n3) {
          var g4, m5 = 0;
          for (g4 = 0; g4 < f4; ++g4) g4 & e3 || (m5 = i3(s3[u4++])), c4[l6++] = a3(d5[m5 & p4]), m5 >>= h4;
        }
        else t3["VP8LMapColor" + r2](s3, u4, d5, p4, c4, l6, n3, o3, f4);
      };
    }
    function K4(t4, e2, n2, r2, i3) {
      for (n2 = e2 + n2; e2 < n2; ) {
        var a3 = t4[e2++];
        r2[i3++] = a3 >> 16 & 255, r2[i3++] = a3 >> 8 & 255, r2[i3++] = 255 & a3;
      }
    }
    function Z3(t4, e2, n2, r2, i3) {
      for (n2 = e2 + n2; e2 < n2; ) {
        var a3 = t4[e2++];
        r2[i3++] = a3 >> 16 & 255, r2[i3++] = a3 >> 8 & 255, r2[i3++] = 255 & a3, r2[i3++] = a3 >> 24 & 255;
      }
    }
    function $3(t4, e2, n2, r2, i3) {
      for (n2 = e2 + n2; e2 < n2; ) {
        var a3 = (o3 = t4[e2++]) >> 16 & 240 | o3 >> 12 & 15, o3 = 240 & o3 | o3 >> 28 & 15;
        r2[i3++] = a3, r2[i3++] = o3;
      }
    }
    function Q4(t4, e2, n2, r2, i3) {
      for (n2 = e2 + n2; e2 < n2; ) {
        var a3 = (o3 = t4[e2++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
        r2[i3++] = a3, r2[i3++] = o3;
      }
    }
    function tt2(t4, e2, n2, r2, i3) {
      for (n2 = e2 + n2; e2 < n2; ) {
        var a3 = t4[e2++];
        r2[i3++] = 255 & a3, r2[i3++] = a3 >> 8 & 255, r2[i3++] = a3 >> 16 & 255;
      }
    }
    function et3(t4, e2, n2, i3, a3, o3) {
      if (0 == o3) for (n2 = e2 + n2; e2 < n2; ) F14(i3, ((o3 = t4[e2++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
      else r(i3, a3, t4, e2, n2);
    }
    function nt2(e2, n2) {
      t3[n2][0] = t3[e2 + "0"], t3[n2][1] = t3[e2 + "1"], t3[n2][2] = t3[e2 + "2"], t3[n2][3] = t3[e2 + "3"], t3[n2][4] = t3[e2 + "4"], t3[n2][5] = t3[e2 + "5"], t3[n2][6] = t3[e2 + "6"], t3[n2][7] = t3[e2 + "7"], t3[n2][8] = t3[e2 + "8"], t3[n2][9] = t3[e2 + "9"], t3[n2][10] = t3[e2 + "10"], t3[n2][11] = t3[e2 + "11"], t3[n2][12] = t3[e2 + "12"], t3[n2][13] = t3[e2 + "13"], t3[n2][14] = t3[e2 + "0"], t3[n2][15] = t3[e2 + "0"];
    }
    function rt2(t4) {
      return t4 == Ur || t4 == Hr || t4 == Wr || t4 == Vr;
    }
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
    }
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ut2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ct2(t4) {
      return alert("todo:WebPSamplerProcessPlane"), t4.T;
    }
    function lt2(t4, e2) {
      var n2 = t4.T, i3 = e2.ba.f.RGBA, a3 = i3.eb, o3 = i3.fb + t4.ka * i3.A, s3 = mi[e2.ba.S], u4 = t4.y, c4 = t4.O, l6 = t4.f, h4 = t4.N, f4 = t4.ea, d5 = t4.W, p4 = e2.cc, g4 = e2.dc, m5 = e2.Mc, v5 = e2.Nc, b5 = t4.ka, y5 = t4.ka + t4.T, w5 = t4.U, N6 = w5 + 1 >> 1;
      for (0 == b5 ? s3(u4, c4, null, null, l6, h4, f4, d5, l6, h4, f4, d5, a3, o3, null, null, w5) : (s3(e2.ec, e2.fc, u4, c4, p4, g4, m5, v5, l6, h4, f4, d5, a3, o3 - i3.A, a3, o3, w5), ++n2); b5 + 2 < y5; b5 += 2) p4 = l6, g4 = h4, m5 = f4, v5 = d5, h4 += t4.Rc, d5 += t4.Rc, o3 += 2 * i3.A, s3(u4, (c4 += 2 * t4.fa) - t4.fa, u4, c4, p4, g4, m5, v5, l6, h4, f4, d5, a3, o3 - i3.A, a3, o3, w5);
      return c4 += t4.fa, t4.j + y5 < t4.o ? (r(e2.ec, e2.fc, u4, c4, w5), r(e2.cc, e2.dc, l6, h4, N6), r(e2.Mc, e2.Nc, f4, d5, N6), n2--) : 1 & y5 || s3(u4, c4, null, null, l6, h4, f4, d5, l6, h4, f4, d5, a3, o3 + i3.A, null, null, w5), n2;
    }
    function ht2(t4, n2, r2) {
      var i3 = t4.F, a3 = [t4.J];
      if (null != i3) {
        var o3 = t4.U, s3 = n2.ba.S, u4 = s3 == Dr || s3 == Wr;
        n2 = n2.ba.f.RGBA;
        var c4 = [0], l6 = t4.ka;
        c4[0] = t4.T, t4.Kb && (0 == l6 ? --c4[0] : (--l6, a3[0] -= t4.width), t4.j + t4.ka + t4.T == t4.o && (c4[0] = t4.o - t4.j - l6));
        var h4 = n2.eb;
        l6 = n2.fb + l6 * n2.A, t4 = Ar(i3, a3[0], t4.width, o3, c4, h4, l6 + (u4 ? 0 : 3), n2.A), e(r2 == c4), t4 && rt2(s3) && Lr(h4, l6, u4, o3, c4, n2.A);
      }
      return 0;
    }
    function ft2(t4) {
      var e2 = t4.ma, n2 = e2.ba.S, r2 = 11 > n2, i3 = n2 == qr || n2 == Rr || n2 == Dr || n2 == Tr || 12 == n2 || rt2(n2);
      if (e2.memory = null, e2.Ib = null, e2.Jb = null, e2.Nd = null, !Mn(e2.Oa, t4, i3 ? 11 : 12)) return 0;
      if (i3 && rt2(n2) && bn(), t4.da) alert("todo:use_scaling");
      else {
        if (r2) {
          if (e2.Ib = ct2, t4.Kb) {
            if (n2 = t4.U + 1 >> 1, e2.memory = a2(t4.U + 2 * n2), null == e2.memory) return 0;
            e2.ec = e2.memory, e2.fc = 0, e2.cc = e2.ec, e2.dc = e2.fc + t4.U, e2.Mc = e2.cc, e2.Nc = e2.dc + n2, e2.Ib = lt2, bn();
          }
        } else alert("todo:EmitYUV");
        i3 && (e2.Jb = ht2, r2 && mn());
      }
      if (r2 && !Ii) {
        for (t4 = 0; 256 > t4; ++t4) ji[t4] = 89858 * (t4 - 128) + Si >> Ai, Bi[t4] = -22014 * (t4 - 128) + Si, Oi[t4] = -45773 * (t4 - 128), Ci[t4] = 113618 * (t4 - 128) + Si >> Ai;
        for (t4 = _i; t4 < Pi; ++t4) e2 = 76283 * (t4 - 16) + Si >> Ai, Mi[t4 - _i] = Vt2(e2, 255), qi[t4 - _i] = Vt2(e2 + 8 >> 4, 15);
        Ii = 1;
      }
      return 1;
    }
    function dt2(t4) {
      var n2 = t4.ma, r2 = t4.U, i3 = t4.T;
      return e(!(1 & t4.ka)), 0 >= r2 || 0 >= i3 ? 0 : (r2 = n2.Ib(t4, n2), null != n2.Jb && n2.Jb(t4, n2, r2), n2.Dc += r2, 1);
    }
    function pt2(t4) {
      t4.ma.memory = null;
    }
    function gt2(t4, e2, n2, r2) {
      return 47 != y4(t4, 8) ? 0 : (e2[0] = y4(t4, 14) + 1, n2[0] = y4(t4, 14) + 1, r2[0] = y4(t4, 1), 0 != y4(t4, 3) ? 0 : !t4.h);
    }
    function mt2(t4, e2) {
      if (4 > t4) return t4 + 1;
      var n2 = t4 - 2 >> 1;
      return (2 + (1 & t4) << n2) + y4(e2, n2) + 1;
    }
    function vt2(t4, e2) {
      return 120 < e2 ? e2 - 120 : 1 <= (n2 = ((n2 = Zr[e2 - 1]) >> 4) * t4 + (8 - (15 & n2))) ? n2 : 1;
      var n2;
    }
    function bt2(t4, e2, n2) {
      var r2 = L5(n2), i3 = t4[e2 += 255 & r2].g - 8;
      return 0 < i3 && (A4(n2, n2.u + 8), r2 = L5(n2), e2 += t4[e2].value, e2 += r2 & (1 << i3) - 1), A4(n2, n2.u + t4[e2].g), t4[e2].value;
    }
    function yt2(t4, n2, r2) {
      return r2.g += t4.g, r2.value += t4.value << n2 >>> 0, e(8 >= r2.g), t4.g;
    }
    function wt2(t4, n2, r2) {
      var i3 = t4.xc;
      return e((n2 = 0 == i3 ? 0 : t4.vc[t4.md * (r2 >> i3) + (n2 >> i3)]) < t4.Wb), t4.Ya[n2];
    }
    function Nt3(t4, n2, i3, a3) {
      var o3 = t4.ab, s3 = t4.c * n2, u4 = t4.C;
      n2 = u4 + n2;
      var c4 = i3, l6 = a3;
      for (a3 = t4.Ta, i3 = t4.Ua; 0 < o3--; ) {
        var h4 = t4.gc[o3], f4 = u4, d5 = n2, p4 = c4, g4 = l6, m5 = (l6 = a3, c4 = i3, h4.Ea);
        switch (e(f4 < d5), e(d5 <= h4.nc), h4.hc) {
          case 2:
            Gn(p4, g4, (d5 - f4) * m5, l6, c4);
            break;
          case 0:
            var v5 = f4, b5 = d5, y5 = l6, w5 = c4, N6 = (_4 = h4).Ea;
            0 == v5 && (Wn(p4, g4, null, null, 1, y5, w5), V4(p4, g4 + 1, 0, 0, N6 - 1, y5, w5 + 1), g4 += N6, w5 += N6, ++v5);
            for (var L6 = 1 << _4.b, x5 = L6 - 1, A5 = E4(N6, _4.b), S5 = _4.K, _4 = _4.w + (v5 >> _4.b) * A5; v5 < b5; ) {
              var P5 = S5, k4 = _4, F15 = 1;
              for (Vn(p4, g4, y5, w5 - N6, 1, y5, w5); F15 < N6; ) {
                var I5 = (F15 & ~x5) + L6;
                I5 > N6 && (I5 = N6), (0, Zn[P5[k4++] >> 8 & 15])(p4, g4 + +F15, y5, w5 + F15 - N6, I5 - F15, y5, w5 + F15), F15 = I5;
              }
              g4 += N6, w5 += N6, ++v5 & x5 || (_4 += A5);
            }
            d5 != h4.nc && r(l6, c4 - m5, l6, c4 + (d5 - f4 - 1) * m5, m5);
            break;
          case 1:
            for (m5 = p4, b5 = g4, N6 = (p4 = h4.Ea) - (w5 = p4 & ~(y5 = (g4 = 1 << h4.b) - 1)), v5 = E4(p4, h4.b), L6 = h4.K, h4 = h4.w + (f4 >> h4.b) * v5; f4 < d5; ) {
              for (x5 = L6, A5 = h4, S5 = new T4(), _4 = b5 + w5, P5 = b5 + p4; b5 < _4; ) Y3(x5[A5++], S5), $n(S5, m5, b5, g4, l6, c4), b5 += g4, c4 += g4;
              b5 < P5 && (Y3(x5[A5++], S5), $n(S5, m5, b5, N6, l6, c4), b5 += N6, c4 += N6), ++f4 & y5 || (h4 += v5);
            }
            break;
          case 3:
            if (p4 == l6 && g4 == c4 && 0 < h4.b) {
              for (b5 = l6, p4 = m5 = c4 + (d5 - f4) * m5 - (w5 = (d5 - f4) * E4(h4.Ea, h4.b)), g4 = l6, y5 = c4, v5 = [], w5 = (N6 = w5) - 1; 0 <= w5; --w5) v5[w5] = g4[y5 + w5];
              for (w5 = N6 - 1; 0 <= w5; --w5) b5[p4 + w5] = v5[w5];
              Yn(h4, f4, d5, l6, m5, l6, c4);
            } else Yn(h4, f4, d5, p4, g4, l6, c4);
        }
        c4 = a3, l6 = i3;
      }
      l6 != i3 && r(a3, i3, c4, l6, s3);
    }
    function Lt2(t4, n2) {
      var r2 = t4.V, i3 = t4.Ba + t4.c * t4.C, a3 = n2 - t4.C;
      if (e(n2 <= t4.l.o), e(16 >= a3), 0 < a3) {
        var o3 = t4.l, s3 = t4.Ta, u4 = t4.Ua, c4 = o3.width;
        if (Nt3(t4, a3, r2, i3), a3 = u4 = [u4], e((r2 = t4.C) < (i3 = n2)), e(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), r2 < o3.j) {
          var l6 = o3.j - r2;
          r2 = o3.j, a3[0] += l6 * c4;
        }
        if (r2 >= i3 ? r2 = 0 : (a3[0] += 4 * o3.v, o3.ka = r2 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - r2, r2 = 1), r2) {
          if (u4 = u4[0], 11 > (r2 = t4.ca).S) {
            var h4 = r2.f.RGBA, f4 = (i3 = r2.S, a3 = o3.U, o3 = o3.T, l6 = h4.eb, h4.A), d5 = o3;
            for (h4 = h4.fb + t4.Ma * h4.A; 0 < d5--; ) {
              var p4 = s3, g4 = u4, m5 = a3, v5 = l6, b5 = h4;
              switch (i3) {
                case Mr:
                  Qn(p4, g4, m5, v5, b5);
                  break;
                case qr:
                  tr(p4, g4, m5, v5, b5);
                  break;
                case Ur:
                  tr(p4, g4, m5, v5, b5), Lr(v5, b5, 0, m5, 1, 0);
                  break;
                case Er:
                  rr(p4, g4, m5, v5, b5);
                  break;
                case Rr:
                  et3(p4, g4, m5, v5, b5, 1);
                  break;
                case Hr:
                  et3(p4, g4, m5, v5, b5, 1), Lr(v5, b5, 0, m5, 1, 0);
                  break;
                case Dr:
                  et3(p4, g4, m5, v5, b5, 0);
                  break;
                case Wr:
                  et3(p4, g4, m5, v5, b5, 0), Lr(v5, b5, 1, m5, 1, 0);
                  break;
                case Tr:
                  er(p4, g4, m5, v5, b5);
                  break;
                case Vr:
                  er(p4, g4, m5, v5, b5), xr(v5, b5, m5, 1, 0);
                  break;
                case zr:
                  nr(p4, g4, m5, v5, b5);
                  break;
                default:
                  e(0);
              }
              u4 += c4, h4 += f4;
            }
            t4.Ma += o3;
          } else alert("todo:EmitRescaledRowsYUVA");
          e(t4.Ma <= r2.height);
        }
      }
      t4.C = n2, e(t4.C <= t4.i);
    }
    function xt2(t4) {
      var e2;
      if (0 < t4.ua) return 0;
      for (e2 = 0; e2 < t4.Wb; ++e2) {
        var n2 = t4.Ya[e2].G, r2 = t4.Ya[e2].H;
        if (0 < n2[1][r2[1] + 0].g || 0 < n2[2][r2[2] + 0].g || 0 < n2[3][r2[3] + 0].g) return 0;
      }
      return 1;
    }
    function At2(t4, n2, r2, i3, a3, o3) {
      if (0 != t4.Z) {
        var s3 = t4.qd, u4 = t4.rd;
        for (e(null != gi[t4.Z]); n2 < r2; ++n2) gi[t4.Z](s3, u4, i3, a3, i3, a3, o3), s3 = i3, u4 = a3, a3 += o3;
        t4.qd = s3, t4.rd = u4;
      }
    }
    function St2(t4, n2) {
      var r2 = t4.l.ma, i3 = 0 == r2.Z || 1 == r2.Z ? t4.l.j : t4.C;
      if (i3 = t4.C < i3 ? i3 : t4.C, e(n2 <= t4.l.o), n2 > i3) {
        var a3 = t4.l.width, o3 = r2.ca, s3 = r2.tb + a3 * i3, u4 = t4.V, c4 = t4.Ba + t4.c * i3, l6 = t4.gc;
        e(1 == t4.ab), e(3 == l6[0].hc), Xn(l6[0], i3, n2, u4, c4, o3, s3), At2(r2, i3, n2, o3, s3, a3);
      }
      t4.C = t4.Ma = n2;
    }
    function _t2(t4, n2, r2, i3, a3, o3, s3) {
      var u4 = t4.$ / i3, c4 = t4.$ % i3, l6 = t4.m, h4 = t4.s, f4 = r2 + t4.$, d5 = f4;
      a3 = r2 + i3 * a3;
      var p4 = r2 + i3 * o3, g4 = 280 + h4.ua, m5 = t4.Pb ? u4 : 16777216, v5 = 0 < h4.ua ? h4.Wa : null, b5 = h4.wc, y5 = f4 < p4 ? wt2(h4, c4, u4) : null;
      e(t4.C < o3), e(p4 <= a3);
      var w5 = false;
      t: for (; ; ) {
        for (; w5 || f4 < p4; ) {
          var N6 = 0;
          if (u4 >= m5) {
            var _4 = f4 - r2;
            e((m5 = t4).Pb), m5.wd = m5.m, m5.xd = _4, 0 < m5.s.ua && B4(m5.s.Wa, m5.s.vb), m5 = u4 + Qr;
          }
          if (c4 & b5 || (y5 = wt2(h4, c4, u4)), e(null != y5), y5.Qb && (n2[f4] = y5.qb, w5 = true), !w5) if (S4(l6), y5.jc) {
            N6 = l6, _4 = n2;
            var P5 = f4, k4 = y5.pd[L5(N6) & Rn - 1];
            e(y5.jc), 256 > k4.g ? (A4(N6, N6.u + k4.g), _4[P5] = k4.value, N6 = 0) : (A4(N6, N6.u + k4.g - 256), e(256 <= k4.value), N6 = k4.value), 0 == N6 && (w5 = true);
          } else N6 = bt2(y5.G[0], y5.H[0], l6);
          if (l6.h) break;
          if (w5 || 256 > N6) {
            if (!w5) if (y5.nd) n2[f4] = (y5.qb | N6 << 8) >>> 0;
            else {
              if (S4(l6), w5 = bt2(y5.G[1], y5.H[1], l6), S4(l6), _4 = bt2(y5.G[2], y5.H[2], l6), P5 = bt2(y5.G[3], y5.H[3], l6), l6.h) break;
              n2[f4] = (P5 << 24 | w5 << 16 | N6 << 8 | _4) >>> 0;
            }
            if (w5 = false, ++f4, ++c4 >= i3 && (c4 = 0, ++u4, null != s3 && u4 <= o3 && !(u4 % 16) && s3(t4, u4), null != v5)) for (; d5 < f4; ) N6 = n2[d5++], v5.X[(506832829 * N6 & 4294967295) >>> v5.Mb] = N6;
          } else if (280 > N6) {
            if (N6 = mt2(N6 - 256, l6), _4 = bt2(y5.G[4], y5.H[4], l6), S4(l6), _4 = vt2(i3, _4 = mt2(_4, l6)), l6.h) break;
            if (f4 - r2 < _4 || a3 - f4 < N6) break t;
            for (P5 = 0; P5 < N6; ++P5) n2[f4 + P5] = n2[f4 + P5 - _4];
            for (f4 += N6, c4 += N6; c4 >= i3; ) c4 -= i3, ++u4, null != s3 && u4 <= o3 && !(u4 % 16) && s3(t4, u4);
            if (e(f4 <= a3), c4 & b5 && (y5 = wt2(h4, c4, u4)), null != v5) for (; d5 < f4; ) N6 = n2[d5++], v5.X[(506832829 * N6 & 4294967295) >>> v5.Mb] = N6;
          } else {
            if (!(N6 < g4)) break t;
            for (w5 = N6 - 280, e(null != v5); d5 < f4; ) N6 = n2[d5++], v5.X[(506832829 * N6 & 4294967295) >>> v5.Mb] = N6;
            N6 = f4, e(!(w5 >>> (_4 = v5).Xa)), n2[N6] = _4.X[w5], w5 = true;
          }
          w5 || e(l6.h == x4(l6));
        }
        if (t4.Pb && l6.h && f4 < a3) e(t4.m.h), t4.a = 5, t4.m = t4.wd, t4.$ = t4.xd, 0 < t4.s.ua && B4(t4.s.vb, t4.s.Wa);
        else {
          if (l6.h) break t;
          null != s3 && s3(t4, u4 > o3 ? o3 : u4), t4.a = 0, t4.$ = f4 - r2;
        }
        return 1;
      }
      return t4.a = 3, 0;
    }
    function Pt2(t4) {
      e(null != t4), t4.vc = null, t4.yc = null, t4.Ya = null;
      var n2 = t4.Wa;
      null != n2 && (n2.X = null), t4.vb = null, e(null != t4);
    }
    function kt2() {
      var e2 = new on();
      return null == e2 ? null : (e2.a = 0, e2.xb = pi, nt2("Predictor", "VP8LPredictors"), nt2("Predictor", "VP8LPredictors_C"), nt2("PredictorAdd", "VP8LPredictorsAdd"), nt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gn = G4, $n = J4, Qn = K4, tr = Z3, er = $3, nr = Q4, rr = tt2, t3.VP8LMapColor32b = Jn, t3.VP8LMapColor8b = Kn, e2);
    }
    function Ft3(t4, n2, r2, s3, u4) {
      var c4 = 1, f4 = [t4], p4 = [n2], g4 = s3.m, m5 = s3.s, v5 = null, b5 = 0;
      t: for (; ; ) {
        if (r2) for (; c4 && y4(g4, 1); ) {
          var w5 = f4, N6 = p4, x5 = s3, _4 = 1, P5 = x5.m, k4 = x5.gc[x5.ab], F15 = y4(P5, 2);
          if (x5.Oc & 1 << F15) c4 = 0;
          else {
            switch (x5.Oc |= 1 << F15, k4.hc = F15, k4.Ea = w5[0], k4.nc = N6[0], k4.K = [null], ++x5.ab, e(4 >= x5.ab), F15) {
              case 0:
              case 1:
                k4.b = y4(P5, 3) + 2, _4 = Ft3(E4(k4.Ea, k4.b), E4(k4.nc, k4.b), 0, x5, k4.K), k4.K = k4.K[0];
                break;
              case 3:
                var I5, j4 = y4(P5, 8) + 1, C5 = 16 < j4 ? 0 : 4 < j4 ? 1 : 2 < j4 ? 2 : 3;
                if (w5[0] = E4(k4.Ea, C5), k4.b = C5, I5 = _4 = Ft3(j4, 1, 0, x5, k4.K)) {
                  var B5, M5 = j4, q4 = k4, D5 = 1 << (8 >> q4.b), T5 = a2(D5);
                  if (null == T5) I5 = 0;
                  else {
                    var z4 = q4.K[0], U5 = q4.w;
                    for (T5[0] = q4.K[0][0], B5 = 1; B5 < 1 * M5; ++B5) T5[B5] = R3(z4[U5 + B5], T5[B5 - 1]);
                    for (; B5 < 4 * D5; ++B5) T5[B5] = 0;
                    q4.K[0] = null, q4.K[0] = T5, I5 = 1;
                  }
                }
                _4 = I5;
                break;
              case 2:
                break;
              default:
                e(0);
            }
            c4 = _4;
          }
        }
        if (f4 = f4[0], p4 = p4[0], c4 && y4(g4, 1) && !(c4 = 1 <= (b5 = y4(g4, 4)) && 11 >= b5)) {
          s3.a = 3;
          break t;
        }
        var H4;
        if (H4 = c4) e: {
          var W5, V5, G5, Y4 = s3, J5 = f4, X5 = p4, K5 = b5, Z4 = r2, $4 = Y4.m, Q5 = Y4.s, tt3 = [null], et4 = 1, nt3 = 0, rt3 = $r[K5];
          n: for (; ; ) {
            if (Z4 && y4($4, 1)) {
              var it3 = y4($4, 3) + 2, at3 = E4(J5, it3), ot3 = E4(X5, it3), st3 = at3 * ot3;
              if (!Ft3(at3, ot3, 0, Y4, tt3)) break n;
              for (tt3 = tt3[0], Q5.xc = it3, W5 = 0; W5 < st3; ++W5) {
                var ut3 = tt3[W5] >> 8 & 65535;
                tt3[W5] = ut3, ut3 >= et4 && (et4 = ut3 + 1);
              }
            }
            if ($4.h) break n;
            for (V5 = 0; 5 > V5; ++V5) {
              var ct3 = Jr[V5];
              !V5 && 0 < K5 && (ct3 += 1 << K5), nt3 < ct3 && (nt3 = ct3);
            }
            var lt3 = o2(et4 * rt3, h3), ht3 = et4, ft3 = o2(ht3, d4);
            if (null == ft3) var dt3 = null;
            else e(65536 >= ht3), dt3 = ft3;
            var pt3 = a2(nt3);
            if (null == dt3 || null == pt3 || null == lt3) {
              Y4.a = 1;
              break n;
            }
            var gt3 = lt3;
            for (W5 = G5 = 0; W5 < et4; ++W5) {
              var mt3 = dt3[W5], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt4 = 1, Lt3 = 0;
              for (V5 = 0; 5 > V5; ++V5) {
                ct3 = Jr[V5], vt3[V5] = gt3, bt3[V5] = G5, !V5 && 0 < K5 && (ct3 += 1 << K5);
                r: {
                  var xt3, At3 = ct3, St3 = Y4, kt3 = pt3, It3 = gt3, jt3 = G5, Ct3 = 0, Ot3 = St3.m, Bt3 = y4(Ot3, 1);
                  if (i2(kt3, 0, 0, At3), Bt3) {
                    var Mt3 = y4(Ot3, 1) + 1, qt3 = y4(Ot3, 1), Et3 = y4(Ot3, 0 == qt3 ? 1 : 8);
                    kt3[Et3] = 1, 2 == Mt3 && (kt3[Et3 = y4(Ot3, 8)] = 1);
                    var Rt3 = 1;
                  } else {
                    var Dt3 = a2(19), Tt3 = y4(Ot3, 4) + 4;
                    if (19 < Tt3) {
                      St3.a = 3;
                      var zt3 = 0;
                      break r;
                    }
                    for (xt3 = 0; xt3 < Tt3; ++xt3) Dt3[Kr[xt3]] = y4(Ot3, 3);
                    var Ut4 = void 0, Ht4 = void 0, Wt3 = St3, Vt3 = Dt3, Gt4 = At3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt4 = o2(128, h3);
                    i: for (; l5(Zt4, 0, 7, Vt3, 19); ) {
                      if (y4(Xt3, 1)) {
                        var $t3 = 2 + 2 * y4(Xt3, 3);
                        if ((Ut4 = 2 + y4(Xt3, $t3)) > Gt4) break i;
                      } else Ut4 = Gt4;
                      for (Ht4 = 0; Ht4 < Gt4 && Ut4--; ) {
                        S4(Xt3);
                        var Qt4 = Zt4[0 + (127 & L5(Xt3))];
                        A4(Xt3, Xt3.u + Qt4.g);
                        var te3 = Qt4.value;
                        if (16 > te3) Yt3[Ht4++] = te3, 0 != te3 && (Kt3 = te3);
                        else {
                          var ee3 = 16 == te3, ne4 = te3 - 16, re4 = Yr[ne4], ie4 = y4(Xt3, Gr[ne4]) + re4;
                          if (Ht4 + ie4 > Gt4) break i;
                          for (var ae4 = ee3 ? Kt3 : 0; 0 < ie4--; ) Yt3[Ht4++] = ae4;
                        }
                      }
                      Jt3 = 1;
                      break i;
                    }
                    Jt3 || (Wt3.a = 3), Rt3 = Jt3;
                  }
                  (Rt3 = Rt3 && !Ot3.h) && (Ct3 = l5(It3, jt3, 8, kt3, At3)), Rt3 && 0 != Ct3 ? zt3 = Ct3 : (St3.a = 3, zt3 = 0);
                }
                if (0 == zt3) break n;
                if (Nt4 && 1 == Xr[V5] && (Nt4 = 0 == gt3[G5].g), wt3 += gt3[G5].g, G5 += zt3, 3 >= V5) {
                  var oe4, se4 = pt3[0];
                  for (oe4 = 1; oe4 < ct3; ++oe4) pt3[oe4] > se4 && (se4 = pt3[oe4]);
                  Lt3 += se4;
                }
              }
              if (mt3.nd = Nt4, mt3.Qb = 0, Nt4 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                var ue4, ce4 = mt3;
                for (ue4 = 0; ue4 < Rn; ++ue4) {
                  var le4 = ue4, he4 = ce4.pd[le4], fe4 = ce4.G[0][ce4.H[0] + le4];
                  256 <= fe4.value ? (he4.g = fe4.g + 256, he4.value = fe4.value) : (he4.g = 0, he4.value = 0, le4 >>= yt2(fe4, 8, he4), le4 >>= yt2(ce4.G[1][ce4.H[1] + le4], 16, he4), le4 >>= yt2(ce4.G[2][ce4.H[2] + le4], 0, he4), yt2(ce4.G[3][ce4.H[3] + le4], 24, he4));
                }
              }
            }
            Q5.vc = tt3, Q5.Wb = et4, Q5.Ya = dt3, Q5.yc = lt3, H4 = 1;
            break e;
          }
          H4 = 0;
        }
        if (!(c4 = H4)) {
          s3.a = 3;
          break t;
        }
        if (0 < b5) {
          if (m5.ua = 1 << b5, !O3(m5.Wa, b5)) {
            s3.a = 1, c4 = 0;
            break t;
          }
        } else m5.ua = 0;
        var de4 = s3, pe4 = f4, ge4 = p4, me3 = de4.s, ve4 = me3.xc;
        if (de4.c = pe4, de4.i = ge4, me3.md = E4(pe4, ve4), me3.wc = 0 == ve4 ? -1 : (1 << ve4) - 1, r2) {
          s3.xb = di;
          break t;
        }
        if (null == (v5 = a2(f4 * p4))) {
          s3.a = 1, c4 = 0;
          break t;
        }
        c4 = (c4 = _t2(s3, v5, 0, f4, p4, p4, null)) && !g4.h;
        break t;
      }
      return c4 ? (null != u4 ? u4[0] = v5 : (e(null == v5), e(r2)), s3.$ = 0, r2 || Pt2(m5)) : Pt2(m5), c4;
    }
    function It2(t4, n2) {
      var r2 = t4.c * t4.i, i3 = r2 + n2 + 16 * n2;
      return e(t4.c <= n2), t4.V = a2(i3), null == t4.V ? (t4.Ta = null, t4.Ua = 0, t4.a = 1, 0) : (t4.Ta = t4.V, t4.Ua = t4.Ba + r2 + n2, 1);
    }
    function jt2(t4, n2) {
      var r2 = t4.C, i3 = n2 - r2, a3 = t4.V, o3 = t4.Ba + t4.c * r2;
      for (e(n2 <= t4.l.o); 0 < i3; ) {
        var s3 = 16 < i3 ? 16 : i3, u4 = t4.l.ma, c4 = t4.l.width, l6 = c4 * s3, h4 = u4.ca, f4 = u4.tb + c4 * r2, d5 = t4.Ta, p4 = t4.Ua;
        Nt3(t4, s3, a3, o3), Sr(d5, p4, h4, f4, l6), At2(u4, r2, r2 + s3, h4, f4, c4), i3 -= s3, a3 += s3 * t4.c, r2 += s3;
      }
      e(r2 == n2), t4.C = t4.Ma = n2;
    }
    function Ct2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
    }
    function Mt2() {
      this.Yb = (function() {
        var t4 = [];
        return (function t5(e2, n2, r2) {
          for (var i3 = r2[n2], a3 = 0; a3 < i3 && (e2.push(r2.length > n2 + 1 ? [] : 0), !(r2.length < n2 + 1)); a3++) t5(e2[a3], n2 + 1, r2);
        })(t4, 0, [3, 11]), t4;
      })();
    }
    function qt2() {
      this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
    }
    function Et2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
    }
    function Rt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Dt2() {
      this.Na = this.la = 0;
    }
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function zt2() {
      this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Ut3() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Rt2()), this.Y = 0, this.ya = Array(new zt2()), this.aa = 0, this.l = new Gt3();
    }
    function Ht3() {
      this.y = a2(16), this.f = a2(8), this.ea = a2(8);
    }
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w4(), this.Od = new Ct2(), this.Kc = new Ot2(), this.ed = new Et2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new Ut3(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w4), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new qt2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht3()), this.Hd = 0, this.rb = Array(new Dt2()), this.sb = 0, this.wa = Array(new Rt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new zt2()), this.L = this.aa = 0, this.gd = s2([4, 2], Rt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Vt2(t4, e2) {
      return 0 > t4 ? 0 : t4 > e2 ? e2 : t4;
    }
    function Gt3() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Yt2() {
      var t4 = new Wt2();
      return null != t4 && (t4.a = 0, t4.sc = "OK", t4.cb = 0, t4.Xb = 0, ni || (ni = Zt3)), t4;
    }
    function Jt2(t4, e2, n2) {
      return 0 == t4.a && (t4.a = e2, t4.sc = n2, t4.cb = 0), 0;
    }
    function Xt2(t4, e2, n2) {
      return 3 <= n2 && 157 == t4[e2 + 0] && 1 == t4[e2 + 1] && 42 == t4[e2 + 2];
    }
    function Kt2(t4, n2) {
      if (null == t4) return 0;
      if (t4.a = 0, t4.sc = "OK", null == n2) return Jt2(t4, 2, "null VP8Io passed to VP8GetHeaders()");
      var r2 = n2.data, a3 = n2.w, o3 = n2.ha;
      if (4 > o3) return Jt2(t4, 7, "Truncated header.");
      var s3 = r2[a3 + 0] | r2[a3 + 1] << 8 | r2[a3 + 2] << 16, u4 = t4.Od;
      if (u4.Rb = !(1 & s3), u4.td = s3 >> 1 & 7, u4.yd = s3 >> 4 & 1, u4.ub = s3 >> 5, 3 < u4.td) return Jt2(t4, 3, "Incorrect keyframe parameters.");
      if (!u4.yd) return Jt2(t4, 4, "Frame not displayable.");
      a3 += 3, o3 -= 3;
      var c4 = t4.Kc;
      if (u4.Rb) {
        if (7 > o3) return Jt2(t4, 7, "cannot parse picture header");
        if (!Xt2(r2, a3, o3)) return Jt2(t4, 3, "Bad code word");
        c4.c = 16383 & (r2[a3 + 4] << 8 | r2[a3 + 3]), c4.Td = r2[a3 + 4] >> 6, c4.i = 16383 & (r2[a3 + 6] << 8 | r2[a3 + 5]), c4.Ud = r2[a3 + 6] >> 6, a3 += 7, o3 -= 7, t4.za = c4.c + 15 >> 4, t4.Ub = c4.i + 15 >> 4, n2.width = c4.c, n2.height = c4.i, n2.Da = 0, n2.j = 0, n2.v = 0, n2.va = n2.width, n2.o = n2.height, n2.da = 0, n2.ib = n2.width, n2.hb = n2.height, n2.U = n2.width, n2.T = n2.height, i2((s3 = t4.Pa).jb, 0, 255, s3.jb.length), e(null != (s3 = t4.Qa)), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);
      }
      if (u4.ub > o3) return Jt2(t4, 7, "bad partition length");
      p3(s3 = t4.m, r2, a3, u4.ub), a3 += u4.ub, o3 -= u4.ub, u4.Rb && (c4.Ld = P4(s3), c4.Kd = P4(s3)), c4 = t4.Qa;
      var l6, h4 = t4.Pa;
      if (e(null != s3), e(null != c4), c4.Cb = P4(s3), c4.Cb) {
        if (c4.Bb = P4(s3), P4(s3)) {
          for (c4.Fb = P4(s3), l6 = 0; 4 > l6; ++l6) c4.Zb[l6] = P4(s3) ? m4(s3, 7) : 0;
          for (l6 = 0; 4 > l6; ++l6) c4.Lb[l6] = P4(s3) ? m4(s3, 6) : 0;
        }
        if (c4.Bb) for (l6 = 0; 3 > l6; ++l6) h4.jb[l6] = P4(s3) ? g3(s3, 8) : 255;
      } else c4.Bb = 0;
      if (s3.Ka) return Jt2(t4, 3, "cannot parse segment header");
      if ((c4 = t4.ed).zd = P4(s3), c4.Tb = g3(s3, 6), c4.wb = g3(s3, 3), c4.Pc = P4(s3), c4.Pc && P4(s3)) {
        for (h4 = 0; 4 > h4; ++h4) P4(s3) && (c4.vd[h4] = m4(s3, 6));
        for (h4 = 0; 4 > h4; ++h4) P4(s3) && (c4.od[h4] = m4(s3, 6));
      }
      if (t4.L = 0 == c4.Tb ? 0 : c4.zd ? 1 : 2, s3.Ka) return Jt2(t4, 3, "cannot parse filter header");
      var f4 = o3;
      if (o3 = l6 = a3, a3 = l6 + f4, c4 = f4, t4.Xb = (1 << g3(t4.m, 2)) - 1, f4 < 3 * (h4 = t4.Xb)) r2 = 7;
      else {
        for (l6 += 3 * h4, c4 -= 3 * h4, f4 = 0; f4 < h4; ++f4) {
          var d5 = r2[o3 + 0] | r2[o3 + 1] << 8 | r2[o3 + 2] << 16;
          d5 > c4 && (d5 = c4), p3(t4.Jc[+f4], r2, l6, d5), l6 += d5, c4 -= d5, o3 += 3;
        }
        p3(t4.Jc[+h4], r2, l6, c4), r2 = l6 < a3 ? 0 : 5;
      }
      if (0 != r2) return Jt2(t4, r2, "cannot parse partitions");
      for (r2 = g3(l6 = t4.m, 7), o3 = P4(l6) ? m4(l6, 4) : 0, a3 = P4(l6) ? m4(l6, 4) : 0, c4 = P4(l6) ? m4(l6, 4) : 0, h4 = P4(l6) ? m4(l6, 4) : 0, l6 = P4(l6) ? m4(l6, 4) : 0, f4 = t4.Qa, d5 = 0; 4 > d5; ++d5) {
        if (f4.Cb) {
          var v5 = f4.Zb[d5];
          f4.Fb || (v5 += r2);
        } else {
          if (0 < d5) {
            t4.pb[d5] = t4.pb[0];
            continue;
          }
          v5 = r2;
        }
        var b5 = t4.pb[d5];
        b5.Sc[0] = ti[Vt2(v5 + o3, 127)], b5.Sc[1] = ei[Vt2(v5 + 0, 127)], b5.Eb[0] = 2 * ti[Vt2(v5 + a3, 127)], b5.Eb[1] = 101581 * ei[Vt2(v5 + c4, 127)] >> 16, 8 > b5.Eb[1] && (b5.Eb[1] = 8), b5.Qc[0] = ti[Vt2(v5 + h4, 117)], b5.Qc[1] = ei[Vt2(v5 + l6, 127)], b5.lc = v5 + l6;
      }
      if (!u4.Rb) return Jt2(t4, 4, "Not a key frame.");
      for (P4(s3), u4 = t4.Pa, r2 = 0; 4 > r2; ++r2) {
        for (o3 = 0; 8 > o3; ++o3) for (a3 = 0; 3 > a3; ++a3) for (c4 = 0; 11 > c4; ++c4) h4 = k3(s3, ui[r2][o3][a3][c4]) ? g3(s3, 8) : oi[r2][o3][a3][c4], u4.Wc[r2][o3].Yb[a3][c4] = h4;
        for (o3 = 0; 17 > o3; ++o3) u4.Xc[r2][o3] = u4.Wc[r2][ci[o3]];
      }
      return t4.kc = P4(s3), t4.kc && (t4.Bd = g3(s3, 8)), t4.cb = 1;
    }
    function Zt3(t4, e2, n2, r2, i3, a3, o3) {
      var s3 = e2[i3].Yb[n2];
      for (n2 = 0; 16 > i3; ++i3) {
        if (!k3(t4, s3[n2 + 0])) return i3;
        for (; !k3(t4, s3[n2 + 1]); ) if (s3 = e2[++i3].Yb[0], n2 = 0, 16 == i3) return 16;
        var u4 = e2[i3 + 1].Yb;
        if (k3(t4, s3[n2 + 2])) {
          var c4 = t4, l6 = 0;
          if (k3(c4, (f4 = s3)[(h4 = n2) + 3])) if (k3(c4, f4[h4 + 6])) {
            for (s3 = 0, h4 = 2 * (l6 = k3(c4, f4[h4 + 8])) + (f4 = k3(c4, f4[h4 + 9 + l6])), l6 = 0, f4 = ri[h4]; f4[s3]; ++s3) l6 += l6 + k3(c4, f4[s3]);
            l6 += 3 + (8 << h4);
          } else k3(c4, f4[h4 + 7]) ? (l6 = 7 + 2 * k3(c4, 165), l6 += k3(c4, 145)) : l6 = 5 + k3(c4, 159);
          else l6 = k3(c4, f4[h4 + 4]) ? 3 + k3(c4, f4[h4 + 5]) : 2;
          s3 = u4[2];
        } else l6 = 1, s3 = u4[1];
        u4 = o3 + ii[i3], 0 > (c4 = t4).b && _3(c4);
        var h4, f4 = c4.b, d5 = (h4 = c4.Ca >> 1) - (c4.I >> f4) >> 31;
        --c4.b, c4.Ca += d5, c4.Ca |= 1, c4.I -= (h4 + 1 & d5) << f4, a3[u4] = ((l6 ^ d5) - d5) * r2[(0 < i3) + 0];
      }
      return 16;
    }
    function $t2(t4) {
      var e2 = t4.rb[t4.sb - 1];
      e2.la = 0, e2.Na = 0, i2(t4.zc, 0, 0, t4.zc.length), t4.ja = 0;
    }
    function Qt3(t4, e2, n2, r2, i3) {
      i3 = t4[e2 + n2 + 32 * r2] + (i3 >> 3), t4[e2 + n2 + 32 * r2] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;
    }
    function te2(t4, e2, n2, r2, i3, a3) {
      Qt3(t4, e2, 0, n2, r2 + i3), Qt3(t4, e2, 1, n2, r2 + a3), Qt3(t4, e2, 2, n2, r2 - a3), Qt3(t4, e2, 3, n2, r2 - i3);
    }
    function ee2(t4) {
      return (20091 * t4 >> 16) + t4;
    }
    function ne3(t4, e2, n2, r2) {
      var i3, o3 = 0, s3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var u4 = t4[e2 + 0] + t4[e2 + 8], c4 = t4[e2 + 0] - t4[e2 + 8], l6 = (35468 * t4[e2 + 4] >> 16) - ee2(t4[e2 + 12]), h4 = ee2(t4[e2 + 4]) + (35468 * t4[e2 + 12] >> 16);
        s3[o3 + 0] = u4 + h4, s3[o3 + 1] = c4 + l6, s3[o3 + 2] = c4 - l6, s3[o3 + 3] = u4 - h4, o3 += 4, e2++;
      }
      for (i3 = o3 = 0; 4 > i3; ++i3) u4 = (t4 = s3[o3 + 0] + 4) + s3[o3 + 8], c4 = t4 - s3[o3 + 8], l6 = (35468 * s3[o3 + 4] >> 16) - ee2(s3[o3 + 12]), Qt3(n2, r2, 0, 0, u4 + (h4 = ee2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), Qt3(n2, r2, 1, 0, c4 + l6), Qt3(n2, r2, 2, 0, c4 - l6), Qt3(n2, r2, 3, 0, u4 - h4), o3++, r2 += 32;
    }
    function re3(t4, e2, n2, r2) {
      var i3 = t4[e2 + 0] + 4, a3 = 35468 * t4[e2 + 4] >> 16, o3 = ee2(t4[e2 + 4]), s3 = 35468 * t4[e2 + 1] >> 16;
      te2(n2, r2, 0, i3 + o3, t4 = ee2(t4[e2 + 1]), s3), te2(n2, r2, 1, i3 + a3, t4, s3), te2(n2, r2, 2, i3 - a3, t4, s3), te2(n2, r2, 3, i3 - o3, t4, s3);
    }
    function ie3(t4, e2, n2, r2, i3) {
      ne3(t4, e2, n2, r2), i3 && ne3(t4, e2 + 16, n2, r2 + 4);
    }
    function ae3(t4, e2, n2, r2) {
      ar(t4, e2 + 0, n2, r2, 1), ar(t4, e2 + 32, n2, r2 + 128, 1);
    }
    function oe3(t4, e2, n2, r2) {
      var i3;
      for (t4 = t4[e2 + 0] + 4, i3 = 0; 4 > i3; ++i3) for (e2 = 0; 4 > e2; ++e2) Qt3(n2, r2, e2, i3, t4);
    }
    function se3(t4, e2, n2, r2) {
      t4[e2 + 0] && ur(t4, e2 + 0, n2, r2), t4[e2 + 16] && ur(t4, e2 + 16, n2, r2 + 4), t4[e2 + 32] && ur(t4, e2 + 32, n2, r2 + 128), t4[e2 + 48] && ur(t4, e2 + 48, n2, r2 + 128 + 4);
    }
    function ue3(t4, e2, n2, r2) {
      var i3, o3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var s3 = t4[e2 + 0 + i3] + t4[e2 + 12 + i3], u4 = t4[e2 + 4 + i3] + t4[e2 + 8 + i3], c4 = t4[e2 + 4 + i3] - t4[e2 + 8 + i3], l6 = t4[e2 + 0 + i3] - t4[e2 + 12 + i3];
        o3[0 + i3] = s3 + u4, o3[8 + i3] = s3 - u4, o3[4 + i3] = l6 + c4, o3[12 + i3] = l6 - c4;
      }
      for (i3 = 0; 4 > i3; ++i3) s3 = (t4 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], u4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], c4 = o3[1 + 4 * i3] - o3[2 + 4 * i3], l6 = t4 - o3[3 + 4 * i3], n2[r2 + 0] = s3 + u4 >> 3, n2[r2 + 16] = l6 + c4 >> 3, n2[r2 + 32] = s3 - u4 >> 3, n2[r2 + 48] = l6 - c4 >> 3, r2 += 64;
    }
    function ce3(t4, e2, n2) {
      var r2, i3 = e2 - 32, a3 = Or, o3 = 255 - t4[i3 - 1];
      for (r2 = 0; r2 < n2; ++r2) {
        var s3, u4 = a3, c4 = o3 + t4[e2 - 1];
        for (s3 = 0; s3 < n2; ++s3) t4[e2 + s3] = u4[c4 + t4[i3 + s3]];
        e2 += 32;
      }
    }
    function le3(t4, e2) {
      ce3(t4, e2, 4);
    }
    function he3(t4, e2) {
      ce3(t4, e2, 8);
    }
    function fe3(t4, e2) {
      ce3(t4, e2, 16);
    }
    function de3(t4, e2) {
      var n2;
      for (n2 = 0; 16 > n2; ++n2) r(t4, e2 + 32 * n2, t4, e2 - 32, 16);
    }
    function pe3(t4, e2) {
      var n2;
      for (n2 = 16; 0 < n2; --n2) i2(t4, e2, t4[e2 - 1], 16), e2 += 32;
    }
    function ge3(t4, e2, n2) {
      var r2;
      for (r2 = 0; 16 > r2; ++r2) i2(e2, n2 + 32 * r2, t4, 16);
    }
    function me2(t4, e2) {
      var n2, r2 = 16;
      for (n2 = 0; 16 > n2; ++n2) r2 += t4[e2 - 1 + 32 * n2] + t4[e2 + n2 - 32];
      ge3(r2 >> 5, t4, e2);
    }
    function ve3(t4, e2) {
      var n2, r2 = 8;
      for (n2 = 0; 16 > n2; ++n2) r2 += t4[e2 - 1 + 32 * n2];
      ge3(r2 >> 4, t4, e2);
    }
    function be3(t4, e2) {
      var n2, r2 = 8;
      for (n2 = 0; 16 > n2; ++n2) r2 += t4[e2 + n2 - 32];
      ge3(r2 >> 4, t4, e2);
    }
    function ye3(t4, e2) {
      ge3(128, t4, e2);
    }
    function we3(t4, e2, n2) {
      return t4 + 2 * e2 + n2 + 2 >> 2;
    }
    function Ne3(t4, e2) {
      var n2, i3 = e2 - 32;
      for (i3 = new Uint8Array([we3(t4[i3 - 1], t4[i3 + 0], t4[i3 + 1]), we3(t4[i3 + 0], t4[i3 + 1], t4[i3 + 2]), we3(t4[i3 + 1], t4[i3 + 2], t4[i3 + 3]), we3(t4[i3 + 2], t4[i3 + 3], t4[i3 + 4])]), n2 = 0; 4 > n2; ++n2) r(t4, e2 + 32 * n2, i3, 0, i3.length);
    }
    function Le3(t4, e2) {
      var n2 = t4[e2 - 1], r2 = t4[e2 - 1 + 32], i3 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 + 96];
      F14(t4, e2 + 0, 16843009 * we3(t4[e2 - 1 - 32], n2, r2)), F14(t4, e2 + 32, 16843009 * we3(n2, r2, i3)), F14(t4, e2 + 64, 16843009 * we3(r2, i3, a3)), F14(t4, e2 + 96, 16843009 * we3(i3, a3, a3));
    }
    function xe3(t4, e2) {
      var n2, r2 = 4;
      for (n2 = 0; 4 > n2; ++n2) r2 += t4[e2 + n2 - 32] + t4[e2 - 1 + 32 * n2];
      for (r2 >>= 3, n2 = 0; 4 > n2; ++n2) i2(t4, e2 + 32 * n2, r2, 4);
    }
    function Ae3(t4, e2) {
      var n2 = t4[e2 - 1 + 0], r2 = t4[e2 - 1 + 32], i3 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 - 32], o3 = t4[e2 + 0 - 32], s3 = t4[e2 + 1 - 32], u4 = t4[e2 + 2 - 32], c4 = t4[e2 + 3 - 32];
      t4[e2 + 0 + 96] = we3(r2, i3, t4[e2 - 1 + 96]), t4[e2 + 1 + 96] = t4[e2 + 0 + 64] = we3(n2, r2, i3), t4[e2 + 2 + 96] = t4[e2 + 1 + 64] = t4[e2 + 0 + 32] = we3(a3, n2, r2), t4[e2 + 3 + 96] = t4[e2 + 2 + 64] = t4[e2 + 1 + 32] = t4[e2 + 0 + 0] = we3(o3, a3, n2), t4[e2 + 3 + 64] = t4[e2 + 2 + 32] = t4[e2 + 1 + 0] = we3(s3, o3, a3), t4[e2 + 3 + 32] = t4[e2 + 2 + 0] = we3(u4, s3, o3), t4[e2 + 3 + 0] = we3(c4, u4, s3);
    }
    function Se3(t4, e2) {
      var n2 = t4[e2 + 1 - 32], r2 = t4[e2 + 2 - 32], i3 = t4[e2 + 3 - 32], a3 = t4[e2 + 4 - 32], o3 = t4[e2 + 5 - 32], s3 = t4[e2 + 6 - 32], u4 = t4[e2 + 7 - 32];
      t4[e2 + 0 + 0] = we3(t4[e2 + 0 - 32], n2, r2), t4[e2 + 1 + 0] = t4[e2 + 0 + 32] = we3(n2, r2, i3), t4[e2 + 2 + 0] = t4[e2 + 1 + 32] = t4[e2 + 0 + 64] = we3(r2, i3, a3), t4[e2 + 3 + 0] = t4[e2 + 2 + 32] = t4[e2 + 1 + 64] = t4[e2 + 0 + 96] = we3(i3, a3, o3), t4[e2 + 3 + 32] = t4[e2 + 2 + 64] = t4[e2 + 1 + 96] = we3(a3, o3, s3), t4[e2 + 3 + 64] = t4[e2 + 2 + 96] = we3(o3, s3, u4), t4[e2 + 3 + 96] = we3(s3, u4, u4);
    }
    function _e3(t4, e2) {
      var n2 = t4[e2 - 1 + 0], r2 = t4[e2 - 1 + 32], i3 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 - 32], o3 = t4[e2 + 0 - 32], s3 = t4[e2 + 1 - 32], u4 = t4[e2 + 2 - 32], c4 = t4[e2 + 3 - 32];
      t4[e2 + 0 + 0] = t4[e2 + 1 + 64] = a3 + o3 + 1 >> 1, t4[e2 + 1 + 0] = t4[e2 + 2 + 64] = o3 + s3 + 1 >> 1, t4[e2 + 2 + 0] = t4[e2 + 3 + 64] = s3 + u4 + 1 >> 1, t4[e2 + 3 + 0] = u4 + c4 + 1 >> 1, t4[e2 + 0 + 96] = we3(i3, r2, n2), t4[e2 + 0 + 64] = we3(r2, n2, a3), t4[e2 + 0 + 32] = t4[e2 + 1 + 96] = we3(n2, a3, o3), t4[e2 + 1 + 32] = t4[e2 + 2 + 96] = we3(a3, o3, s3), t4[e2 + 2 + 32] = t4[e2 + 3 + 96] = we3(o3, s3, u4), t4[e2 + 3 + 32] = we3(s3, u4, c4);
    }
    function Pe3(t4, e2) {
      var n2 = t4[e2 + 0 - 32], r2 = t4[e2 + 1 - 32], i3 = t4[e2 + 2 - 32], a3 = t4[e2 + 3 - 32], o3 = t4[e2 + 4 - 32], s3 = t4[e2 + 5 - 32], u4 = t4[e2 + 6 - 32], c4 = t4[e2 + 7 - 32];
      t4[e2 + 0 + 0] = n2 + r2 + 1 >> 1, t4[e2 + 1 + 0] = t4[e2 + 0 + 64] = r2 + i3 + 1 >> 1, t4[e2 + 2 + 0] = t4[e2 + 1 + 64] = i3 + a3 + 1 >> 1, t4[e2 + 3 + 0] = t4[e2 + 2 + 64] = a3 + o3 + 1 >> 1, t4[e2 + 0 + 32] = we3(n2, r2, i3), t4[e2 + 1 + 32] = t4[e2 + 0 + 96] = we3(r2, i3, a3), t4[e2 + 2 + 32] = t4[e2 + 1 + 96] = we3(i3, a3, o3), t4[e2 + 3 + 32] = t4[e2 + 2 + 96] = we3(a3, o3, s3), t4[e2 + 3 + 64] = we3(o3, s3, u4), t4[e2 + 3 + 96] = we3(s3, u4, c4);
    }
    function ke3(t4, e2) {
      var n2 = t4[e2 - 1 + 0], r2 = t4[e2 - 1 + 32], i3 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 + 96];
      t4[e2 + 0 + 0] = n2 + r2 + 1 >> 1, t4[e2 + 2 + 0] = t4[e2 + 0 + 32] = r2 + i3 + 1 >> 1, t4[e2 + 2 + 32] = t4[e2 + 0 + 64] = i3 + a3 + 1 >> 1, t4[e2 + 1 + 0] = we3(n2, r2, i3), t4[e2 + 3 + 0] = t4[e2 + 1 + 32] = we3(r2, i3, a3), t4[e2 + 3 + 32] = t4[e2 + 1 + 64] = we3(i3, a3, a3), t4[e2 + 3 + 64] = t4[e2 + 2 + 64] = t4[e2 + 0 + 96] = t4[e2 + 1 + 96] = t4[e2 + 2 + 96] = t4[e2 + 3 + 96] = a3;
    }
    function Fe3(t4, e2) {
      var n2 = t4[e2 - 1 + 0], r2 = t4[e2 - 1 + 32], i3 = t4[e2 - 1 + 64], a3 = t4[e2 - 1 + 96], o3 = t4[e2 - 1 - 32], s3 = t4[e2 + 0 - 32], u4 = t4[e2 + 1 - 32], c4 = t4[e2 + 2 - 32];
      t4[e2 + 0 + 0] = t4[e2 + 2 + 32] = n2 + o3 + 1 >> 1, t4[e2 + 0 + 32] = t4[e2 + 2 + 64] = r2 + n2 + 1 >> 1, t4[e2 + 0 + 64] = t4[e2 + 2 + 96] = i3 + r2 + 1 >> 1, t4[e2 + 0 + 96] = a3 + i3 + 1 >> 1, t4[e2 + 3 + 0] = we3(s3, u4, c4), t4[e2 + 2 + 0] = we3(o3, s3, u4), t4[e2 + 1 + 0] = t4[e2 + 3 + 32] = we3(n2, o3, s3), t4[e2 + 1 + 32] = t4[e2 + 3 + 64] = we3(r2, n2, o3), t4[e2 + 1 + 64] = t4[e2 + 3 + 96] = we3(i3, r2, n2), t4[e2 + 1 + 96] = we3(a3, i3, r2);
    }
    function Ie3(t4, e2) {
      var n2;
      for (n2 = 0; 8 > n2; ++n2) r(t4, e2 + 32 * n2, t4, e2 - 32, 8);
    }
    function je3(t4, e2) {
      var n2;
      for (n2 = 0; 8 > n2; ++n2) i2(t4, e2, t4[e2 - 1], 8), e2 += 32;
    }
    function Ce2(t4, e2, n2) {
      var r2;
      for (r2 = 0; 8 > r2; ++r2) i2(e2, n2 + 32 * r2, t4, 8);
    }
    function Oe2(t4, e2) {
      var n2, r2 = 8;
      for (n2 = 0; 8 > n2; ++n2) r2 += t4[e2 + n2 - 32] + t4[e2 - 1 + 32 * n2];
      Ce2(r2 >> 4, t4, e2);
    }
    function Be2(t4, e2) {
      var n2, r2 = 4;
      for (n2 = 0; 8 > n2; ++n2) r2 += t4[e2 + n2 - 32];
      Ce2(r2 >> 3, t4, e2);
    }
    function Me2(t4, e2) {
      var n2, r2 = 4;
      for (n2 = 0; 8 > n2; ++n2) r2 += t4[e2 - 1 + 32 * n2];
      Ce2(r2 >> 3, t4, e2);
    }
    function qe2(t4, e2) {
      Ce2(128, t4, e2);
    }
    function Ee2(t4, e2, n2) {
      var r2 = t4[e2 - n2], i3 = t4[e2 + 0], a3 = 3 * (i3 - r2) + jr[1020 + t4[e2 - 2 * n2] - t4[e2 + n2]], o3 = Cr[112 + (a3 + 4 >> 3)];
      t4[e2 - n2] = Or[255 + r2 + Cr[112 + (a3 + 3 >> 3)]], t4[e2 + 0] = Or[255 + i3 - o3];
    }
    function Re2(t4, e2, n2, r2) {
      var i3 = t4[e2 + 0], a3 = t4[e2 + n2];
      return Br[255 + t4[e2 - 2 * n2] - t4[e2 - n2]] > r2 || Br[255 + a3 - i3] > r2;
    }
    function De2(t4, e2, n2, r2) {
      return 4 * Br[255 + t4[e2 - n2] - t4[e2 + 0]] + Br[255 + t4[e2 - 2 * n2] - t4[e2 + n2]] <= r2;
    }
    function Te2(t4, e2, n2, r2, i3) {
      var a3 = t4[e2 - 3 * n2], o3 = t4[e2 - 2 * n2], s3 = t4[e2 - n2], u4 = t4[e2 + 0], c4 = t4[e2 + n2], l6 = t4[e2 + 2 * n2], h4 = t4[e2 + 3 * n2];
      return 4 * Br[255 + s3 - u4] + Br[255 + o3 - c4] > r2 ? 0 : Br[255 + t4[e2 - 4 * n2] - a3] <= i3 && Br[255 + a3 - o3] <= i3 && Br[255 + o3 - s3] <= i3 && Br[255 + h4 - l6] <= i3 && Br[255 + l6 - c4] <= i3 && Br[255 + c4 - u4] <= i3;
    }
    function ze2(t4, e2, n2, r2) {
      var i3 = 2 * r2 + 1;
      for (r2 = 0; 16 > r2; ++r2) De2(t4, e2 + r2, n2, i3) && Ee2(t4, e2 + r2, n2);
    }
    function Ue2(t4, e2, n2, r2) {
      var i3 = 2 * r2 + 1;
      for (r2 = 0; 16 > r2; ++r2) De2(t4, e2 + r2 * n2, 1, i3) && Ee2(t4, e2 + r2 * n2, 1);
    }
    function He2(t4, e2, n2, r2) {
      var i3;
      for (i3 = 3; 0 < i3; --i3) ze2(t4, e2 += 4 * n2, n2, r2);
    }
    function We2(t4, e2, n2, r2) {
      var i3;
      for (i3 = 3; 0 < i3; --i3) Ue2(t4, e2 += 4, n2, r2);
    }
    function Ve2(t4, e2, n2, r2, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (Te2(t4, e2, n2, a3, o3)) if (Re2(t4, e2, n2, s3)) Ee2(t4, e2, n2);
        else {
          var u4 = t4, c4 = e2, l6 = n2, h4 = u4[c4 - 2 * l6], f4 = u4[c4 - l6], d5 = u4[c4 + 0], p4 = u4[c4 + l6], g4 = u4[c4 + 2 * l6], m5 = 27 * (b5 = jr[1020 + 3 * (d5 - f4) + jr[1020 + h4 - p4]]) + 63 >> 7, v5 = 18 * b5 + 63 >> 7, b5 = 9 * b5 + 63 >> 7;
          u4[c4 - 3 * l6] = Or[255 + u4[c4 - 3 * l6] + b5], u4[c4 - 2 * l6] = Or[255 + h4 + v5], u4[c4 - l6] = Or[255 + f4 + m5], u4[c4 + 0] = Or[255 + d5 - m5], u4[c4 + l6] = Or[255 + p4 - v5], u4[c4 + 2 * l6] = Or[255 + g4 - b5];
        }
        e2 += r2;
      }
    }
    function Ge2(t4, e2, n2, r2, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (Te2(t4, e2, n2, a3, o3)) if (Re2(t4, e2, n2, s3)) Ee2(t4, e2, n2);
        else {
          var u4 = t4, c4 = e2, l6 = n2, h4 = u4[c4 - l6], f4 = u4[c4 + 0], d5 = u4[c4 + l6], p4 = Cr[112 + (4 + (g4 = 3 * (f4 - h4)) >> 3)], g4 = Cr[112 + (g4 + 3 >> 3)], m5 = p4 + 1 >> 1;
          u4[c4 - 2 * l6] = Or[255 + u4[c4 - 2 * l6] + m5], u4[c4 - l6] = Or[255 + h4 + g4], u4[c4 + 0] = Or[255 + f4 - p4], u4[c4 + l6] = Or[255 + d5 - m5];
        }
        e2 += r2;
      }
    }
    function Ye(t4, e2, n2, r2, i3, a3) {
      Ve2(t4, e2, n2, 1, 16, r2, i3, a3);
    }
    function Je2(t4, e2, n2, r2, i3, a3) {
      Ve2(t4, e2, 1, n2, 16, r2, i3, a3);
    }
    function Xe2(t4, e2, n2, r2, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3) Ge2(t4, e2 += 4 * n2, n2, 1, 16, r2, i3, a3);
    }
    function Ke2(t4, e2, n2, r2, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3) Ge2(t4, e2 += 4, 1, n2, 16, r2, i3, a3);
    }
    function Ze2(t4, e2, n2, r2, i3, a3, o3, s3) {
      Ve2(t4, e2, i3, 1, 8, a3, o3, s3), Ve2(n2, r2, i3, 1, 8, a3, o3, s3);
    }
    function $e2(t4, e2, n2, r2, i3, a3, o3, s3) {
      Ve2(t4, e2, 1, i3, 8, a3, o3, s3), Ve2(n2, r2, 1, i3, 8, a3, o3, s3);
    }
    function Qe2(t4, e2, n2, r2, i3, a3, o3, s3) {
      Ge2(t4, e2 + 4 * i3, i3, 1, 8, a3, o3, s3), Ge2(n2, r2 + 4 * i3, i3, 1, 8, a3, o3, s3);
    }
    function tn(t4, e2, n2, r2, i3, a3, o3, s3) {
      Ge2(t4, e2 + 4, 1, i3, 8, a3, o3, s3), Ge2(n2, r2 + 4, 1, i3, 8, a3, o3, s3);
    }
    function en() {
      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ut2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function nn() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function rn() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function an() {
      this.ua = 0, this.Wa = new M4(), this.vb = new M4(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d4(), this.yc = new h3();
    }
    function on() {
      this.xb = this.a = 0, this.l = new Gt3(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N5(), this.Pb = 0, this.wd = new N5(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new an(), this.ab = 0, this.gc = o2(4, rn), this.Oc = 0;
    }
    function sn() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt3(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function un(t4, e2, n2, r2, i3, a3, o3) {
      for (t4 = null == t4 ? 0 : t4[e2 + 0], e2 = 0; e2 < o3; ++e2) i3[a3 + e2] = t4 + n2[r2 + e2] & 255, t4 = i3[a3 + e2];
    }
    function cn(t4, e2, n2, r2, i3, a3, o3) {
      var s3;
      if (null == t4) un(null, null, n2, r2, i3, a3, o3);
      else for (s3 = 0; s3 < o3; ++s3) i3[a3 + s3] = t4[e2 + s3] + n2[r2 + s3] & 255;
    }
    function ln2(t4, e2, n2, r2, i3, a3, o3) {
      if (null == t4) un(null, null, n2, r2, i3, a3, o3);
      else {
        var s3, u4 = t4[e2 + 0], c4 = u4, l6 = u4;
        for (s3 = 0; s3 < o3; ++s3) c4 = l6 + (u4 = t4[e2 + s3]) - c4, l6 = n2[r2 + s3] + (-256 & c4 ? 0 > c4 ? 0 : 255 : c4) & 255, c4 = u4, i3[a3 + s3] = l6;
      }
    }
    function hn(t4, n2, i3, o3) {
      var s3 = n2.width, u4 = n2.o;
      if (e(null != t4 && null != n2), 0 > i3 || 0 >= o3 || i3 + o3 > u4) return null;
      if (!t4.Cc) {
        if (null == t4.ga) {
          var c4;
          if (t4.ga = new sn(), (c4 = null == t4.ga) || (c4 = n2.width * n2.o, e(0 == t4.Gb.length), t4.Gb = a2(c4), t4.Uc = 0, null == t4.Gb ? c4 = 0 : (t4.mb = t4.Gb, t4.nb = t4.Uc, t4.rc = null, c4 = 1), c4 = !c4), !c4) {
            c4 = t4.ga;
            var l6 = t4.Fa, h4 = t4.P, f4 = t4.qc, d5 = t4.mb, p4 = t4.nb, g4 = h4 + 1, m5 = f4 - 1, b5 = c4.l;
            if (e(null != l6 && null != d5 && null != n2), gi[0] = null, gi[1] = un, gi[2] = cn, gi[3] = ln2, c4.ca = d5, c4.tb = p4, c4.c = n2.width, c4.i = n2.height, e(0 < c4.c && 0 < c4.i), 1 >= f4) n2 = 0;
            else if (c4.$a = 3 & l6[h4 + 0], c4.Z = l6[h4 + 0] >> 2 & 3, c4.Lc = l6[h4 + 0] >> 4 & 3, h4 = l6[h4 + 0] >> 6 & 3, 0 > c4.$a || 1 < c4.$a || 4 <= c4.Z || 1 < c4.Lc || h4) n2 = 0;
            else if (b5.put = dt2, b5.ac = ft2, b5.bc = pt2, b5.ma = c4, b5.width = n2.width, b5.height = n2.height, b5.Da = n2.Da, b5.v = n2.v, b5.va = n2.va, b5.j = n2.j, b5.o = n2.o, c4.$a) t: {
              e(1 == c4.$a), n2 = kt2();
              e: for (; ; ) {
                if (null == n2) {
                  n2 = 0;
                  break t;
                }
                if (e(null != c4), c4.mc = n2, n2.c = c4.c, n2.i = c4.i, n2.l = c4.l, n2.l.ma = c4, n2.l.width = c4.c, n2.l.height = c4.i, n2.a = 0, v4(n2.m, l6, g4, m5), !Ft3(c4.c, c4.i, 1, n2, null)) break e;
                if (1 == n2.ab && 3 == n2.gc[0].hc && xt2(n2.s) ? (c4.ic = 1, l6 = n2.c * n2.i, n2.Ta = null, n2.Ua = 0, n2.V = a2(l6), n2.Ba = 0, null == n2.V ? (n2.a = 1, n2 = 0) : n2 = 1) : (c4.ic = 0, n2 = It2(n2, c4.c)), !n2) break e;
                n2 = 1;
                break t;
              }
              c4.mc = null, n2 = 0;
            }
            else n2 = m5 >= c4.c * c4.i;
            c4 = !n2;
          }
          if (c4) return null;
          1 != t4.ga.Lc ? t4.Ga = 0 : o3 = u4 - i3;
        }
        e(null != t4.ga), e(i3 + o3 <= u4);
        t: {
          if (n2 = (l6 = t4.ga).c, u4 = l6.l.o, 0 == l6.$a) {
            if (g4 = t4.rc, m5 = t4.Vc, b5 = t4.Fa, h4 = t4.P + 1 + i3 * n2, f4 = t4.mb, d5 = t4.nb + i3 * n2, e(h4 <= t4.P + t4.qc), 0 != l6.Z) for (e(null != gi[l6.Z]), c4 = 0; c4 < o3; ++c4) gi[l6.Z](g4, m5, b5, h4, f4, d5, n2), g4 = f4, m5 = d5, d5 += n2, h4 += n2;
            else for (c4 = 0; c4 < o3; ++c4) r(f4, d5, b5, h4, n2), g4 = f4, m5 = d5, d5 += n2, h4 += n2;
            t4.rc = g4, t4.Vc = m5;
          } else {
            if (e(null != l6.mc), n2 = i3 + o3, e(null != (c4 = l6.mc)), e(n2 <= c4.i), c4.C >= n2) n2 = 1;
            else if (l6.ic || mn(), l6.ic) {
              l6 = c4.V, g4 = c4.Ba, m5 = c4.c;
              var y5 = c4.i, w5 = (b5 = 1, h4 = c4.$ / m5, f4 = c4.$ % m5, d5 = c4.m, p4 = c4.s, c4.$), N6 = m5 * y5, L6 = m5 * n2, A5 = p4.wc, _4 = w5 < L6 ? wt2(p4, f4, h4) : null;
              e(w5 <= N6), e(n2 <= y5), e(xt2(p4));
              e: for (; ; ) {
                for (; !d5.h && w5 < L6; ) {
                  if (f4 & A5 || (_4 = wt2(p4, f4, h4)), e(null != _4), S4(d5), 256 > (y5 = bt2(_4.G[0], _4.H[0], d5))) l6[g4 + w5] = y5, ++w5, ++f4 >= m5 && (f4 = 0, ++h4 <= n2 && !(h4 % 16) && St2(c4, h4));
                  else {
                    if (!(280 > y5)) {
                      b5 = 0;
                      break e;
                    }
                    y5 = mt2(y5 - 256, d5);
                    var P5, k4 = bt2(_4.G[4], _4.H[4], d5);
                    if (S4(d5), !(w5 >= (k4 = vt2(m5, k4 = mt2(k4, d5))) && N6 - w5 >= y5)) {
                      b5 = 0;
                      break e;
                    }
                    for (P5 = 0; P5 < y5; ++P5) l6[g4 + w5 + P5] = l6[g4 + w5 + P5 - k4];
                    for (w5 += y5, f4 += y5; f4 >= m5; ) f4 -= m5, ++h4 <= n2 && !(h4 % 16) && St2(c4, h4);
                    w5 < L6 && f4 & A5 && (_4 = wt2(p4, f4, h4));
                  }
                  e(d5.h == x4(d5));
                }
                St2(c4, h4 > n2 ? n2 : h4);
                break e;
              }
              !b5 || d5.h && w5 < N6 ? (b5 = 0, c4.a = d5.h ? 5 : 3) : c4.$ = w5, n2 = b5;
            } else n2 = _t2(c4, c4.V, c4.Ba, c4.c, c4.i, n2, jt2);
            if (!n2) {
              o3 = 0;
              break t;
            }
          }
          i3 + o3 >= u4 && (t4.Cc = 1), o3 = 1;
        }
        if (!o3) return null;
        if (t4.Cc && (null != (o3 = t4.ga) && (o3.mc = null), t4.ga = null, 0 < t4.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return t4.nb + i3 * s3;
    }
    function fn(t4, e2, n2, r2, i3, a3) {
      for (; 0 < i3--; ) {
        var o3, s3 = t4, u4 = e2 + (n2 ? 1 : 0), c4 = t4, l6 = e2 + (n2 ? 0 : 3);
        for (o3 = 0; o3 < r2; ++o3) {
          var h4 = c4[l6 + 4 * o3];
          255 != h4 && (h4 *= 32897, s3[u4 + 4 * o3 + 0] = s3[u4 + 4 * o3 + 0] * h4 >> 23, s3[u4 + 4 * o3 + 1] = s3[u4 + 4 * o3 + 1] * h4 >> 23, s3[u4 + 4 * o3 + 2] = s3[u4 + 4 * o3 + 2] * h4 >> 23);
        }
        e2 += a3;
      }
    }
    function dn(t4, e2, n2, r2, i3) {
      for (; 0 < r2--; ) {
        var a3;
        for (a3 = 0; a3 < n2; ++a3) {
          var o3 = t4[e2 + 2 * a3 + 0], s3 = 15 & (c4 = t4[e2 + 2 * a3 + 1]), u4 = 4369 * s3, c4 = (240 & c4 | c4 >> 4) * u4 >> 16;
          t4[e2 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * u4 >> 16 & 240 | (15 & o3 | o3 << 4) * u4 >> 16 >> 4 & 15, t4[e2 + 2 * a3 + 1] = 240 & c4 | s3;
        }
        e2 += i3;
      }
    }
    function pn(t4, e2, n2, r2, i3, a3, o3, s3) {
      var u4, c4, l6 = 255;
      for (c4 = 0; c4 < i3; ++c4) {
        for (u4 = 0; u4 < r2; ++u4) {
          var h4 = t4[e2 + u4];
          a3[o3 + 4 * u4] = h4, l6 &= h4;
        }
        e2 += n2, o3 += s3;
      }
      return 255 != l6;
    }
    function gn(t4, e2, n2, r2, i3) {
      var a3;
      for (a3 = 0; a3 < i3; ++a3) n2[r2 + a3] = t4[e2 + a3] >> 8;
    }
    function mn() {
      Lr = fn, xr = dn, Ar = pn, Sr = gn;
    }
    function vn(n2, r2, i3) {
      t3[n2] = function(t4, n3, a3, o3, s3, u4, c4, l6, h4, f4, d5, p4, g4, m5, v5, b5, y5) {
        var w5, N6 = y5 - 1 >> 1, L6 = s3[u4 + 0] | c4[l6 + 0] << 16, x5 = h4[f4 + 0] | d5[p4 + 0] << 16;
        e(null != t4);
        var A5 = 3 * L6 + x5 + 131074 >> 2;
        for (r2(t4[n3 + 0], 255 & A5, A5 >> 16, g4, m5), null != a3 && (A5 = 3 * x5 + L6 + 131074 >> 2, r2(a3[o3 + 0], 255 & A5, A5 >> 16, v5, b5)), w5 = 1; w5 <= N6; ++w5) {
          var S5 = s3[u4 + w5] | c4[l6 + w5] << 16, _4 = h4[f4 + w5] | d5[p4 + w5] << 16, P5 = L6 + S5 + x5 + _4 + 524296, k4 = P5 + 2 * (S5 + x5) >> 3;
          A5 = k4 + L6 >> 1, L6 = (P5 = P5 + 2 * (L6 + _4) >> 3) + S5 >> 1, r2(t4[n3 + 2 * w5 - 1], 255 & A5, A5 >> 16, g4, m5 + (2 * w5 - 1) * i3), r2(t4[n3 + 2 * w5 - 0], 255 & L6, L6 >> 16, g4, m5 + (2 * w5 - 0) * i3), null != a3 && (A5 = P5 + x5 >> 1, L6 = k4 + _4 >> 1, r2(a3[o3 + 2 * w5 - 1], 255 & A5, A5 >> 16, v5, b5 + (2 * w5 - 1) * i3), r2(a3[o3 + 2 * w5 + 0], 255 & L6, L6 >> 16, v5, b5 + (2 * w5 + 0) * i3)), L6 = S5, x5 = _4;
        }
        1 & y5 || (A5 = 3 * L6 + x5 + 131074 >> 2, r2(t4[n3 + y5 - 1], 255 & A5, A5 >> 16, g4, m5 + (y5 - 1) * i3), null != a3 && (A5 = 3 * x5 + L6 + 131074 >> 2, r2(a3[o3 + y5 - 1], 255 & A5, A5 >> 16, v5, b5 + (y5 - 1) * i3)));
      };
    }
    function bn() {
      mi[Mr] = vi, mi[qr] = yi, mi[Er] = bi, mi[Rr] = wi, mi[Dr] = Ni, mi[Tr] = Li, mi[zr] = xi, mi[Ur] = yi, mi[Hr] = wi, mi[Wr] = Ni, mi[Vr] = Li;
    }
    function yn(t4) {
      return t4 & ~Fi ? 0 > t4 ? 0 : 255 : t4 >> ki;
    }
    function wn(t4, e2) {
      return yn((19077 * t4 >> 8) + (26149 * e2 >> 8) - 14234);
    }
    function Nn(t4, e2, n2) {
      return yn((19077 * t4 >> 8) - (6419 * e2 >> 8) - (13320 * n2 >> 8) + 8708);
    }
    function Ln(t4, e2) {
      return yn((19077 * t4 >> 8) + (33050 * e2 >> 8) - 17685);
    }
    function xn(t4, e2, n2, r2, i3) {
      r2[i3 + 0] = wn(t4, n2), r2[i3 + 1] = Nn(t4, e2, n2), r2[i3 + 2] = Ln(t4, e2);
    }
    function An(t4, e2, n2, r2, i3) {
      r2[i3 + 0] = Ln(t4, e2), r2[i3 + 1] = Nn(t4, e2, n2), r2[i3 + 2] = wn(t4, n2);
    }
    function Sn(t4, e2, n2, r2, i3) {
      var a3 = Nn(t4, e2, n2);
      e2 = a3 << 3 & 224 | Ln(t4, e2) >> 3, r2[i3 + 0] = 248 & wn(t4, n2) | a3 >> 5, r2[i3 + 1] = e2;
    }
    function _n(t4, e2, n2, r2, i3) {
      var a3 = 240 & Ln(t4, e2) | 15;
      r2[i3 + 0] = 240 & wn(t4, n2) | Nn(t4, e2, n2) >> 4, r2[i3 + 1] = a3;
    }
    function Pn(t4, e2, n2, r2, i3) {
      r2[i3 + 0] = 255, xn(t4, e2, n2, r2, i3 + 1);
    }
    function kn(t4, e2, n2, r2, i3) {
      An(t4, e2, n2, r2, i3), r2[i3 + 3] = 255;
    }
    function Fn(t4, e2, n2, r2, i3) {
      xn(t4, e2, n2, r2, i3), r2[i3 + 3] = 255;
    }
    function Vt2(t4, e2) {
      return 0 > t4 ? 0 : t4 > e2 ? e2 : t4;
    }
    function In(e2, n2, r2) {
      t3[e2] = function(t4, e3, i3, a3, o3, s3, u4, c4, l6) {
        for (var h4 = c4 + (-2 & l6) * r2; c4 != h4; ) n2(t4[e3 + 0], i3[a3 + 0], o3[s3 + 0], u4, c4), n2(t4[e3 + 1], i3[a3 + 0], o3[s3 + 0], u4, c4 + r2), e3 += 2, ++a3, ++s3, c4 += 2 * r2;
        1 & l6 && n2(t4[e3 + 0], i3[a3 + 0], o3[s3 + 0], u4, c4);
      };
    }
    function jn(t4, e2, n2) {
      return 0 == n2 ? 0 == t4 ? 0 == e2 ? 6 : 5 : 0 == e2 ? 4 : 0 : n2;
    }
    function Cn(t4, e2, n2, r2, i3) {
      switch (t4 >>> 30) {
        case 3:
          ar(e2, n2, r2, i3, 0);
          break;
        case 2:
          or(e2, n2, r2, i3);
          break;
        case 1:
          ur(e2, n2, r2, i3);
      }
    }
    function On(t4, e2) {
      var n2, a3, o3 = e2.M, s3 = e2.Nb, u4 = t4.oc, c4 = t4.pc + 40, l6 = t4.oc, h4 = t4.pc + 584, f4 = t4.oc, d5 = t4.pc + 600;
      for (n2 = 0; 16 > n2; ++n2) u4[c4 + 32 * n2 - 1] = 129;
      for (n2 = 0; 8 > n2; ++n2) l6[h4 + 32 * n2 - 1] = 129, f4[d5 + 32 * n2 - 1] = 129;
      for (0 < o3 ? u4[c4 - 1 - 32] = l6[h4 - 1 - 32] = f4[d5 - 1 - 32] = 129 : (i2(u4, c4 - 32 - 1, 127, 21), i2(l6, h4 - 32 - 1, 127, 9), i2(f4, d5 - 32 - 1, 127, 9)), a3 = 0; a3 < t4.za; ++a3) {
        var p4 = e2.ya[e2.aa + a3];
        if (0 < a3) {
          for (n2 = -1; 16 > n2; ++n2) r(u4, c4 + 32 * n2 - 4, u4, c4 + 32 * n2 + 12, 4);
          for (n2 = -1; 8 > n2; ++n2) r(l6, h4 + 32 * n2 - 4, l6, h4 + 32 * n2 + 4, 4), r(f4, d5 + 32 * n2 - 4, f4, d5 + 32 * n2 + 4, 4);
        }
        var g4 = t4.Gd, m5 = t4.Hd + a3, v5 = p4.ad, b5 = p4.Hc;
        if (0 < o3 && (r(u4, c4 - 32, g4[m5].y, 0, 16), r(l6, h4 - 32, g4[m5].f, 0, 8), r(f4, d5 - 32, g4[m5].ea, 0, 8)), p4.Za) {
          var y5 = u4, w5 = c4 - 32 + 16;
          for (0 < o3 && (a3 >= t4.za - 1 ? i2(y5, w5, g4[m5].y[15], 4) : r(y5, w5, g4[m5 + 1].y, 0, 4)), n2 = 0; 4 > n2; n2++) y5[w5 + 128 + n2] = y5[w5 + 256 + n2] = y5[w5 + 384 + n2] = y5[w5 + 0 + n2];
          for (n2 = 0; 16 > n2; ++n2, b5 <<= 2) y5 = u4, w5 = c4 + Ei[n2], hi[p4.Ob[n2]](y5, w5), Cn(b5, v5, 16 * +n2, y5, w5);
        } else if (y5 = jn(a3, o3, p4.Ob[0]), li[y5](u4, c4), 0 != b5) for (n2 = 0; 16 > n2; ++n2, b5 <<= 2) Cn(b5, v5, 16 * +n2, u4, c4 + Ei[n2]);
        for (n2 = p4.Gc, y5 = jn(a3, o3, p4.Dd), fi[y5](l6, h4), fi[y5](f4, d5), b5 = v5, y5 = l6, w5 = h4, 255 & (p4 = 0 | n2) && (170 & p4 ? sr(b5, 256, y5, w5) : cr(b5, 256, y5, w5)), p4 = f4, b5 = d5, 255 & (n2 >>= 8) && (170 & n2 ? sr(v5, 320, p4, b5) : cr(v5, 320, p4, b5)), o3 < t4.Ub - 1 && (r(g4[m5].y, 0, u4, c4 + 480, 16), r(g4[m5].f, 0, l6, h4 + 224, 8), r(g4[m5].ea, 0, f4, d5 + 224, 8)), n2 = 8 * s3 * t4.B, g4 = t4.sa, m5 = t4.ta + 16 * a3 + 16 * s3 * t4.R, v5 = t4.qa, p4 = t4.ra + 8 * a3 + n2, b5 = t4.Ha, y5 = t4.Ia + 8 * a3 + n2, n2 = 0; 16 > n2; ++n2) r(g4, m5 + n2 * t4.R, u4, c4 + 32 * n2, 16);
        for (n2 = 0; 8 > n2; ++n2) r(v5, p4 + n2 * t4.B, l6, h4 + 32 * n2, 8), r(b5, y5 + n2 * t4.B, f4, d5 + 32 * n2, 8);
      }
    }
    function Bn(t4, r2, i3, a3, o3, s3, u4, c4, l6) {
      var h4 = [0], f4 = [0], d5 = 0, p4 = null != l6 ? l6.kd : 0, g4 = null != l6 ? l6 : new nn();
      if (null == t4 || 12 > i3) return 7;
      g4.data = t4, g4.w = r2, g4.ha = i3, r2 = [r2], i3 = [i3], g4.gb = [g4.gb];
      t: {
        var m5 = r2, b5 = i3, y5 = g4.gb;
        if (e(null != t4), e(null != b5), e(null != y5), y5[0] = 0, 12 <= b5[0] && !n(t4, m5[0], "RIFF")) {
          if (n(t4, m5[0] + 8, "WEBP")) {
            y5 = 3;
            break t;
          }
          var w5 = C4(t4, m5[0] + 4);
          if (12 > w5 || 4294967286 < w5) {
            y5 = 3;
            break t;
          }
          if (p4 && w5 > b5[0] - 8) {
            y5 = 7;
            break t;
          }
          y5[0] = w5, m5[0] += 12, b5[0] -= 12;
        }
        y5 = 0;
      }
      if (0 != y5) return y5;
      for (w5 = 0 < g4.gb[0], i3 = i3[0]; ; ) {
        t: {
          var L6 = t4;
          b5 = r2, y5 = i3;
          var x5 = h4, A5 = f4, S5 = m5 = [0];
          if ((k4 = d5 = [d5])[0] = 0, 8 > y5[0]) y5 = 7;
          else {
            if (!n(L6, b5[0], "VP8X")) {
              if (10 != C4(L6, b5[0] + 4)) {
                y5 = 3;
                break t;
              }
              if (18 > y5[0]) {
                y5 = 7;
                break t;
              }
              var _4 = C4(L6, b5[0] + 8), P5 = 1 + j3(L6, b5[0] + 12);
              if (2147483648 <= P5 * (L6 = 1 + j3(L6, b5[0] + 15))) {
                y5 = 3;
                break t;
              }
              null != S5 && (S5[0] = _4), null != x5 && (x5[0] = P5), null != A5 && (A5[0] = L6), b5[0] += 18, y5[0] -= 18, k4[0] = 1;
            }
            y5 = 0;
          }
        }
        if (d5 = d5[0], m5 = m5[0], 0 != y5) return y5;
        if (b5 = !!(2 & m5), !w5 && d5) return 3;
        if (null != s3 && (s3[0] = !!(16 & m5)), null != u4 && (u4[0] = b5), null != c4 && (c4[0] = 0), u4 = h4[0], m5 = f4[0], d5 && b5 && null == l6) {
          y5 = 0;
          break;
        }
        if (4 > i3) {
          y5 = 7;
          break;
        }
        if (w5 && d5 || !w5 && !d5 && !n(t4, r2[0], "ALPH")) {
          i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
          t: {
            _4 = t4, y5 = r2, w5 = i3;
            var k4 = g4.gb;
            x5 = g4.na, A5 = g4.P, S5 = g4.Sa, P5 = 22, e(null != _4), e(null != w5), L6 = y5[0];
            var F15 = w5[0];
            for (e(null != x5), e(null != S5), x5[0] = null, A5[0] = null, S5[0] = 0; ; ) {
              if (y5[0] = L6, w5[0] = F15, 8 > F15) {
                y5 = 7;
                break t;
              }
              var I5 = C4(_4, L6 + 4);
              if (4294967286 < I5) {
                y5 = 3;
                break t;
              }
              var O4 = 8 + I5 + 1 & -2;
              if (P5 += O4, 0 < k4 && P5 > k4) {
                y5 = 3;
                break t;
              }
              if (!n(_4, L6, "VP8 ") || !n(_4, L6, "VP8L")) {
                y5 = 0;
                break t;
              }
              if (F15[0] < O4) {
                y5 = 7;
                break t;
              }
              n(_4, L6, "ALPH") || (x5[0] = _4, A5[0] = L6 + 8, S5[0] = I5), L6 += O4, F15 -= O4;
            }
          }
          if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], 0 != y5) break;
        }
        i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
        t: if (k4 = t4, y5 = r2, w5 = i3, x5 = g4.gb[0], A5 = g4.Ja, S5 = g4.xa, _4 = y5[0], L6 = !n(k4, _4, "VP8 "), P5 = !n(k4, _4, "VP8L"), e(null != k4), e(null != w5), e(null != A5), e(null != S5), 8 > w5[0]) y5 = 7;
        else {
          if (L6 || P5) {
            if (k4 = C4(k4, _4 + 4), 12 <= x5 && k4 > x5 - 12) {
              y5 = 3;
              break t;
            }
            if (p4 && k4 > w5[0] - 8) {
              y5 = 7;
              break t;
            }
            A5[0] = k4, y5[0] += 8, w5[0] -= 8, S5[0] = P5;
          } else S5[0] = 5 <= w5[0] && 47 == k4[_4 + 0] && !(k4[_4 + 4] >> 5), A5[0] = w5[0];
          y5 = 0;
        }
        if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], r2 = r2[0], 0 != y5) break;
        if (4294967286 < g4.Ja) return 3;
        if (null == c4 || b5 || (c4[0] = g4.xa ? 2 : 1), u4 = [u4], m5 = [m5], g4.xa) {
          if (5 > i3) {
            y5 = 7;
            break;
          }
          c4 = u4, p4 = m5, b5 = s3, null == t4 || 5 > i3 ? t4 = 0 : 5 <= i3 && 47 == t4[r2 + 0] && !(t4[r2 + 4] >> 5) ? (w5 = [0], k4 = [0], x5 = [0], v4(A5 = new N5(), t4, r2, i3), gt2(A5, w5, k4, x5) ? (null != c4 && (c4[0] = w5[0]), null != p4 && (p4[0] = k4[0]), null != b5 && (b5[0] = x5[0]), t4 = 1) : t4 = 0) : t4 = 0;
        } else {
          if (10 > i3) {
            y5 = 7;
            break;
          }
          c4 = m5, null == t4 || 10 > i3 || !Xt2(t4, r2 + 3, i3 - 3) ? t4 = 0 : (p4 = t4[r2 + 0] | t4[r2 + 1] << 8 | t4[r2 + 2] << 16, b5 = 16383 & (t4[r2 + 7] << 8 | t4[r2 + 6]), t4 = 16383 & (t4[r2 + 9] << 8 | t4[r2 + 8]), 1 & p4 || 3 < (p4 >> 1 & 7) || !(p4 >> 4 & 1) || p4 >> 5 >= g4.Ja || !b5 || !t4 ? t4 = 0 : (u4 && (u4[0] = b5), c4 && (c4[0] = t4), t4 = 1));
        }
        if (!t4) return 3;
        if (u4 = u4[0], m5 = m5[0], d5 && (h4[0] != u4 || f4[0] != m5)) return 3;
        null != l6 && (l6[0] = g4, l6.offset = r2 - l6.w, e(4294967286 > r2 - l6.w), e(l6.offset == l6.ha - i3));
        break;
      }
      return 0 == y5 || 7 == y5 && d5 && null == l6 ? (null != s3 && (s3[0] |= null != g4.na && 0 < g4.na.length), null != a3 && (a3[0] = u4), null != o3 && (o3[0] = m5), 0) : y5;
    }
    function Mn(t4, e2, n2) {
      var r2 = e2.width, i3 = e2.height, a3 = 0, o3 = 0, s3 = r2, u4 = i3;
      if (e2.Da = null != t4 && 0 < t4.Da, e2.Da && (s3 = t4.cd, u4 = t4.bd, a3 = t4.v, o3 = t4.j, 11 > n2 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= u4 || a3 + s3 > r2 || o3 + u4 > i3)) return 0;
      if (e2.v = a3, e2.j = o3, e2.va = a3 + s3, e2.o = o3 + u4, e2.U = s3, e2.T = u4, e2.da = null != t4 && 0 < t4.da, e2.da) {
        if (!q3(s3, u4, n2 = [t4.ib], a3 = [t4.hb])) return 0;
        e2.ib = n2[0], e2.hb = a3[0];
      }
      return e2.ob = null != t4 && t4.ob, e2.Kb = null == t4 || !t4.Sd, e2.da && (e2.ob = e2.ib < 3 * r2 / 4 && e2.hb < 3 * i3 / 4, e2.Kb = 0), 1;
    }
    function qn(t4) {
      if (null == t4) return 2;
      if (11 > t4.S) {
        var e2 = t4.f.RGBA;
        e2.fb += (t4.height - 1) * e2.A, e2.A = -e2.A;
      } else e2 = t4.f.kb, t4 = t4.height, e2.O += (t4 - 1) * e2.fa, e2.fa = -e2.fa, e2.N += (t4 - 1 >> 1) * e2.Ab, e2.Ab = -e2.Ab, e2.W += (t4 - 1 >> 1) * e2.Db, e2.Db = -e2.Db, null != e2.F && (e2.J += (t4 - 1) * e2.lb, e2.lb = -e2.lb);
      return 0;
    }
    function En(t4, e2, n2, r2) {
      if (null == r2 || 0 >= t4 || 0 >= e2) return 2;
      if (null != n2) {
        if (n2.Da) {
          var i3 = n2.cd, o3 = n2.bd, s3 = -2 & n2.v, u4 = -2 & n2.j;
          if (0 > s3 || 0 > u4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t4 || u4 + o3 > e2) return 2;
          t4 = i3, e2 = o3;
        }
        if (n2.da) {
          if (!q3(t4, e2, i3 = [n2.ib], o3 = [n2.hb])) return 2;
          t4 = i3[0], e2 = o3[0];
        }
      }
      r2.width = t4, r2.height = e2;
      t: {
        var c4 = r2.width, l6 = r2.height;
        if (t4 = r2.S, 0 >= c4 || 0 >= l6 || !(t4 >= Mr && 13 > t4)) t4 = 2;
        else {
          if (0 >= r2.Rd && null == r2.sd) {
            s3 = o3 = i3 = e2 = 0;
            var h4 = (u4 = c4 * zi[t4]) * l6;
            if (11 > t4 || (o3 = (l6 + 1) / 2 * (e2 = (c4 + 1) / 2), 12 == t4 && (s3 = (i3 = c4) * l6)), null == (l6 = a2(h4 + 2 * o3 + s3))) {
              t4 = 1;
              break t;
            }
            r2.sd = l6, 11 > t4 ? ((c4 = r2.f.RGBA).eb = l6, c4.fb = 0, c4.A = u4, c4.size = h4) : ((c4 = r2.f.kb).y = l6, c4.O = 0, c4.fa = u4, c4.Fd = h4, c4.f = l6, c4.N = 0 + h4, c4.Ab = e2, c4.Cd = o3, c4.ea = l6, c4.W = 0 + h4 + o3, c4.Db = e2, c4.Ed = o3, 12 == t4 && (c4.F = l6, c4.J = 0 + h4 + 2 * o3), c4.Tc = s3, c4.lb = i3);
          }
          if (e2 = 1, i3 = r2.S, o3 = r2.width, s3 = r2.height, i3 >= Mr && 13 > i3) if (11 > i3) t4 = r2.f.RGBA, e2 &= (u4 = Math.abs(t4.A)) * (s3 - 1) + o3 <= t4.size, e2 &= u4 >= o3 * zi[i3], e2 &= null != t4.eb;
          else {
            t4 = r2.f.kb, u4 = (o3 + 1) / 2, h4 = (s3 + 1) / 2, c4 = Math.abs(t4.fa), l6 = Math.abs(t4.Ab);
            var f4 = Math.abs(t4.Db), d5 = Math.abs(t4.lb), p4 = d5 * (s3 - 1) + o3;
            e2 &= c4 * (s3 - 1) + o3 <= t4.Fd, e2 &= l6 * (h4 - 1) + u4 <= t4.Cd, e2 = (e2 &= f4 * (h4 - 1) + u4 <= t4.Ed) & c4 >= o3 & l6 >= u4 & f4 >= u4, e2 &= null != t4.y, e2 &= null != t4.f, e2 &= null != t4.ea, 12 == i3 && (e2 &= d5 >= o3, e2 &= p4 <= t4.Tc, e2 &= null != t4.F);
          }
          else e2 = 0;
          t4 = e2 ? 0 : 2;
        }
      }
      return 0 != t4 || null != n2 && n2.fd && (t4 = qn(r2)), t4;
    }
    var Rn = 64, Dn = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tn = 24, zn = 32, Un = 8, Hn = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    D4("Predictor0", "PredictorAdd0"), t3.Predictor0 = function() {
      return 4278190080;
    }, t3.Predictor1 = function(t4) {
      return t4;
    }, t3.Predictor2 = function(t4, e2, n2) {
      return e2[n2 + 0];
    }, t3.Predictor3 = function(t4, e2, n2) {
      return e2[n2 + 1];
    }, t3.Predictor4 = function(t4, e2, n2) {
      return e2[n2 - 1];
    }, t3.Predictor5 = function(t4, e2, n2) {
      return z3(z3(t4, e2[n2 + 1]), e2[n2 + 0]);
    }, t3.Predictor6 = function(t4, e2, n2) {
      return z3(t4, e2[n2 - 1]);
    }, t3.Predictor7 = function(t4, e2, n2) {
      return z3(t4, e2[n2 + 0]);
    }, t3.Predictor8 = function(t4, e2, n2) {
      return z3(e2[n2 - 1], e2[n2 + 0]);
    }, t3.Predictor9 = function(t4, e2, n2) {
      return z3(e2[n2 + 0], e2[n2 + 1]);
    }, t3.Predictor10 = function(t4, e2, n2) {
      return z3(z3(t4, e2[n2 - 1]), z3(e2[n2 + 0], e2[n2 + 1]));
    }, t3.Predictor11 = function(t4, e2, n2) {
      var r2 = e2[n2 + 0];
      return 0 >= W4(r2 >> 24 & 255, t4 >> 24 & 255, (e2 = e2[n2 - 1]) >> 24 & 255) + W4(r2 >> 16 & 255, t4 >> 16 & 255, e2 >> 16 & 255) + W4(r2 >> 8 & 255, t4 >> 8 & 255, e2 >> 8 & 255) + W4(255 & r2, 255 & t4, 255 & e2) ? r2 : t4;
    }, t3.Predictor12 = function(t4, e2, n2) {
      var r2 = e2[n2 + 0];
      return (U4((t4 >> 24 & 255) + (r2 >> 24 & 255) - ((e2 = e2[n2 - 1]) >> 24 & 255)) << 24 | U4((t4 >> 16 & 255) + (r2 >> 16 & 255) - (e2 >> 16 & 255)) << 16 | U4((t4 >> 8 & 255) + (r2 >> 8 & 255) - (e2 >> 8 & 255)) << 8 | U4((255 & t4) + (255 & r2) - (255 & e2))) >>> 0;
    }, t3.Predictor13 = function(t4, e2, n2) {
      var r2 = e2[n2 - 1];
      return (H3((t4 = z3(t4, e2[n2 + 0])) >> 24 & 255, r2 >> 24 & 255) << 24 | H3(t4 >> 16 & 255, r2 >> 16 & 255) << 16 | H3(t4 >> 8 & 255, r2 >> 8 & 255) << 8 | H3(255 & t4, 255 & r2)) >>> 0;
    };
    var Wn = t3.PredictorAdd0;
    t3.PredictorAdd1 = V4, D4("Predictor2", "PredictorAdd2"), D4("Predictor3", "PredictorAdd3"), D4("Predictor4", "PredictorAdd4"), D4("Predictor5", "PredictorAdd5"), D4("Predictor6", "PredictorAdd6"), D4("Predictor7", "PredictorAdd7"), D4("Predictor8", "PredictorAdd8"), D4("Predictor9", "PredictorAdd9"), D4("Predictor10", "PredictorAdd10"), D4("Predictor11", "PredictorAdd11"), D4("Predictor12", "PredictorAdd12"), D4("Predictor13", "PredictorAdd13");
    var Vn = t3.PredictorAdd2;
    X4("ColorIndexInverseTransform", "MapARGB", "32b", function(t4) {
      return t4 >> 8 & 255;
    }, function(t4) {
      return t4;
    }), X4("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t4) {
      return t4;
    }, function(t4) {
      return t4 >> 8 & 255;
    });
    var Gn, Yn = t3.ColorIndexInverseTransform, Jn = t3.MapARGB, Xn = t3.VP8LColorIndexInverseTransformAlpha, Kn = t3.MapAlpha, Zn = t3.VP8LPredictorsAdd = [];
    Zn.length = 16, (t3.VP8LPredictors = []).length = 16, (t3.VP8LPredictorsAdd_C = []).length = 16, (t3.VP8LPredictors_C = []).length = 16;
    var $n, Qn, tr, er, nr, rr, ir, ar, or, sr, ur, cr, lr, hr, fr, dr, pr, gr, mr, vr, br, yr, wr, Nr, Lr, xr, Ar, Sr, _r = a2(511), Pr = a2(2041), kr = a2(225), Fr = a2(767), Ir = 0, jr = Pr, Cr = kr, Or = Fr, Br = _r, Mr = 0, qr = 1, Er = 2, Rr = 3, Dr = 4, Tr = 5, zr = 6, Ur = 7, Hr = 8, Wr = 9, Vr = 10, Gr = [2, 3, 7], Yr = [3, 3, 11], Jr = [280, 256, 256, 256, 40], Xr = [0, 1, 1, 1, 0], Kr = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Zr = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], $r = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Qr = 8, ti = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ei = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ri = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ii = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], ai = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], oi = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], si = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], ci = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], hi = [], fi = [], di = 1, pi = 2, gi = [], mi = [];
    vn("UpsampleRgbLinePair", xn, 3), vn("UpsampleBgrLinePair", An, 3), vn("UpsampleRgbaLinePair", Fn, 4), vn("UpsampleBgraLinePair", kn, 4), vn("UpsampleArgbLinePair", Pn, 4), vn("UpsampleRgba4444LinePair", _n, 2), vn("UpsampleRgb565LinePair", Sn, 2);
    var vi = t3.UpsampleRgbLinePair, bi = t3.UpsampleBgrLinePair, yi = t3.UpsampleRgbaLinePair, wi = t3.UpsampleBgraLinePair, Ni = t3.UpsampleArgbLinePair, Li = t3.UpsampleRgba4444LinePair, xi = t3.UpsampleRgb565LinePair, Ai = 16, Si = 1 << Ai - 1, _i = -227, Pi = 482, ki = 6, Fi = (256 << ki) - 1, Ii = 0, ji = a2(256), Ci = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(Pi - _i), qi = a2(Pi - _i);
    In("YuvToRgbRow", xn, 3), In("YuvToBgrRow", An, 3), In("YuvToRgbaRow", Fn, 4), In("YuvToBgraRow", kn, 4), In("YuvToArgbRow", Pn, 4), In("YuvToRgba4444Row", _n, 2), In("YuvToRgb565Row", Sn, 2);
    var Ei = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Di = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ti = 1;
    this.WebPDecodeRGBA = function(t4, n2, s3, u4, c4) {
      var l6 = qr, h4 = new en(), f4 = new ot2();
      h4.ba = f4, f4.S = l6, f4.width = [f4.width], f4.height = [f4.height];
      var d5 = f4.width, p4 = f4.height, g4 = new st2();
      if (null == g4 || null == t4) var m5 = 2;
      else e(null != g4), m5 = Bn(t4, n2, s3, g4.width, g4.height, g4.Pd, g4.Qd, g4.format, null);
      if (0 != m5 ? d5 = 0 : (null != d5 && (d5[0] = g4.width[0]), null != p4 && (p4[0] = g4.height[0]), d5 = 1), d5) {
        f4.width = f4.width[0], f4.height = f4.height[0], null != u4 && (u4[0] = f4.width), null != c4 && (c4[0] = f4.height);
        t: {
          if (u4 = new Gt3(), (c4 = new nn()).data = t4, c4.w = n2, c4.ha = s3, c4.kd = 1, n2 = [0], e(null != c4), (0 == (t4 = Bn(c4.data, c4.w, c4.ha, null, null, null, n2, null, c4)) || 7 == t4) && n2[0] && (t4 = 4), 0 == (n2 = t4)) {
            if (e(null != h4), u4.data = c4.data, u4.w = c4.w + c4.offset, u4.ha = c4.ha - c4.offset, u4.put = dt2, u4.ac = ft2, u4.bc = pt2, u4.ma = h4, c4.xa) {
              if (null == (t4 = kt2())) {
                h4 = 1;
                break t;
              }
              if ((function(t5, n3) {
                var r2 = [0], i3 = [0], a3 = [0];
                e: for (; ; ) {
                  if (null == t5) return 0;
                  if (null == n3) return t5.a = 2, 0;
                  if (t5.l = n3, t5.a = 0, v4(t5.m, n3.data, n3.w, n3.ha), !gt2(t5.m, r2, i3, a3)) {
                    t5.a = 3;
                    break e;
                  }
                  if (t5.xb = pi, n3.width = r2[0], n3.height = i3[0], !Ft3(r2[0], i3[0], 1, t5, null)) break e;
                  return 1;
                }
                return e(0 != t5.a), 0;
              })(t4, u4)) {
                if (u4 = 0 == (n2 = En(u4.width, u4.height, h4.Oa, h4.ba))) {
                  e: {
                    u4 = t4;
                    n: for (; ; ) {
                      if (null == u4) {
                        u4 = 0;
                        break e;
                      }
                      if (e(null != u4.s.yc), e(null != u4.s.Ya), e(0 < u4.s.Wb), e(null != (s3 = u4.l)), e(null != (c4 = s3.ma)), 0 != u4.xb) {
                        if (u4.ca = c4.ba, u4.tb = c4.tb, e(null != u4.ca), !Mn(c4.Oa, s3, Rr)) {
                          u4.a = 2;
                          break n;
                        }
                        if (!It2(u4, s3.width)) break n;
                        if (s3.da) break n;
                        if ((s3.da || rt2(u4.ca.S)) && mn(), 11 > u4.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != u4.ca.f.kb.F && mn()), u4.Pb && 0 < u4.s.ua && null == u4.s.vb.X && !O3(u4.s.vb, u4.s.Wa.Xa)) {
                          u4.a = 1;
                          break n;
                        }
                        u4.xb = 0;
                      }
                      if (!_t2(u4, u4.V, u4.Ba, u4.c, u4.i, s3.o, Lt2)) break n;
                      c4.Dc = u4.Ma, u4 = 1;
                      break e;
                    }
                    e(0 != u4.a), u4 = 0;
                  }
                  u4 = !u4;
                }
                u4 && (n2 = t4.a);
              } else n2 = t4.a;
            } else {
              if (null == (t4 = new Yt2())) {
                h4 = 1;
                break t;
              }
              if (t4.Fa = c4.na, t4.P = c4.P, t4.qc = c4.Sa, Kt2(t4, u4)) {
                if (0 == (n2 = En(u4.width, u4.height, h4.Oa, h4.ba))) {
                  if (t4.Aa = 0, s3 = h4.Oa, e(null != (c4 = t4)), null != s3) {
                    if (0 < (d5 = 0 > (d5 = s3.Md) ? 0 : 100 < d5 ? 255 : 255 * d5 / 100)) {
                      for (p4 = g4 = 0; 4 > p4; ++p4) 12 > (m5 = c4.pb[p4]).lc && (m5.ia = d5 * Di[0 > m5.lc ? 0 : m5.lc] >> 3), g4 |= m5.ia;
                      g4 && (alert("todo:VP8InitRandom"), c4.ia = 1);
                    }
                    c4.Ga = s3.Id, 100 < c4.Ga ? c4.Ga = 100 : 0 > c4.Ga && (c4.Ga = 0);
                  }
                  (function(t5, n3) {
                    if (null == t5) return 0;
                    if (null == n3) return Jt2(t5, 2, "NULL VP8Io parameter in VP8Decode().");
                    if (!t5.cb && !Kt2(t5, n3)) return 0;
                    if (e(t5.cb), null == n3.ac || n3.ac(n3)) {
                      n3.ob && (t5.L = 0);
                      var s4 = Ri[t5.L];
                      if (2 == t5.L ? (t5.yb = 0, t5.zb = 0) : (t5.yb = n3.v - s4 >> 4, t5.zb = n3.j - s4 >> 4, 0 > t5.yb && (t5.yb = 0), 0 > t5.zb && (t5.zb = 0)), t5.Va = n3.o + 15 + s4 >> 4, t5.Hb = n3.va + 15 + s4 >> 4, t5.Hb > t5.za && (t5.Hb = t5.za), t5.Va > t5.Ub && (t5.Va = t5.Ub), 0 < t5.L) {
                        var u5 = t5.ed;
                        for (s4 = 0; 4 > s4; ++s4) {
                          var c5;
                          if (t5.Qa.Cb) {
                            var l7 = t5.Qa.Lb[s4];
                            t5.Qa.Fb || (l7 += u5.Tb);
                          } else l7 = u5.Tb;
                          for (c5 = 0; 1 >= c5; ++c5) {
                            var h5 = t5.gd[s4][c5], f5 = l7;
                            if (u5.Pc && (f5 += u5.vd[0], c5 && (f5 += u5.od[0])), 0 < (f5 = 0 > f5 ? 0 : 63 < f5 ? 63 : f5)) {
                              var d6 = f5;
                              0 < u5.wb && (d6 = 4 < u5.wb ? d6 >> 2 : d6 >> 1) > 9 - u5.wb && (d6 = 9 - u5.wb), 1 > d6 && (d6 = 1), h5.dd = d6, h5.tc = 2 * f5 + d6, h5.ld = 40 <= f5 ? 2 : 15 <= f5 ? 1 : 0;
                            } else h5.tc = 0;
                            h5.La = c5;
                          }
                        }
                      }
                      s4 = 0;
                    } else Jt2(t5, 6, "Frame setup failed"), s4 = t5.a;
                    if (s4 = 0 == s4) {
                      if (s4) {
                        t5.$c = 0, 0 < t5.Aa || (t5.Ic = Ti);
                        e: {
                          s4 = t5.Ic, u5 = 4 * (d6 = t5.za);
                          var p5 = 32 * d6, g5 = d6 + 1, m6 = 0 < t5.L ? d6 * (0 < t5.Aa ? 2 : 1) : 0, v5 = (2 == t5.Aa ? 2 : 1) * d6;
                          if ((h5 = u5 + 832 + (c5 = 3 * (16 * s4 + Ri[t5.L]) / 2 * p5) + (l7 = null != t5.Fa && 0 < t5.Fa.length ? t5.Kc.c * t5.Kc.i : 0)) != h5) s4 = 0;
                          else {
                            if (h5 > t5.Vb) {
                              if (t5.Vb = 0, t5.Ec = a2(h5), t5.Fc = 0, null == t5.Ec) {
                                s4 = Jt2(t5, 1, "no memory during frame initialization.");
                                break e;
                              }
                              t5.Vb = h5;
                            }
                            h5 = t5.Ec, f5 = t5.Fc, t5.Ac = h5, t5.Bc = f5, f5 += u5, t5.Gd = o2(p5, Ht3), t5.Hd = 0, t5.rb = o2(g5 + 1, Dt2), t5.sb = 1, t5.wa = m6 ? o2(m6, Rt2) : null, t5.Y = 0, t5.D.Nb = 0, t5.D.wa = t5.wa, t5.D.Y = t5.Y, 0 < t5.Aa && (t5.D.Y += d6), e(true), t5.oc = h5, t5.pc = f5, f5 += 832, t5.ya = o2(v5, zt2), t5.aa = 0, t5.D.ya = t5.ya, t5.D.aa = t5.aa, 2 == t5.Aa && (t5.D.aa += d6), t5.R = 16 * d6, t5.B = 8 * d6, d6 = (p5 = Ri[t5.L]) * t5.R, p5 = p5 / 2 * t5.B, t5.sa = h5, t5.ta = f5 + d6, t5.qa = t5.sa, t5.ra = t5.ta + 16 * s4 * t5.R + p5, t5.Ha = t5.qa, t5.Ia = t5.ra + 8 * s4 * t5.B + p5, t5.$c = 0, f5 += c5, t5.mb = l7 ? h5 : null, t5.nb = l7 ? f5 : null, e(f5 + l7 <= t5.Fc + t5.Vb), $t2(t5), i2(t5.Ac, t5.Bc, 0, u5), s4 = 1;
                          }
                        }
                        if (s4) {
                          if (n3.ka = 0, n3.y = t5.sa, n3.O = t5.ta, n3.f = t5.qa, n3.N = t5.ra, n3.ea = t5.Ha, n3.Vd = t5.Ia, n3.fa = t5.R, n3.Rc = t5.B, n3.F = null, n3.J = 0, !Ir) {
                            for (s4 = -255; 255 >= s4; ++s4) _r[255 + s4] = 0 > s4 ? -s4 : s4;
                            for (s4 = -1020; 1020 >= s4; ++s4) Pr[1020 + s4] = -128 > s4 ? -128 : 127 < s4 ? 127 : s4;
                            for (s4 = -112; 112 >= s4; ++s4) kr[112 + s4] = -16 > s4 ? -16 : 15 < s4 ? 15 : s4;
                            for (s4 = -255; 510 >= s4; ++s4) Fr[255 + s4] = 0 > s4 ? 0 : 255 < s4 ? 255 : s4;
                            Ir = 1;
                          }
                          ir = ue3, ar = ie3, sr = ae3, ur = oe3, cr = se3, or = re3, lr = Ye, hr = Je2, fr = Ze2, dr = $e2, pr = Xe2, gr = Ke2, mr = Qe2, vr = tn, br = ze2, yr = Ue2, wr = He2, Nr = We2, hi[0] = xe3, hi[1] = le3, hi[2] = Ne3, hi[3] = Le3, hi[4] = Ae3, hi[5] = _e3, hi[6] = Se3, hi[7] = Pe3, hi[8] = Fe3, hi[9] = ke3, li[0] = me2, li[1] = fe3, li[2] = de3, li[3] = pe3, li[4] = ve3, li[5] = be3, li[6] = ye3, fi[0] = Oe2, fi[1] = he3, fi[2] = Ie3, fi[3] = je3, fi[4] = Me2, fi[5] = Be2, fi[6] = qe2, s4 = 1;
                        } else s4 = 0;
                      }
                      s4 && (s4 = (function(t6, n4) {
                        for (t6.M = 0; t6.M < t6.Va; ++t6.M) {
                          var o3, s5 = t6.Jc[t6.M & t6.Xb], u6 = t6.m, c6 = t6;
                          for (o3 = 0; o3 < c6.za; ++o3) {
                            var l8 = u6, h6 = c6, f6 = h6.Ac, d7 = h6.Bc + 4 * o3, p6 = h6.zc, g6 = h6.ya[h6.aa + o3];
                            if (h6.Qa.Bb ? g6.$b = k3(l8, h6.Pa.jb[0]) ? 2 + k3(l8, h6.Pa.jb[2]) : k3(l8, h6.Pa.jb[1]) : g6.$b = 0, h6.kc && (g6.Ad = k3(l8, h6.Bd)), g6.Za = !k3(l8, 145) + 0, g6.Za) {
                              var m7 = g6.Ob, v6 = 0;
                              for (h6 = 0; 4 > h6; ++h6) {
                                var b5, y5 = p6[0 + h6];
                                for (b5 = 0; 4 > b5; ++b5) {
                                  y5 = si[f6[d7 + b5]][y5];
                                  for (var w5 = ai[k3(l8, y5[0])]; 0 < w5; ) w5 = ai[2 * w5 + k3(l8, y5[w5])];
                                  y5 = -w5, f6[d7 + b5] = y5;
                                }
                                r(m7, v6, f6, d7, 4), v6 += 4, p6[0 + h6] = y5;
                              }
                            } else y5 = k3(l8, 156) ? k3(l8, 128) ? 1 : 3 : k3(l8, 163) ? 2 : 0, g6.Ob[0] = y5, i2(f6, d7, y5, 4), i2(p6, 0, y5, 4);
                            g6.Dd = k3(l8, 142) ? k3(l8, 114) ? k3(l8, 183) ? 1 : 3 : 2 : 0;
                          }
                          if (c6.m.Ka) return Jt2(t6, 7, "Premature end-of-partition0 encountered.");
                          for (; t6.ja < t6.za; ++t6.ja) {
                            if (c6 = s5, l8 = (u6 = t6).rb[u6.sb - 1], f6 = u6.rb[u6.sb + u6.ja], o3 = u6.ya[u6.aa + u6.ja], d7 = u6.kc ? o3.Ad : 0) l8.la = f6.la = 0, o3.Za || (l8.Na = f6.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
                            else {
                              var N6, L6;
                              if (l8 = f6, f6 = c6, d7 = u6.Pa.Xc, p6 = u6.ya[u6.aa + u6.ja], g6 = u6.pb[p6.$b], h6 = p6.ad, m7 = 0, v6 = u6.rb[u6.sb - 1], y5 = b5 = 0, i2(h6, m7, 0, 384), p6.Za) var x5 = 0, A5 = d7[3];
                              else {
                                w5 = a2(16);
                                var S5 = l8.Na + v6.Na;
                                if (S5 = ni(f6, d7[1], S5, g6.Eb, 0, w5, 0), l8.Na = v6.Na = (0 < S5) + 0, 1 < S5) ir(w5, 0, h6, m7);
                                else {
                                  var _4 = w5[0] + 3 >> 3;
                                  for (w5 = 0; 256 > w5; w5 += 16) h6[m7 + w5] = _4;
                                }
                                x5 = 1, A5 = d7[0];
                              }
                              var P5 = 15 & l8.la, F15 = 15 & v6.la;
                              for (w5 = 0; 4 > w5; ++w5) {
                                var I5 = 1 & F15;
                                for (_4 = L6 = 0; 4 > _4; ++_4) P5 = P5 >> 1 | (I5 = (S5 = ni(f6, A5, S5 = I5 + (1 & P5), g6.Sc, x5, h6, m7)) > x5) << 7, L6 = L6 << 2 | (3 < S5 ? 3 : 1 < S5 ? 2 : 0 != h6[m7 + 0]), m7 += 16;
                                P5 >>= 4, F15 = F15 >> 1 | I5 << 7, b5 = (b5 << 8 | L6) >>> 0;
                              }
                              for (A5 = P5, x5 = F15 >> 4, N6 = 0; 4 > N6; N6 += 2) {
                                for (L6 = 0, P5 = l8.la >> 4 + N6, F15 = v6.la >> 4 + N6, w5 = 0; 2 > w5; ++w5) {
                                  for (I5 = 1 & F15, _4 = 0; 2 > _4; ++_4) S5 = I5 + (1 & P5), P5 = P5 >> 1 | (I5 = 0 < (S5 = ni(f6, d7[2], S5, g6.Qc, 0, h6, m7))) << 3, L6 = L6 << 2 | (3 < S5 ? 3 : 1 < S5 ? 2 : 0 != h6[m7 + 0]), m7 += 16;
                                  P5 >>= 2, F15 = F15 >> 1 | I5 << 5;
                                }
                                y5 |= L6 << 4 * N6, A5 |= P5 << 4 << N6, x5 |= (240 & F15) << N6;
                              }
                              l8.la = A5, v6.la = x5, p6.Hc = b5, p6.Gc = y5, p6.ia = 43690 & y5 ? 0 : g6.ia, d7 = !(b5 | y5);
                            }
                            if (0 < u6.L && (u6.wa[u6.Y + u6.ja] = u6.gd[o3.$b][o3.Za], u6.wa[u6.Y + u6.ja].La |= !d7), c6.Ka) return Jt2(t6, 7, "Premature end-of-file encountered.");
                          }
                          if ($t2(t6), u6 = n4, c6 = 1, o3 = (s5 = t6).D, l8 = 0 < s5.L && s5.M >= s5.zb && s5.M <= s5.Va, 0 == s5.Aa) e: {
                            if (o3.M = s5.M, o3.uc = l8, On(s5, o3), c6 = 1, o3 = (L6 = s5.D).Nb, l8 = (y5 = Ri[s5.L]) * s5.R, f6 = y5 / 2 * s5.B, w5 = 16 * o3 * s5.R, _4 = 8 * o3 * s5.B, d7 = s5.sa, p6 = s5.ta - l8 + w5, g6 = s5.qa, h6 = s5.ra - f6 + _4, m7 = s5.Ha, v6 = s5.Ia - f6 + _4, F15 = 0 == (P5 = L6.M), b5 = P5 >= s5.Va - 1, 2 == s5.Aa && On(s5, L6), L6.uc) for (I5 = (S5 = s5).D.M, e(S5.D.uc), L6 = S5.yb; L6 < S5.Hb; ++L6) {
                              x5 = L6, A5 = I5;
                              var j4 = (C5 = (z4 = S5).D).Nb;
                              N6 = z4.R;
                              var C5 = C5.wa[C5.Y + x5], O4 = z4.sa, B5 = z4.ta + 16 * j4 * N6 + 16 * x5, M5 = C5.dd, q4 = C5.tc;
                              if (0 != q4) if (e(3 <= q4), 1 == z4.L) 0 < x5 && yr(O4, B5, N6, q4 + 4), C5.La && Nr(O4, B5, N6, q4), 0 < A5 && br(O4, B5, N6, q4 + 4), C5.La && wr(O4, B5, N6, q4);
                              else {
                                var E5 = z4.B, R4 = z4.qa, D5 = z4.ra + 8 * j4 * E5 + 8 * x5, T5 = z4.Ha, z4 = z4.Ia + 8 * j4 * E5 + 8 * x5;
                                j4 = C5.ld, 0 < x5 && (hr(O4, B5, N6, q4 + 4, M5, j4), dr(R4, D5, T5, z4, E5, q4 + 4, M5, j4)), C5.La && (gr(O4, B5, N6, q4, M5, j4), vr(R4, D5, T5, z4, E5, q4, M5, j4)), 0 < A5 && (lr(O4, B5, N6, q4 + 4, M5, j4), fr(R4, D5, T5, z4, E5, q4 + 4, M5, j4)), C5.La && (pr(O4, B5, N6, q4, M5, j4), mr(R4, D5, T5, z4, E5, q4, M5, j4));
                              }
                            }
                            if (s5.ia && alert("todo:DitherRow"), null != u6.put) {
                              if (L6 = 16 * P5, P5 = 16 * (P5 + 1), F15 ? (u6.y = s5.sa, u6.O = s5.ta + w5, u6.f = s5.qa, u6.N = s5.ra + _4, u6.ea = s5.Ha, u6.W = s5.Ia + _4) : (L6 -= y5, u6.y = d7, u6.O = p6, u6.f = g6, u6.N = h6, u6.ea = m7, u6.W = v6), b5 || (P5 -= y5), P5 > u6.o && (P5 = u6.o), u6.F = null, u6.J = null, null != s5.Fa && 0 < s5.Fa.length && L6 < P5 && (u6.J = hn(s5, u6, L6, P5 - L6), u6.F = s5.mb, null == u6.F && 0 == u6.F.length)) {
                                c6 = Jt2(s5, 3, "Could not decode alpha data.");
                                break e;
                              }
                              L6 < u6.j && (y5 = u6.j - L6, L6 = u6.j, e(!(1 & y5)), u6.O += s5.R * y5, u6.N += s5.B * (y5 >> 1), u6.W += s5.B * (y5 >> 1), null != u6.F && (u6.J += u6.width * y5)), L6 < P5 && (u6.O += u6.v, u6.N += u6.v >> 1, u6.W += u6.v >> 1, null != u6.F && (u6.J += u6.v), u6.ka = L6 - u6.j, u6.U = u6.va - u6.v, u6.T = P5 - L6, c6 = u6.put(u6));
                            }
                            o3 + 1 != s5.Ic || b5 || (r(s5.sa, s5.ta - l8, d7, p6 + 16 * s5.R, l8), r(s5.qa, s5.ra - f6, g6, h6 + 8 * s5.B, f6), r(s5.Ha, s5.Ia - f6, m7, v6 + 8 * s5.B, f6));
                          }
                          if (!c6) return Jt2(t6, 6, "Output aborted.");
                        }
                        return 1;
                      })(t5, n3)), null != n3.bc && n3.bc(n3), s4 &= 1;
                    }
                    return s4 ? (t5.cb = 0, s4) : 0;
                  })(t4, u4) || (n2 = t4.a);
                }
              } else n2 = t4.a;
            }
            0 == n2 && null != h4.Oa && h4.Oa.fd && (n2 = qn(h4.ba));
          }
          h4 = n2;
        }
        l6 = 0 != h4 ? null : 11 > l6 ? f4.f.RGBA.eb : f4.f.kb.y;
      } else l6 = null;
      return l6;
    };
    var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function c2(t3, e2) {
    for (var n2 = "", r2 = 0; r2 < 4; r2++) n2 += String.fromCharCode(t3[e2++]);
    return n2;
  }
  function l4(t3, e2) {
    return t3[e2 + 0] | t3[e2 + 1] << 8;
  }
  function h2(t3, e2) {
    return (t3[e2 + 0] | t3[e2 + 1] << 8 | t3[e2 + 2] << 16) >>> 0;
  }
  function f2(t3, e2) {
    return (t3[e2 + 0] | t3[e2 + 1] << 8 | t3[e2 + 2] << 16 | t3[e2 + 3] << 24) >>> 0;
  }
  new u2();
  var d3 = [0], p2 = [0], g2 = [], m3 = new u2(), v3 = t2, b3 = (function(t3, e2) {
    var n2 = {}, r2 = 0, i3 = false, a3 = 0, o3 = 0;
    if (n2.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    (function(t4, e3) {
      for (var n3 = 0; n3 < 4; n3++) if (t4[e3 + n3] != "RIFF".charCodeAt(n3)) return true;
      return false;
    })(t3, e2)) {
      for (f2(t3, e2 += 4), e2 += 8; e2 < t3.length; ) {
        var s3 = c2(t3, e2), u3 = f2(t3, e2 += 4);
        e2 += 4;
        var d4 = u3 + (1 & u3);
        switch (s3) {
          case "VP8 ":
          case "VP8L":
            void 0 === n2.frames[r2] && (n2.frames[r2] = {}), (m4 = n2.frames[r2]).src_off = i3 ? o3 : e2 - 8, m4.src_size = a3 + u3 + 8, r2++, i3 && (i3 = false, a3 = 0, o3 = 0);
            break;
          case "VP8X":
            (m4 = n2.header = {}).feature_flags = t3[e2];
            var p3 = e2 + 4;
            m4.canvas_width = 1 + h2(t3, p3), p3 += 3, m4.canvas_height = 1 + h2(t3, p3), p3 += 3;
            break;
          case "ALPH":
            i3 = true, a3 = d4 + 8, o3 = e2 - 8;
            break;
          case "ANIM":
            (m4 = n2.header).bgcolor = f2(t3, e2), p3 = e2 + 4, m4.loop_count = l4(t3, p3), p3 += 2;
            break;
          case "ANMF":
            var g3, m4;
            (m4 = n2.frames[r2] = {}).offset_x = 2 * h2(t3, e2), e2 += 3, m4.offset_y = 2 * h2(t3, e2), e2 += 3, m4.width = 1 + h2(t3, e2), e2 += 3, m4.height = 1 + h2(t3, e2), e2 += 3, m4.duration = h2(t3, e2), e2 += 3, g3 = t3[e2++], m4.dispose = 1 & g3, m4.blend = g3 >> 1 & 1;
        }
        "ANMF" != s3 && (e2 += d4);
      }
      return n2;
    }
  })(v3, 0);
  b3.response = v3, b3.rgbaoutput = true, b3.dataurl = false;
  var y3 = b3.header ? b3.header : null, w3 = b3.frames ? b3.frames : null;
  if (y3) {
    y3.loop_counter = y3.loop_count, d3 = [y3.canvas_height], p2 = [y3.canvas_width];
    for (var N4 = 0; N4 < w3.length && 0 != w3[N4].blend; N4++) ;
  }
  var L4 = w3[0], x3 = m3.WebPDecodeRGBA(v3, L4.src_off, L4.src_size, p2, d3);
  L4.rgba = x3, L4.imgwidth = p2[0], L4.imgheight = d3[0];
  for (var A3 = 0; A3 < p2[0] * d3[0] * 4; A3++) g2[A3] = x3[A3];
  return this.width = p2, this.height = d3, this.data = g2, this;
}
var i, o, l3, f, d2, L3, _2, F13, R2, D3, T3, z2, U3, H2, W3, V3, G3, Y2, J3, X3, K3, Z2, $2, Q3, tt, et2, nt, rt, it, at, ot, st, ut, ct, lt, ht, ft, dt, pt, gt, mt, vt, bt, yt, wt, Nt2, Lt, xt, At, St, Pt, kt, Ft2, It, jt, Bt, Mt, Tt, zt, Ut2, Ht2, Wt, Vt, Gt2, Yt, Jt, he2, fe2, de2, pe2, ge2, me, ve2, be2, ye2, we2, Ne2, Le2, xe2, Ae2, Se2, _e2, Pe2, ke2, Fe2, Ie2, je2;
var init_jspdf_es_min = __esm({
  "node_modules/jspdf/dist/jspdf.es.min.js"() {
    "use strict";
    init_typeof();
    init_browser();
    init_slicedToArray();
    init_lib_esm();
    i = /* @__PURE__ */ (function() {
      return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
    })();
    o = { log: a, warn: function(t2) {
      i.console && ("function" == typeof i.console.warn ? i.console.warn.apply(i.console, arguments) : a.call(null, arguments));
    }, error: function(t2) {
      i.console && ("function" == typeof i.console.error ? i.console.error.apply(i.console, arguments) : a(t2));
    } };
    l3 = i.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : _typeof(window)) || window !== i ? function() {
    } : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t2, e, n) {
      var r = i.URL || i.webkitURL, a2 = document.createElement("a");
      e = e || t2.name || "download", a2.download = e, a2.rel = "noopener", "string" == typeof t2 ? (a2.href = t2, a2.origin !== location.origin ? u(a2.href) ? s(t2, e, n) : c(a2, a2.target = "_blank") : c(a2)) : (a2.href = r.createObjectURL(t2), setTimeout(function() {
        r.revokeObjectURL(a2.href);
      }, 4e4), setTimeout(function() {
        c(a2);
      }, 0));
    } : "msSaveOrOpenBlob" in navigator ? function(e, n, r) {
      if (n = n || e.name || "download", "string" == typeof e) if (u(e)) s(e, n, r);
      else {
        var i2 = document.createElement("a");
        i2.href = e, i2.target = "_blank", setTimeout(function() {
          c(i2);
        });
      }
      else navigator.msSaveOrOpenBlob((function(e2, n2) {
        return void 0 === n2 ? n2 = { autoBom: false } : "object" !== _typeof(n2) && (o.warn("Deprecated: Expected third argument to be a object"), n2 = { autoBom: !n2 }), n2.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e2.type) ? new Blob([String.fromCharCode(65279), e2], { type: e2.type }) : e2;
      })(e, r), n);
    } : function(e, n, r, a2) {
      if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), "string" == typeof e) return s(e, n, r);
      var o2 = "application/octet-stream" === e.type, u2 = /constructor/i.test(i.HTMLElement) || i.safari, c2 = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((c2 || o2 && u2) && "object" === ("undefined" == typeof FileReader ? "undefined" : _typeof(FileReader))) {
        var l4 = new FileReader();
        l4.onloadend = function() {
          var t2 = l4.result;
          t2 = c2 ? t2 : t2.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t2 : location = t2, a2 = null;
        }, l4.readAsDataURL(e);
      } else {
        var h2 = i.URL || i.webkitURL, f2 = h2.createObjectURL(e);
        a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
          h2.revokeObjectURL(f2);
        }, 4e4);
      }
    });
    f = i.atob.bind(i);
    d2 = i.btoa.bind(i);
    L3 = "0123456789abcdef".split("");
    _2 = "5d41402abc4b2a76b9719d911017c592" != (function(t2) {
      for (var e = 0; e < t2.length; e++) t2[e] = x2(t2[e]);
      return t2.join("");
    })(w2("hello"));
    F13 = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
    I3.prototype.lsbFirstWord = function(t2) {
      return String.fromCharCode(255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, t2 >> 24 & 255);
    }, I3.prototype.toHexString = function(t2) {
      return t2.split("").map(function(t3) {
        return ("0" + (255 & t3.charCodeAt(0)).toString(16)).slice(-2);
      }).join("");
    }, I3.prototype.hexToBytes = function(t2) {
      for (var e = [], n = 0; n < t2.length; n += 2) e.push(String.fromCharCode(parseInt(t2.substr(n, 2), 16)));
      return e.join("");
    }, I3.prototype.processOwnerPassword = function(t2, e) {
      return k2(S3(e).substr(0, 5), t2);
    }, I3.prototype.encryptor = function(t2, e) {
      var n = S3(this.encryptionKey + String.fromCharCode(255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
      return function(t3) {
        return k2(n, t3);
      };
    }, O2.prototype.equals = function(e) {
      var n, r = "id,objectNumber,equals";
      if (!e || _typeof(e) !== _typeof(this)) return false;
      var i2 = 0;
      for (n in this) if (!(r.indexOf(n) >= 0)) {
        if (this.hasOwnProperty(n) && !e.hasOwnProperty(n)) return false;
        if (this[n] !== e[n]) return false;
        i2++;
      }
      for (n in e) e.hasOwnProperty(n) && r.indexOf(n) < 0 && i2--;
      return 0 === i2;
    }, E3.API = { events: [] }, E3.version = "3.0.3";
    R2 = E3.API;
    D3 = 1;
    T3 = function(t2) {
      return t2.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
    };
    z2 = function(t2) {
      return t2.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
    };
    U3 = function(t2) {
      return t2.toFixed(2);
    };
    H2 = function(t2) {
      return t2.toFixed(5);
    };
    R2.__acroform__ = {};
    W3 = function(t2, e) {
      t2.prototype = Object.create(e.prototype), t2.prototype.constructor = t2;
    };
    V3 = function(t2) {
      return t2 * D3;
    };
    G3 = function(t2) {
      var e = new ct(), n = xt.internal.getHeight(t2) || 0, r = xt.internal.getWidth(t2) || 0;
      return e.BBox = [0, 0, Number(U3(r)), Number(U3(n))], e;
    };
    Y2 = R2.__acroform__.setBit = function(t2, e) {
      if (t2 = t2 || 0, e = e || 0, isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
      return t2 | 1 << e;
    };
    J3 = R2.__acroform__.clearBit = function(t2, e) {
      if (t2 = t2 || 0, e = e || 0, isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
      return t2 & ~(1 << e);
    };
    X3 = R2.__acroform__.getBit = function(t2, e) {
      if (isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
      return t2 & 1 << e ? 1 : 0;
    };
    K3 = R2.__acroform__.getBitForPdf = function(t2, e) {
      if (isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
      return X3(t2, e - 1);
    };
    Z2 = R2.__acroform__.setBitForPdf = function(t2, e) {
      if (isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
      return Y2(t2, e - 1);
    };
    $2 = R2.__acroform__.clearBitForPdf = function(t2, e) {
      if (isNaN(t2) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
      return J3(t2, e - 1);
    };
    Q3 = R2.__acroform__.calculateCoordinates = function(t2, e) {
      var n = e.internal.getHorizontalCoordinate, r = e.internal.getVerticalCoordinate, i2 = t2[0], a2 = t2[1], o2 = t2[2], s2 = t2[3], u2 = {};
      return u2.lowerLeft_X = n(i2) || 0, u2.lowerLeft_Y = r(a2 + s2) || 0, u2.upperRight_X = n(i2 + o2) || 0, u2.upperRight_Y = r(a2) || 0, [Number(U3(u2.lowerLeft_X)), Number(U3(u2.lowerLeft_Y)), Number(U3(u2.upperRight_X)), Number(U3(u2.upperRight_Y))];
    };
    tt = function(t2) {
      if (t2.appearanceStreamContent) return t2.appearanceStreamContent;
      if (t2.V || t2.DV) {
        var e = [], n = t2._V || t2.DV, r = et2(t2, n), i2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id;
        e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(t2.scope.__private__.encodeColorString(t2.color)), e.push("/" + i2 + " " + U3(r.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(r.text), e.push("ET"), e.push("Q"), e.push("EMC");
        var a2 = G3(t2);
        return a2.scope = t2.scope, a2.stream = e.join("\n"), a2;
      }
    };
    et2 = function(t2, e) {
      var n = 0 === t2.fontSize ? t2.maxFontSize : t2.fontSize, r = { text: "", fontSize: "" }, i2 = (e = ")" == (e = "(" == e.substr(0, 1) ? e.substr(1) : e).substr(e.length - 1) ? e.substr(0, e.length - 1) : e).split(" ");
      i2 = t2.multiline ? i2.map(function(t3) {
        return t3.split("\n");
      }) : i2.map(function(t3) {
        return [t3];
      });
      var a2 = n, o2 = xt.internal.getHeight(t2) || 0;
      o2 = o2 < 0 ? -o2 : o2;
      var s2 = xt.internal.getWidth(t2) || 0;
      s2 = s2 < 0 ? -s2 : s2;
      var u2 = function(e2, n2, r2) {
        if (e2 + 1 < i2.length) {
          var a3 = n2 + " " + i2[e2 + 1][0];
          return nt(a3, t2, r2).width <= s2 - 4;
        }
        return false;
      };
      a2++;
      t: for (; a2 > 0; ) {
        e = "", a2--;
        var c2, l4, h2 = nt("3", t2, a2).height, f2 = t2.multiline ? o2 - a2 : (o2 - h2) / 2, d3 = f2 += 2, p2 = 0, g2 = 0, m3 = 0;
        if (a2 <= 0) {
          e = "(...) Tj\n", e += "% Width of Text: " + nt(e, t2, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
          break;
        }
        for (var v3 = "", b3 = 0, y3 = 0; y3 < i2.length; y3++) if (i2.hasOwnProperty(y3)) {
          var w3 = false;
          if (1 !== i2[y3].length && m3 !== i2[y3].length - 1) {
            if ((h2 + 2) * (b3 + 2) + 2 > o2) continue t;
            v3 += i2[y3][m3], w3 = true, g2 = y3, y3--;
          } else {
            v3 = " " == (v3 += i2[y3][m3] + " ").substr(v3.length - 1) ? v3.substr(0, v3.length - 1) : v3;
            var N4 = parseInt(y3), L4 = u2(N4, v3, a2), x3 = y3 >= i2.length - 1;
            if (L4 && !x3) {
              v3 += " ", m3 = 0;
              continue;
            }
            if (L4 || x3) {
              if (x3) g2 = N4;
              else if (t2.multiline && (h2 + 2) * (b3 + 2) + 2 > o2) continue t;
            } else {
              if (!t2.multiline) continue t;
              if ((h2 + 2) * (b3 + 2) + 2 > o2) continue t;
              g2 = N4;
            }
          }
          for (var A3 = "", S4 = p2; S4 <= g2; S4++) {
            var _3 = i2[S4];
            if (t2.multiline) {
              if (S4 === g2) {
                A3 += _3[m3] + " ", m3 = (m3 + 1) % _3.length;
                continue;
              }
              if (S4 === p2) {
                A3 += _3[_3.length - 1] + " ";
                continue;
              }
            }
            A3 += _3[0] + " ";
          }
          switch (A3 = " " == A3.substr(A3.length - 1) ? A3.substr(0, A3.length - 1) : A3, l4 = nt(A3, t2, a2).width, t2.textAlign) {
            case "right":
              c2 = s2 - l4 - 2;
              break;
            case "center":
              c2 = (s2 - l4) / 2;
              break;
            default:
              c2 = 2;
          }
          e += U3(c2) + " " + U3(d3) + " Td\n", e += "(" + T3(A3) + ") Tj\n", e += -U3(c2) + " 0 Td\n", d3 = -(a2 + 2), l4 = 0, p2 = w3 ? g2 : g2 + 1, b3++, v3 = "";
        }
        break;
      }
      return r.text = e, r.fontSize = a2, r;
    };
    nt = function(t2, e, n) {
      var r = e.scope.internal.getFont(e.fontName, e.fontStyle), i2 = e.scope.getStringUnitWidth(t2, { font: r, fontSize: parseFloat(n), charSpace: 0 }) * parseFloat(n);
      return { height: e.scope.getStringUnitWidth("3", { font: r, fontSize: parseFloat(n), charSpace: 0 }) * parseFloat(n) * 1.5, width: i2 };
    };
    rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false };
    it = function(t2, e) {
      var n = { type: "reference", object: t2 };
      void 0 === e.internal.getPageInfo(t2.page).pageContext.annotations.find(function(t3) {
        return t3.type === n.type && t3.object === n.object;
      }) && e.internal.getPageInfo(t2.page).pageContext.annotations.push(n);
    };
    at = function(e, n) {
      if (n.scope = e, void 0 !== e.internal && (void 0 === e.internal.acroformPlugin || false === e.internal.acroformPlugin.isInitialized)) {
        if (ht.FieldNum = 0, e.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
        D3 = e.internal.scaleFactor, e.internal.acroformPlugin.acroFormDictionaryRoot = new lt(), e.internal.acroformPlugin.acroFormDictionaryRoot.scope = e, e.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e.internal.events.subscribe("postPutResources", function() {
          !(function(t2) {
            t2.internal.events.unsubscribe(t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t2.internal.acroformPlugin.printedOut = true;
          })(e);
        }), e.internal.events.subscribe("buildDocument", function() {
          !(function(t2) {
            t2.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
            var e2 = t2.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
            for (var n2 in e2) if (e2.hasOwnProperty(n2)) {
              var r = e2[n2];
              r.objId = void 0, r.hasAnnotation && it(r, t2);
            }
          })(e);
        }), e.internal.events.subscribe("putCatalog", function() {
          !(function(t2) {
            if (void 0 === t2.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("putCatalogCallback: Root missing.");
            t2.internal.write("/AcroForm " + t2.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
          })(e);
        }), e.internal.events.subscribe("postPutPages", function(n2) {
          !(function(e2, n3) {
            var r = !e2;
            for (var i2 in e2 || (n3.internal.newObjectDeferredBegin(n3.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), n3.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e2 = e2 || n3.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (e2.hasOwnProperty(i2)) {
              var a2 = e2[i2], o2 = [], s2 = a2.Rect;
              if (a2.Rect && (a2.Rect = Q3(a2.Rect, n3)), n3.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = xt.createDefaultAppearanceStream(a2), "object" === _typeof(a2) && "function" == typeof a2.getKeyValueListForStream && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
                var u2 = tt(a2);
                o2.push({ key: "AP", value: "<</N " + u2 + ">>" }), n3.internal.acroformPlugin.xForms.push(u2);
              }
              if (a2.appearanceStreamContent) {
                var c2 = "";
                for (var l4 in a2.appearanceStreamContent) if (a2.appearanceStreamContent.hasOwnProperty(l4)) {
                  var h2 = a2.appearanceStreamContent[l4];
                  if (c2 += "/" + l4 + " ", c2 += "<<", Object.keys(h2).length >= 1 || Array.isArray(h2)) {
                    for (var i2 in h2) if (h2.hasOwnProperty(i2)) {
                      var f2 = h2[i2];
                      "function" == typeof f2 && (f2 = f2.call(n3, a2)), c2 += "/" + i2 + " " + f2 + " ", n3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || n3.internal.acroformPlugin.xForms.push(f2);
                    }
                  } else "function" == typeof (f2 = h2) && (f2 = f2.call(n3, a2)), c2 += "/" + i2 + " " + f2, n3.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || n3.internal.acroformPlugin.xForms.push(f2);
                  c2 += ">>";
                }
                o2.push({ key: "AP", value: "<<\n" + c2 + ">>" });
              }
              n3.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), n3.internal.out("endobj");
            }
            r && (function(e3, n4) {
              for (var r2 in e3) if (e3.hasOwnProperty(r2)) {
                var i3 = r2, a3 = e3[r2];
                n4.internal.newObjectDeferredBegin(a3.objId, true), "object" === _typeof(a3) && "function" == typeof a3.putStream && a3.putStream(), delete e3[i3];
              }
            })(n3.internal.acroformPlugin.xForms, n3);
          })(n2, e);
        }), e.internal.acroformPlugin.isInitialized = true;
      }
    };
    ot = R2.__acroform__.arrayToPdfArray = function(e, n, r) {
      var i2 = function(t2) {
        return t2;
      };
      if (Array.isArray(e)) {
        for (var a2 = "[", o2 = 0; o2 < e.length; o2++) switch (0 !== o2 && (a2 += " "), _typeof(e[o2])) {
          case "boolean":
          case "number":
          case "object":
            a2 += e[o2].toString();
            break;
          case "string":
            "/" !== e[o2].substr(0, 1) ? (void 0 !== n && r && (i2 = r.internal.getEncryptor(n)), a2 += "(" + T3(i2(e[o2].toString())) + ")") : a2 += e[o2].toString();
        }
        return a2 + "]";
      }
      throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
    };
    st = function(t2, e, n) {
      var r = function(t3) {
        return t3;
      };
      return void 0 !== e && n && (r = n.internal.getEncryptor(e)), (t2 = t2 || "").toString(), "(" + T3(r(t2)) + ")";
    };
    ut = function() {
      this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
        if (void 0 === this._objId) {
          if (void 0 === this.scope) return;
          this._objId = this.scope.internal.newObjectDeferred();
        }
        return this._objId;
      }, set: function(t2) {
        this._objId = t2;
      } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
    };
    ut.prototype.toString = function() {
      return this.objId + " 0 R";
    }, ut.prototype.putStream = function() {
      var t2 = this.getKeyValueListForStream();
      this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t2, objectId: this.objId }), this.scope.internal.out("endobj");
    }, ut.prototype.getKeyValueListForStream = function() {
      var t2 = [], e = Object.getOwnPropertyNames(this).filter(function(t3) {
        return "content" != t3 && "appearanceStreamContent" != t3 && "scope" != t3 && "objId" != t3 && "_" != t3.substring(0, 1);
      });
      for (var n in e) if (false === Object.getOwnPropertyDescriptor(this, e[n]).configurable) {
        var r = e[n], i2 = this[r];
        i2 && (Array.isArray(i2) ? t2.push({ key: r, value: ot(i2, this.objId, this.scope) }) : i2 instanceof ut ? (i2.scope = this.scope, t2.push({ key: r, value: i2.objId + " 0 R" })) : "function" != typeof i2 && t2.push({ key: r, value: i2 }));
      }
      return t2;
    };
    ct = function() {
      ut.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
      var t2, e = [];
      Object.defineProperty(this, "BBox", { configurable: false, get: function() {
        return e;
      }, set: function(t3) {
        e = t3;
      } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e2) {
        t2 = e2.trim();
      }, get: function() {
        return t2 || null;
      } });
    };
    W3(ct, ut);
    lt = function() {
      ut.call(this);
      var t2, e = [];
      Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
        return e.length > 0 ? e : void 0;
      } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
        return e;
      } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
        if (t2) {
          var e2 = function(t3) {
            return t3;
          };
          return this.scope && (e2 = this.scope.internal.getEncryptor(this.objId)), "(" + T3(e2(t2)) + ")";
        }
      }, set: function(e2) {
        t2 = e2;
      } });
    };
    W3(lt, ut);
    ht = function t() {
      ut.call(this);
      var e = 4;
      Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
        return e;
      }, set: function(t2) {
        if (isNaN(t2)) throw new Error('Invalid value "' + t2 + '" for attribute F supplied.');
        e = t2;
      } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(e, 3));
      }, set: function(t2) {
        true === Boolean(t2) ? this.F = Z2(e, 3) : this.F = $2(e, 3);
      } });
      var n = 0;
      Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
        return n;
      }, set: function(t2) {
        if (isNaN(t2)) throw new Error('Invalid value "' + t2 + '" for attribute Ff supplied.');
        n = t2;
      } });
      var r = [];
      Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
        if (0 !== r.length) return r;
      }, set: function(t2) {
        r = void 0 !== t2 ? t2 : [];
      } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
        return !r || isNaN(r[0]) ? 0 : r[0];
      }, set: function(t2) {
        r[0] = t2;
      } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
        return !r || isNaN(r[1]) ? 0 : r[1];
      }, set: function(t2) {
        r[1] = t2;
      } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
        return !r || isNaN(r[2]) ? 0 : r[2];
      }, set: function(t2) {
        r[2] = t2;
      } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
        return !r || isNaN(r[3]) ? 0 : r[3];
      }, set: function(t2) {
        r[3] = t2;
      } });
      var i2 = "";
      Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
        return i2;
      }, set: function(t2) {
        switch (t2) {
          case "/Btn":
          case "/Tx":
          case "/Ch":
          case "/Sig":
            i2 = t2;
            break;
          default:
            throw new Error('Invalid value "' + t2 + '" for attribute FT supplied.');
        }
      } });
      var a2 = null;
      Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
        if (!a2 || a2.length < 1) {
          if (this instanceof yt) return;
          a2 = "FieldObject" + t.FieldNum++;
        }
        var e2 = function(t2) {
          return t2;
        };
        return this.scope && (e2 = this.scope.internal.getEncryptor(this.objId)), "(" + T3(e2(a2)) + ")";
      }, set: function(t2) {
        a2 = t2.toString();
      } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
        return a2;
      }, set: function(t2) {
        a2 = t2;
      } });
      var o2 = "helvetica";
      Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
        return o2;
      }, set: function(t2) {
        o2 = t2;
      } });
      var s2 = "normal";
      Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
        return s2;
      }, set: function(t2) {
        s2 = t2;
      } });
      var u2 = 0;
      Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
        return u2;
      }, set: function(t2) {
        u2 = t2;
      } });
      var c2 = void 0;
      Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
        return void 0 === c2 ? 50 / D3 : c2;
      }, set: function(t2) {
        c2 = t2;
      } });
      var l4 = "black";
      Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
        return l4;
      }, set: function(t2) {
        l4 = t2;
      } });
      var h2 = "/F1 0 Tf 0 g";
      Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
        if (!(!h2 || this instanceof yt || this instanceof Nt2)) return st(h2, this.objId, this.scope);
      }, set: function(t2) {
        t2 = t2.toString(), h2 = t2;
      } });
      var f2 = null;
      Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
        if (f2) return this instanceof mt == 0 ? st(f2, this.objId, this.scope) : f2;
      }, set: function(t2) {
        t2 = t2.toString(), f2 = this instanceof mt == 0 ? "(" === t2.substr(0, 1) ? z2(t2.substr(1, t2.length - 2)) : z2(t2) : t2;
      } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
        return this instanceof mt == 1 ? z2(f2.substr(1, f2.length - 1)) : f2;
      }, set: function(t2) {
        t2 = t2.toString(), f2 = this instanceof mt == 1 ? "/" + t2 : t2;
      } });
      var d3 = null;
      Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
        if (d3) return d3;
      }, set: function(t2) {
        this.V = t2;
      } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
        if (d3) return this instanceof mt == 0 ? st(d3, this.objId, this.scope) : d3;
      }, set: function(t2) {
        t2 = t2.toString(), d3 = this instanceof mt == 0 ? "(" === t2.substr(0, 1) ? z2(t2.substr(1, t2.length - 2)) : z2(t2) : t2;
      } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
        return this instanceof mt == 1 ? z2(d3.substr(1, d3.length - 1)) : d3;
      }, set: function(t2) {
        t2 = t2.toString(), d3 = this instanceof mt == 1 ? "/" + t2 : t2;
      } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
        return this.Rect;
      } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
        return this.hasAnnotation ? "/Annot" : null;
      } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
        return this.hasAnnotation ? "/Widget" : null;
      } });
      var p2, g2 = false;
      Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
        return g2;
      }, set: function(t2) {
        t2 = Boolean(t2), g2 = t2;
      } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
        if (p2) return p2;
      }, set: function(t2) {
        p2 = t2;
      } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 1));
      }, set: function(t2) {
        true === Boolean(t2) ? this.Ff = Z2(this.Ff, 1) : this.Ff = $2(this.Ff, 1);
      } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 2));
      }, set: function(t2) {
        true === Boolean(t2) ? this.Ff = Z2(this.Ff, 2) : this.Ff = $2(this.Ff, 2);
      } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 3));
      }, set: function(t2) {
        true === Boolean(t2) ? this.Ff = Z2(this.Ff, 3) : this.Ff = $2(this.Ff, 3);
      } });
      var m3 = null;
      Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
        if (null !== m3) return m3;
      }, set: function(t2) {
        if (-1 === [0, 1, 2].indexOf(t2)) throw new Error('Invalid value "' + t2 + '" for attribute Q supplied.');
        m3 = t2;
      } }), Object.defineProperty(this, "textAlign", { get: function() {
        var t2;
        switch (m3) {
          case 0:
          default:
            t2 = "left";
            break;
          case 1:
            t2 = "center";
            break;
          case 2:
            t2 = "right";
        }
        return t2;
      }, configurable: true, enumerable: true, set: function(t2) {
        switch (t2) {
          case "right":
          case 2:
            m3 = 2;
            break;
          case "center":
          case 1:
            m3 = 1;
            break;
          default:
            m3 = 0;
        }
      } });
    };
    W3(ht, ut);
    ft = function() {
      ht.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
      var t2 = 0;
      Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
        return t2;
      }, set: function(e2) {
        t2 = e2;
      } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
        return t2;
      }, set: function(e2) {
        t2 = e2;
      } });
      var e = [];
      Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
        return ot(e, this.objId, this.scope);
      }, set: function(t3) {
        var n, r;
        r = [], "string" == typeof (n = t3) && (r = (function(t4, e2, n2) {
          n2 || (n2 = 1);
          for (var r2, i2 = []; r2 = e2.exec(t4); ) i2.push(r2[n2]);
          return i2;
        })(n, /\((.*?)\)/g)), e = r;
      } }), this.getOptions = function() {
        return e;
      }, this.setOptions = function(t3) {
        e = t3, this.sort && e.sort();
      }, this.addOption = function(t3) {
        t3 = (t3 = t3 || "").toString(), e.push(t3), this.sort && e.sort();
      }, this.removeOption = function(t3, n) {
        for (n = n || false, t3 = (t3 = t3 || "").toString(); -1 !== e.indexOf(t3) && (e.splice(e.indexOf(t3), 1), false !== n); ) ;
      }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 18));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = Z2(this.Ff, 18) : this.Ff = $2(this.Ff, 18);
      } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 19));
      }, set: function(t3) {
        true === this.combo && (true === Boolean(t3) ? this.Ff = Z2(this.Ff, 19) : this.Ff = $2(this.Ff, 19));
      } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 20));
      }, set: function(t3) {
        true === Boolean(t3) ? (this.Ff = Z2(this.Ff, 20), e.sort()) : this.Ff = $2(this.Ff, 20);
      } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 22));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = Z2(this.Ff, 22) : this.Ff = $2(this.Ff, 22);
      } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 23));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = Z2(this.Ff, 23) : this.Ff = $2(this.Ff, 23);
      } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 27));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = Z2(this.Ff, 27) : this.Ff = $2(this.Ff, 27);
      } }), this.hasAppearanceStream = false;
    };
    W3(ft, ht);
    dt = function() {
      ft.call(this), this.fontName = "helvetica", this.combo = false;
    };
    W3(dt, ft);
    pt = function() {
      dt.call(this), this.combo = true;
    };
    W3(pt, dt);
    gt = function() {
      pt.call(this), this.edit = true;
    };
    W3(gt, pt);
    mt = function() {
      ht.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 15));
      }, set: function(t2) {
        true === Boolean(t2) ? this.Ff = Z2(this.Ff, 15) : this.Ff = $2(this.Ff, 15);
      } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 16));
      }, set: function(t2) {
        true === Boolean(t2) ? this.Ff = Z2(this.Ff, 16) : this.Ff = $2(this.Ff, 16);
      } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 17));
      }, set: function(t2) {
        true === Boolean(t2) ? this.Ff = Z2(this.Ff, 17) : this.Ff = $2(this.Ff, 17);
      } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 26));
      }, set: function(t2) {
        true === Boolean(t2) ? this.Ff = Z2(this.Ff, 26) : this.Ff = $2(this.Ff, 26);
      } });
      var e, n = {};
      Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
        var t2 = function(t3) {
          return t3;
        };
        if (this.scope && (t2 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(n).length) {
          var e2, r = [];
          for (e2 in r.push("<<"), n) r.push("/" + e2 + " (" + T3(t2(n[e2])) + ")");
          return r.push(">>"), r.join("\n");
        }
      }, set: function(e2) {
        "object" === _typeof(e2) && (n = e2);
      } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
        return n.CA || "";
      }, set: function(t2) {
        "string" == typeof t2 && (n.CA = t2);
      } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
        return e;
      }, set: function(t2) {
        e = t2;
      } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
        return e.substr(1, e.length - 1);
      }, set: function(t2) {
        e = "/" + t2;
      } });
    };
    W3(mt, ht);
    vt = function() {
      mt.call(this), this.pushButton = true;
    };
    W3(vt, mt);
    bt = function() {
      mt.call(this), this.radio = true, this.pushButton = false;
      var t2 = [];
      Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
        return t2;
      }, set: function(e) {
        t2 = void 0 !== e ? e : [];
      } });
    };
    W3(bt, mt);
    yt = function() {
      var e, n;
      ht.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
        return e;
      }, set: function(t2) {
        e = t2;
      } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
        return n;
      }, set: function(t2) {
        n = t2;
      } });
      var r, i2 = {};
      Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
        var t2 = function(t3) {
          return t3;
        };
        this.scope && (t2 = this.scope.internal.getEncryptor(this.objId));
        var e2, n2 = [];
        for (e2 in n2.push("<<"), i2) n2.push("/" + e2 + " (" + T3(t2(i2[e2])) + ")");
        return n2.push(">>"), n2.join("\n");
      }, set: function(e2) {
        "object" === _typeof(e2) && (i2 = e2);
      } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
        return i2.CA || "";
      }, set: function(t2) {
        "string" == typeof t2 && (i2.CA = t2);
      } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
        return r;
      }, set: function(t2) {
        r = t2;
      } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
        return r.substr(1, r.length - 1);
      }, set: function(t2) {
        r = "/" + t2;
      } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = xt.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
    };
    W3(yt, ht), bt.prototype.setAppearance = function(t2) {
      if (!("createAppearanceStream" in t2) || !("getCA" in t2)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
      for (var e in this.Kids) if (this.Kids.hasOwnProperty(e)) {
        var n = this.Kids[e];
        n.appearanceStreamContent = t2.createAppearanceStream(n.optionName), n.caption = t2.getCA();
      }
    }, bt.prototype.createOption = function(t2) {
      var e = new yt();
      return e.Parent = this, e.optionName = t2, this.Kids.push(e), At.call(this.scope, e), e;
    };
    wt = function() {
      mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = xt.CheckBox.createAppearanceStream();
    };
    W3(wt, mt);
    Nt2 = function() {
      ht.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 13));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = Z2(this.Ff, 13) : this.Ff = $2(this.Ff, 13);
      } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 21));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = Z2(this.Ff, 21) : this.Ff = $2(this.Ff, 21);
      } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 23));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = Z2(this.Ff, 23) : this.Ff = $2(this.Ff, 23);
      } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 24));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = Z2(this.Ff, 24) : this.Ff = $2(this.Ff, 24);
      } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 25));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = Z2(this.Ff, 25) : this.Ff = $2(this.Ff, 25);
      } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 26));
      }, set: function(t3) {
        true === Boolean(t3) ? this.Ff = Z2(this.Ff, 26) : this.Ff = $2(this.Ff, 26);
      } });
      var t2 = null;
      Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
        return t2;
      }, set: function(e) {
        t2 = e;
      } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
        return t2;
      }, set: function(e) {
        Number.isInteger(e) && (t2 = e);
      } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
        return this.V || this.DV;
      } });
    };
    W3(Nt2, ht);
    Lt = function() {
      Nt2.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
        return Boolean(K3(this.Ff, 14));
      }, set: function(t2) {
        true === Boolean(t2) ? this.Ff = Z2(this.Ff, 14) : this.Ff = $2(this.Ff, 14);
      } }), this.password = true;
    };
    W3(Lt, Nt2);
    xt = { CheckBox: { createAppearanceStream: function() {
      return { N: { On: xt.CheckBox.YesNormal }, D: { On: xt.CheckBox.YesPushDown, Off: xt.CheckBox.OffPushDown } };
    }, YesPushDown: function(t2) {
      var e = G3(t2);
      e.scope = t2.scope;
      var n = [], r = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, i2 = t2.scope.__private__.encodeColorString(t2.color), a2 = et2(t2, t2.caption);
      return n.push("0.749023 g"), n.push("0 0 " + U3(xt.internal.getWidth(t2)) + " " + U3(xt.internal.getHeight(t2)) + " re"), n.push("f"), n.push("BMC"), n.push("q"), n.push("0 0 1 rg"), n.push("/" + r + " " + U3(a2.fontSize) + " Tf " + i2), n.push("BT"), n.push(a2.text), n.push("ET"), n.push("Q"), n.push("EMC"), e.stream = n.join("\n"), e;
    }, YesNormal: function(t2) {
      var e = G3(t2);
      e.scope = t2.scope;
      var n = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, r = t2.scope.__private__.encodeColorString(t2.color), i2 = [], a2 = xt.internal.getHeight(t2), o2 = xt.internal.getWidth(t2), s2 = et2(t2, t2.caption);
      return i2.push("1 g"), i2.push("0 0 " + U3(o2) + " " + U3(a2) + " re"), i2.push("f"), i2.push("q"), i2.push("0 0 1 rg"), i2.push("0 0 " + U3(o2 - 1) + " " + U3(a2 - 1) + " re"), i2.push("W"), i2.push("n"), i2.push("0 g"), i2.push("BT"), i2.push("/" + n + " " + U3(s2.fontSize) + " Tf " + r), i2.push(s2.text), i2.push("ET"), i2.push("Q"), e.stream = i2.join("\n"), e;
    }, OffPushDown: function(t2) {
      var e = G3(t2);
      e.scope = t2.scope;
      var n = [];
      return n.push("0.749023 g"), n.push("0 0 " + U3(xt.internal.getWidth(t2)) + " " + U3(xt.internal.getHeight(t2)) + " re"), n.push("f"), e.stream = n.join("\n"), e;
    } }, RadioButton: { Circle: { createAppearanceStream: function(t2) {
      var e = { D: { Off: xt.RadioButton.Circle.OffPushDown }, N: {} };
      return e.N[t2] = xt.RadioButton.Circle.YesNormal, e.D[t2] = xt.RadioButton.Circle.YesPushDown, e;
    }, getCA: function() {
      return "l";
    }, YesNormal: function(t2) {
      var e = G3(t2);
      e.scope = t2.scope;
      var n = [], r = xt.internal.getWidth(t2) <= xt.internal.getHeight(t2) ? xt.internal.getWidth(t2) / 4 : xt.internal.getHeight(t2) / 4;
      r = Number((0.9 * r).toFixed(5));
      var i2 = xt.internal.Bezier_C, a2 = Number((r * i2).toFixed(5));
      return n.push("q"), n.push("1 0 0 1 " + H2(xt.internal.getWidth(t2) / 2) + " " + H2(xt.internal.getHeight(t2) / 2) + " cm"), n.push(r + " 0 m"), n.push(r + " " + a2 + " " + a2 + " " + r + " 0 " + r + " c"), n.push("-" + a2 + " " + r + " -" + r + " " + a2 + " -" + r + " 0 c"), n.push("-" + r + " -" + a2 + " -" + a2 + " -" + r + " 0 -" + r + " c"), n.push(a2 + " -" + r + " " + r + " -" + a2 + " " + r + " 0 c"), n.push("f"), n.push("Q"), e.stream = n.join("\n"), e;
    }, YesPushDown: function(t2) {
      var e = G3(t2);
      e.scope = t2.scope;
      var n = [], r = xt.internal.getWidth(t2) <= xt.internal.getHeight(t2) ? xt.internal.getWidth(t2) / 4 : xt.internal.getHeight(t2) / 4;
      r = Number((0.9 * r).toFixed(5));
      var i2 = Number((2 * r).toFixed(5)), a2 = Number((i2 * xt.internal.Bezier_C).toFixed(5)), o2 = Number((r * xt.internal.Bezier_C).toFixed(5));
      return n.push("0.749023 g"), n.push("q"), n.push("1 0 0 1 " + H2(xt.internal.getWidth(t2) / 2) + " " + H2(xt.internal.getHeight(t2) / 2) + " cm"), n.push(i2 + " 0 m"), n.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), n.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), n.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), n.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), n.push("f"), n.push("Q"), n.push("0 g"), n.push("q"), n.push("1 0 0 1 " + H2(xt.internal.getWidth(t2) / 2) + " " + H2(xt.internal.getHeight(t2) / 2) + " cm"), n.push(r + " 0 m"), n.push(r + " " + o2 + " " + o2 + " " + r + " 0 " + r + " c"), n.push("-" + o2 + " " + r + " -" + r + " " + o2 + " -" + r + " 0 c"), n.push("-" + r + " -" + o2 + " -" + o2 + " -" + r + " 0 -" + r + " c"), n.push(o2 + " -" + r + " " + r + " -" + o2 + " " + r + " 0 c"), n.push("f"), n.push("Q"), e.stream = n.join("\n"), e;
    }, OffPushDown: function(t2) {
      var e = G3(t2);
      e.scope = t2.scope;
      var n = [], r = xt.internal.getWidth(t2) <= xt.internal.getHeight(t2) ? xt.internal.getWidth(t2) / 4 : xt.internal.getHeight(t2) / 4;
      r = Number((0.9 * r).toFixed(5));
      var i2 = Number((2 * r).toFixed(5)), a2 = Number((i2 * xt.internal.Bezier_C).toFixed(5));
      return n.push("0.749023 g"), n.push("q"), n.push("1 0 0 1 " + H2(xt.internal.getWidth(t2) / 2) + " " + H2(xt.internal.getHeight(t2) / 2) + " cm"), n.push(i2 + " 0 m"), n.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), n.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), n.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), n.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), n.push("f"), n.push("Q"), e.stream = n.join("\n"), e;
    } }, Cross: { createAppearanceStream: function(t2) {
      var e = { D: { Off: xt.RadioButton.Cross.OffPushDown }, N: {} };
      return e.N[t2] = xt.RadioButton.Cross.YesNormal, e.D[t2] = xt.RadioButton.Cross.YesPushDown, e;
    }, getCA: function() {
      return "8";
    }, YesNormal: function(t2) {
      var e = G3(t2);
      e.scope = t2.scope;
      var n = [], r = xt.internal.calculateCross(t2);
      return n.push("q"), n.push("1 1 " + U3(xt.internal.getWidth(t2) - 2) + " " + U3(xt.internal.getHeight(t2) - 2) + " re"), n.push("W"), n.push("n"), n.push(U3(r.x1.x) + " " + U3(r.x1.y) + " m"), n.push(U3(r.x2.x) + " " + U3(r.x2.y) + " l"), n.push(U3(r.x4.x) + " " + U3(r.x4.y) + " m"), n.push(U3(r.x3.x) + " " + U3(r.x3.y) + " l"), n.push("s"), n.push("Q"), e.stream = n.join("\n"), e;
    }, YesPushDown: function(t2) {
      var e = G3(t2);
      e.scope = t2.scope;
      var n = xt.internal.calculateCross(t2), r = [];
      return r.push("0.749023 g"), r.push("0 0 " + U3(xt.internal.getWidth(t2)) + " " + U3(xt.internal.getHeight(t2)) + " re"), r.push("f"), r.push("q"), r.push("1 1 " + U3(xt.internal.getWidth(t2) - 2) + " " + U3(xt.internal.getHeight(t2) - 2) + " re"), r.push("W"), r.push("n"), r.push(U3(n.x1.x) + " " + U3(n.x1.y) + " m"), r.push(U3(n.x2.x) + " " + U3(n.x2.y) + " l"), r.push(U3(n.x4.x) + " " + U3(n.x4.y) + " m"), r.push(U3(n.x3.x) + " " + U3(n.x3.y) + " l"), r.push("s"), r.push("Q"), e.stream = r.join("\n"), e;
    }, OffPushDown: function(t2) {
      var e = G3(t2);
      e.scope = t2.scope;
      var n = [];
      return n.push("0.749023 g"), n.push("0 0 " + U3(xt.internal.getWidth(t2)) + " " + U3(xt.internal.getHeight(t2)) + " re"), n.push("f"), e.stream = n.join("\n"), e;
    } } }, createDefaultAppearanceStream: function(t2) {
      var e = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, n = t2.scope.__private__.encodeColorString(t2.color);
      return "/" + e + " " + t2.fontSize + " Tf " + n;
    } };
    xt.internal = { Bezier_C: 0.551915024494, calculateCross: function(t2) {
      var e = xt.internal.getWidth(t2), n = xt.internal.getHeight(t2), r = Math.min(e, n);
      return { x1: { x: (e - r) / 2, y: (n - r) / 2 + r }, x2: { x: (e - r) / 2 + r, y: (n - r) / 2 }, x3: { x: (e - r) / 2, y: (n - r) / 2 }, x4: { x: (e - r) / 2 + r, y: (n - r) / 2 + r } };
    } }, xt.internal.getWidth = function(e) {
      var n = 0;
      return "object" === _typeof(e) && (n = V3(e.Rect[2])), n;
    }, xt.internal.getHeight = function(e) {
      var n = 0;
      return "object" === _typeof(e) && (n = V3(e.Rect[3])), n;
    };
    At = R2.addField = function(t2) {
      if (at(this, t2), !(t2 instanceof ht)) throw new Error("Invalid argument passed to jsPDF.addField.");
      var e;
      return (e = t2).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = false, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), t2.page = t2.scope.internal.getCurrentPageInfo().pageNumber, this;
    };
    R2.AcroFormChoiceField = ft, R2.AcroFormListBox = dt, R2.AcroFormComboBox = pt, R2.AcroFormEditBox = gt, R2.AcroFormButton = mt, R2.AcroFormPushButton = vt, R2.AcroFormRadioButton = bt, R2.AcroFormCheckBox = wt, R2.AcroFormTextField = Nt2, R2.AcroFormPasswordField = Lt, R2.AcroFormAppearance = xt, R2.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt2, PasswordField: Lt, Appearance: xt }, E3.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt2, PasswordField: Lt, Appearance: xt };
    St = E3.AcroForm;
    !(function(e) {
      var n = "addImage_";
      e.__addimage__ = {};
      var r = "UNKNOWN", i2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, a2 = e.__addimage__.getImageFileTypeByImageData = function(t2, e2) {
        var n2, a3, o3, s3, u3, c3 = r;
        if ("RGBA" === (e2 = e2 || r) || void 0 !== t2.data && t2.data instanceof Uint8ClampedArray && "height" in t2 && "width" in t2) return "RGBA";
        if (A3(t2)) for (u3 in i2) for (o3 = i2[u3], n2 = 0; n2 < o3.length; n2 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[n2].length; a3 += 1) if (void 0 !== o3[n2][a3] && o3[n2][a3] !== t2[a3]) {
            s3 = false;
            break;
          }
          if (true === s3) {
            c3 = u3;
            break;
          }
        }
        else for (u3 in i2) for (o3 = i2[u3], n2 = 0; n2 < o3.length; n2 += 1) {
          for (s3 = true, a3 = 0; a3 < o3[n2].length; a3 += 1) if (void 0 !== o3[n2][a3] && o3[n2][a3] !== t2.charCodeAt(a3)) {
            s3 = false;
            break;
          }
          if (true === s3) {
            c3 = u3;
            break;
          }
        }
        return c3 === r && e2 !== r && (c3 = e2), c3;
      }, o2 = function t2(e2) {
        for (var n2 = this.internal.write, r2 = this.internal.putStream, i3 = (0, this.internal.getFilters)(); -1 !== i3.indexOf("FlateEncode"); ) i3.splice(i3.indexOf("FlateEncode"), 1);
        e2.objectId = this.internal.newObject();
        var a3 = [];
        if (a3.push({ key: "Type", value: "/XObject" }), a3.push({ key: "Subtype", value: "/Image" }), a3.push({ key: "Width", value: e2.width }), a3.push({ key: "Height", value: e2.height }), e2.colorSpace === y3.INDEXED ? a3.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e2.palette.length / 3 - 1) + " " + ("sMask" in e2 && void 0 !== e2.sMask ? e2.objectId + 2 : e2.objectId + 1) + " 0 R]" }) : (a3.push({ key: "ColorSpace", value: "/" + e2.colorSpace }), e2.colorSpace === y3.DEVICE_CMYK && a3.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a3.push({ key: "BitsPerComponent", value: e2.bitsPerComponent }), "decodeParameters" in e2 && void 0 !== e2.decodeParameters && a3.push({ key: "DecodeParms", value: "<<" + e2.decodeParameters + ">>" }), "transparency" in e2 && Array.isArray(e2.transparency) && e2.transparency.length > 0) {
          for (var o3 = "", s3 = 0, u3 = e2.transparency.length; s3 < u3; s3++) o3 += e2.transparency[s3] + " " + e2.transparency[s3] + " ";
          a3.push({ key: "Mask", value: "[" + o3 + "]" });
        }
        void 0 !== e2.sMask && a3.push({ key: "SMask", value: e2.objectId + 1 + " 0 R" });
        var c3 = void 0 !== e2.filter ? ["/" + e2.filter] : void 0;
        if (r2({ data: e2.data, additionalKeyValues: a3, alreadyAppliedFilters: c3, objectId: e2.objectId }), n2("endobj"), "sMask" in e2 && void 0 !== e2.sMask) {
          var l5, h3 = null !== (l5 = e2.sMaskBitsPerComponent) && void 0 !== l5 ? l5 : e2.bitsPerComponent, f2 = { width: e2.width, height: e2.height, colorSpace: "DeviceGray", bitsPerComponent: h3, data: e2.sMask };
          "filter" in e2 && (f2.decodeParameters = "/Predictor ".concat(e2.predictor, " /Colors 1 /BitsPerComponent ").concat(h3, " /Columns ").concat(e2.width), f2.filter = e2.filter), t2.call(this, f2);
        }
        if (e2.colorSpace === y3.INDEXED) {
          var d4 = this.internal.newObject();
          r2({ data: _3(new Uint8Array(e2.palette)), objectId: d4 }), n2("endobj");
        }
      }, s2 = function() {
        var t2 = this.internal.collections[n + "images"];
        for (var e2 in t2) o2.call(this, t2[e2]);
      }, u2 = function() {
        var t2, e2 = this.internal.collections[n + "images"], r2 = this.internal.write;
        for (var i3 in e2) r2("/I" + (t2 = e2[i3]).index, t2.objectId, "0", "R");
      }, c2 = function() {
        this.internal.collections[n + "images"] || (this.internal.collections[n + "images"] = {}, this.internal.events.subscribe("putResources", s2), this.internal.events.subscribe("putXobjectDict", u2));
      }, l4 = function() {
        var t2 = this.internal.collections[n + "images"];
        return c2.call(this), t2;
      }, h2 = function() {
        return Object.keys(this.internal.collections[n + "images"]).length;
      }, d3 = function(t2) {
        return "function" == typeof e["process" + t2.toUpperCase()];
      }, p2 = function(e2) {
        return "object" === _typeof(e2) && 1 === e2.nodeType;
      }, g2 = function(t2, n2) {
        if ("IMG" === t2.nodeName && t2.hasAttribute("src")) {
          var r2 = "" + t2.getAttribute("src");
          if (0 === r2.indexOf("data:image/")) return f(unescape(r2).split("base64,").pop());
          var i3 = e.loadFile(r2, true);
          if (void 0 !== i3) return i3;
        }
        if ("CANVAS" === t2.nodeName) {
          if (0 === t2.width || 0 === t2.height) throw new Error("Given canvas must have data. Canvas width: " + t2.width + ", height: " + t2.height);
          var a3;
          switch (n2) {
            case "PNG":
              a3 = "image/png";
              break;
            case "WEBP":
              a3 = "image/webp";
              break;
            default:
              a3 = "image/jpeg";
          }
          return f(t2.toDataURL(a3, 1).split("base64,").pop());
        }
      }, m3 = function(t2) {
        var e2 = this.internal.collections[n + "images"];
        if (e2) {
          for (var r2 in e2) if (t2 === e2[r2].alias) return e2[r2];
        }
      }, v3 = function(t2, e2, n2) {
        return t2 || e2 || (t2 = -96, e2 = -96), t2 < 0 && (t2 = -1 * n2.width * 72 / t2 / this.internal.scaleFactor), e2 < 0 && (e2 = -1 * n2.height * 72 / e2 / this.internal.scaleFactor), 0 === t2 && (t2 = e2 * n2.width / n2.height), 0 === e2 && (e2 = t2 * n2.height / n2.width), [t2, e2];
      }, b3 = function(t2, e2, n2, r2, i3, a3) {
        var o3 = v3.call(this, n2, r2, i3), s3 = this.internal.getCoordinateString, u3 = this.internal.getVerticalCoordinateString, c3 = l4.call(this);
        if (n2 = o3[0], r2 = o3[1], c3[i3.index] = i3, a3) {
          a3 *= Math.PI / 180;
          var h3 = Math.cos(a3), f2 = Math.sin(a3), d4 = function(t3) {
            return t3.toFixed(4);
          }, p3 = [d4(h3), d4(f2), d4(-1 * f2), d4(h3), 0, 0, "cm"];
        }
        this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t2), u3(e2 + r2), "cm"].join(" ")), this.internal.write(p3.join(" ")), this.internal.write([s3(n2), "0", "0", s3(r2), "0", "0", "cm"].join(" "))) : this.internal.write([s3(n2), "0", "0", s3(r2), s3(t2), u3(e2 + r2), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i3.index + " Do"), this.internal.write("Q");
      }, y3 = e.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
      e.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
      var w3 = e.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, N4 = e.__addimage__.sHashCode = function(t2) {
        var e2, n2, r2 = 0;
        if ("string" == typeof t2) for (n2 = t2.length, e2 = 0; e2 < n2; e2++) r2 = (r2 << 5) - r2 + t2.charCodeAt(e2), r2 |= 0;
        else if (A3(t2)) for (n2 = t2.byteLength / 2, e2 = 0; e2 < n2; e2++) r2 = (r2 << 5) - r2 + t2[e2], r2 |= 0;
        return r2;
      }, L4 = e.__addimage__.validateStringAsBase64 = function(t2) {
        (t2 = t2 || "").toString().trim();
        var e2 = true;
        return 0 === t2.length && (e2 = false), t2.length % 4 != 0 && (e2 = false), false === /^[A-Za-z0-9+/]+$/.test(t2.substr(0, t2.length - 2)) && (e2 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t2.substr(-2)) && (e2 = false), e2;
      }, x3 = e.__addimage__.extractImageFromDataUrl = function(t2) {
        if (null == t2) return null;
        if (!(t2 = t2.trim()).startsWith("data:")) return null;
        var e2 = t2.indexOf(",");
        return e2 < 0 ? null : t2.substring(0, e2).trim().endsWith("base64") ? t2.substring(e2 + 1) : null;
      };
      e.__addimage__.isArrayBuffer = function(t2) {
        return t2 instanceof ArrayBuffer;
      };
      var A3 = e.__addimage__.isArrayBufferView = function(t2) {
        return t2 instanceof Int8Array || t2 instanceof Uint8Array || t2 instanceof Uint8ClampedArray || t2 instanceof Int16Array || t2 instanceof Uint16Array || t2 instanceof Int32Array || t2 instanceof Uint32Array || t2 instanceof Float32Array || t2 instanceof Float64Array;
      }, S4 = e.__addimage__.binaryStringToUint8Array = function(t2) {
        for (var e2 = t2.length, n2 = new Uint8Array(e2), r2 = 0; r2 < e2; r2++) n2[r2] = t2.charCodeAt(r2);
        return n2;
      }, _3 = e.__addimage__.arrayBufferToBinaryString = function(t2) {
        for (var e2 = "", n2 = A3(t2) ? t2 : new Uint8Array(t2), r2 = 0; r2 < n2.length; r2 += 8192) e2 += String.fromCharCode.apply(null, n2.subarray(r2, r2 + 8192));
        return e2;
      };
      e.addImage = function() {
        var e2, n2, i3, a3, o3, s3, u3, l5, h3;
        if ("number" == typeof arguments[1] ? (n2 = r, i3 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u3 = arguments[5], l5 = arguments[6], h3 = arguments[7]) : (n2 = arguments[1], i3 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u3 = arguments[6], l5 = arguments[7], h3 = arguments[8]), "object" === _typeof(e2 = arguments[0]) && !p2(e2) && "imageData" in e2) {
          var f2 = e2;
          e2 = f2.imageData, n2 = f2.format || n2 || r, i3 = f2.x || i3 || 0, a3 = f2.y || a3 || 0, o3 = f2.w || f2.width || o3, s3 = f2.h || f2.height || s3, u3 = f2.alias || u3, l5 = f2.compression || l5, h3 = f2.rotation || f2.angle || h3;
        }
        var d4 = this.internal.getFilters();
        if (void 0 === l5 && -1 !== d4.indexOf("FlateEncode") && (l5 = "SLOW"), isNaN(i3) || isNaN(a3)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
        c2.call(this);
        var g3 = P4.call(this, e2, n2, u3, l5);
        return b3.call(this, i3, a3, o3, s3, g3, h3), this;
      };
      var P4 = function(t2, n2, i3, o3) {
        var s3, u3, c3;
        if ("string" == typeof t2 && a2(t2) === r) {
          t2 = unescape(t2);
          var l5 = k3(t2, false);
          ("" !== l5 || void 0 !== (l5 = e.loadFile(t2, true))) && (t2 = l5);
        }
        if (p2(t2) && (t2 = g2(t2, n2)), n2 = a2(t2, n2), !d3(n2)) throw new Error("addImage does not support files of type '" + n2 + "', please ensure that a plugin for '" + n2 + "' support is added.");
        if ((null == (c3 = i3) || 0 === c3.length) && (i3 = (function(t3) {
          return "string" == typeof t3 || A3(t3) ? N4(t3) : A3(t3.data) ? N4(t3.data) : null;
        })(t2)), (s3 = m3.call(this, i3)) || (t2 instanceof Uint8Array || "RGBA" === n2 || (u3 = t2, t2 = S4(t2)), s3 = this["process" + n2.toUpperCase()](t2, h2.call(this), i3, (function(t3) {
          return t3 && "string" == typeof t3 && (t3 = t3.toUpperCase()), t3 in e.image_compression ? t3 : w3.NONE;
        })(o3), u3)), !s3) throw new Error("An unknown error occurred whilst processing the image.");
        return s3;
      }, k3 = e.__addimage__.convertBase64ToBinaryString = function(t2, e2) {
        e2 = "boolean" != typeof e2 || e2;
        var n2, r2 = "";
        if ("string" == typeof t2) {
          var i3;
          n2 = null !== (i3 = x3(t2)) && void 0 !== i3 ? i3 : t2;
          try {
            r2 = f(n2);
          } catch (a3) {
            if (e2) throw L4(n2) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + a3.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
          }
        }
        return r2;
      };
      e.getImageProperties = function(t2) {
        var n2, i3, o3 = "";
        if (p2(t2) && (t2 = g2(t2)), "string" == typeof t2 && a2(t2) === r && ("" === (o3 = k3(t2, false)) && (o3 = e.loadFile(t2) || ""), t2 = o3), i3 = a2(t2), !d3(i3)) throw new Error("addImage does not support files of type '" + i3 + "', please ensure that a plugin for '" + i3 + "' support is added.");
        if (t2 instanceof Uint8Array || (t2 = S4(t2)), !(n2 = this["process" + i3.toUpperCase()](t2))) throw new Error("An unknown error occurred whilst processing the image");
        return n2.fileType = i3, n2;
      };
    })(E3.API), /**
     * @license
     * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e = function(t3) {
        if (void 0 !== t3 && "" != t3) return true;
      };
      E3.API.events.push(["addPage", function(t3) {
        this.internal.getPageInfo(t3.pageNumber).pageContext.annotations = [];
      }]), t2.events.push(["putPage", function(t3) {
        for (var n, r, i2, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t3.objId), u2 = t3.pageContext.annotations, c2 = false, l4 = 0; l4 < u2.length && !c2; l4++) switch ((n = u2[l4]).type) {
          case "link":
            (e(n.options.url) || e(n.options.pageNumber)) && (c2 = true);
            break;
          case "reference":
          case "text":
          case "freetext":
            c2 = true;
        }
        if (0 != c2) {
          this.internal.write("/Annots [");
          for (var h2 = 0; h2 < u2.length; h2++) {
            n = u2[h2];
            var f2 = this.internal.pdfEscape, d3 = this.internal.getEncryptor(t3.objId);
            switch (n.type) {
              case "reference":
                this.internal.write(" " + n.object.objId + " 0 R ");
                break;
              case "text":
                var p2 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m3 = this.internal.getEncryptor(p2.objId), v3 = n.title || "Note";
                i2 = "<</Type /Annot /Subtype /Text " + (r = "/Rect [" + a2(n.bounds.x) + " " + o2(n.bounds.y + n.bounds.h) + " " + a2(n.bounds.x + n.bounds.w) + " " + o2(n.bounds.y) + "] ") + "/Contents (" + f2(m3(n.contents)) + ")", i2 += " /Popup " + g2.objId + " 0 R", i2 += " /P " + s2.objId + " 0 R", i2 += " /T (" + f2(m3(v3)) + ") >>", p2.content = i2;
                var b3 = p2.objId + " 0 R";
                i2 = "<</Type /Annot /Subtype /Popup " + (r = "/Rect [" + a2(n.bounds.x + 30) + " " + o2(n.bounds.y + n.bounds.h) + " " + a2(n.bounds.x + n.bounds.w + 30) + " " + o2(n.bounds.y) + "] ") + " /Parent " + b3, n.open && (i2 += " /Open true"), i2 += " >>", g2.content = i2, this.internal.write(p2.objId, "0 R", g2.objId, "0 R");
                break;
              case "freetext":
                r = "/Rect [" + a2(n.bounds.x) + " " + o2(n.bounds.y) + " " + a2(n.bounds.x + n.bounds.w) + " " + o2(n.bounds.y + n.bounds.h) + "] ";
                var y3 = n.color || "#000000";
                i2 = "<</Type /Annot /Subtype /FreeText " + r + "/Contents (" + f2(d3(n.contents)) + ")", i2 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y3 + ")", i2 += " /Border [0 0 0]", i2 += " >>", this.internal.write(i2);
                break;
              case "link":
                if (n.options.name) {
                  var w3 = this.annotations._nameMap[n.options.name];
                  n.options.pageNumber = w3.page, n.options.top = w3.y;
                } else n.options.top || (n.options.top = 0);
                if (r = "/Rect [" + n.finalBounds.x + " " + n.finalBounds.y + " " + n.finalBounds.w + " " + n.finalBounds.h + "] ", i2 = "", n.options.url) i2 = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d3(n.options.url)) + ") >>";
                else if (n.options.pageNumber) switch (i2 = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(n.options.pageNumber).objId + " 0 R", n.options.magFactor = n.options.magFactor || "XYZ", n.options.magFactor) {
                  case "Fit":
                    i2 += " /Fit]";
                    break;
                  case "FitH":
                    i2 += " /FitH " + n.options.top + "]";
                    break;
                  case "FitV":
                    n.options.left = n.options.left || 0, i2 += " /FitV " + n.options.left + "]";
                    break;
                  default:
                    var N4 = o2(n.options.top);
                    n.options.left = n.options.left || 0, void 0 === n.options.zoom && (n.options.zoom = 0), i2 += " /XYZ " + n.options.left + " " + N4 + " " + n.options.zoom + "]";
                }
                "" != i2 && (i2 += " >>", this.internal.write(i2));
            }
          }
          this.internal.write("]");
        }
      }]), t2.createAnnotation = function(t3) {
        var e2 = this.internal.getCurrentPageInfo();
        switch (t3.type) {
          case "link":
            this.link(t3.bounds.x, t3.bounds.y, t3.bounds.w, t3.bounds.h, t3);
            break;
          case "text":
          case "freetext":
            e2.pageContext.annotations.push(t3);
        }
      }, t2.link = function(t3, e2, n, r, i2) {
        var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
        a2.pageContext.annotations.push({ finalBounds: { x: o2(t3), y: s2(e2), w: o2(t3 + n), h: s2(e2 + r) }, options: i2, type: "link" });
      }, t2.textWithLink = function(t3, e2, n, r) {
        var i2, a2, o2 = this.getTextWidth(t3), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
        if (void 0 !== r.maxWidth) {
          a2 = r.maxWidth;
          var u2 = this.splitTextToSize(t3, a2).length;
          i2 = Math.ceil(s2 * u2);
        } else a2 = o2, i2 = s2;
        return this.text(t3, e2, n, r), n += 0.2 * s2, "center" === r.align && (e2 -= o2 / 2), "right" === r.align && (e2 -= o2), this.link(e2, n - s2, a2, i2, r), o2;
      }, t2.getTextWidth = function(t3) {
        var e2 = this.internal.getFontSize();
        return this.getStringUnitWidth(t3) * e2 / this.internal.scaleFactor;
      };
    })(E3.API), /**
     * @license
     * Copyright (c) 2017 Aras Abbasi
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, n = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, r = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i2 = [1570, 1571, 1573, 1575];
      t2.__arabicParser__ = {};
      var a2 = t2.__arabicParser__.isInArabicSubstitutionA = function(t3) {
        return void 0 !== e[t3.charCodeAt(0)];
      }, o2 = t2.__arabicParser__.isArabicLetter = function(t3) {
        return "string" == typeof t3 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t3);
      }, s2 = t2.__arabicParser__.isArabicEndLetter = function(t3) {
        return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length <= 2;
      }, u2 = t2.__arabicParser__.isArabicAlfLetter = function(t3) {
        return o2(t3) && i2.indexOf(t3.charCodeAt(0)) >= 0;
      };
      t2.__arabicParser__.arabicLetterHasIsolatedForm = function(t3) {
        return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 1;
      };
      var c2 = t2.__arabicParser__.arabicLetterHasFinalForm = function(t3) {
        return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 2;
      };
      t2.__arabicParser__.arabicLetterHasInitialForm = function(t3) {
        return o2(t3) && a2(t3) && e[t3.charCodeAt(0)].length >= 3;
      };
      var l4 = t2.__arabicParser__.arabicLetterHasMedialForm = function(t3) {
        return o2(t3) && a2(t3) && 4 == e[t3.charCodeAt(0)].length;
      }, h2 = t2.__arabicParser__.resolveLigatures = function(t3) {
        var e2 = 0, r2 = n, i3 = "", a3 = 0;
        for (e2 = 0; e2 < t3.length; e2 += 1) void 0 !== r2[t3.charCodeAt(e2)] ? (a3++, "number" == typeof (r2 = r2[t3.charCodeAt(e2)]) && (i3 += String.fromCharCode(r2), r2 = n, a3 = 0), e2 === t3.length - 1 && (r2 = n, i3 += t3.charAt(e2 - (a3 - 1)), e2 -= a3 - 1, a3 = 0)) : (r2 = n, i3 += t3.charAt(e2 - a3), e2 -= a3, a3 = 0);
        return i3;
      };
      t2.__arabicParser__.isArabicDiacritic = function(t3) {
        return void 0 !== t3 && void 0 !== r[t3.charCodeAt(0)];
      };
      var f2 = t2.__arabicParser__.getCorrectForm = function(t3, e2, n2) {
        return o2(t3) ? false === a2(t3) ? -1 : !c2(t3) || !o2(e2) && !o2(n2) || !o2(n2) && s2(e2) || s2(t3) && !o2(e2) || s2(t3) && u2(e2) || s2(t3) && s2(e2) ? 0 : l4(t3) && o2(e2) && !s2(e2) && o2(n2) && c2(n2) ? 3 : s2(t3) || !o2(n2) ? 1 : 2 : -1;
      }, d3 = function(t3) {
        var n2 = 0, r2 = 0, i3 = 0, a3 = "", s3 = "", u3 = "", c3 = (t3 = t3 || "").split("\\s+"), l5 = [];
        for (n2 = 0; n2 < c3.length; n2 += 1) {
          for (l5.push(""), r2 = 0; r2 < c3[n2].length; r2 += 1) a3 = c3[n2][r2], s3 = c3[n2][r2 - 1], u3 = c3[n2][r2 + 1], o2(a3) ? (i3 = f2(a3, s3, u3), l5[n2] += -1 !== i3 ? String.fromCharCode(e[a3.charCodeAt(0)][i3]) : a3) : l5[n2] += a3;
          l5[n2] = h2(l5[n2]);
        }
        return l5.join(" ");
      }, p2 = t2.__arabicParser__.processArabic = t2.processArabic = function() {
        var t3, e2 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, n2 = [];
        if (Array.isArray(e2)) {
          var r2 = 0;
          for (n2 = [], r2 = 0; r2 < e2.length; r2 += 1) Array.isArray(e2[r2]) ? n2.push([d3(e2[r2][0]), e2[r2][1], e2[r2][2]]) : n2.push([d3(e2[r2])]);
          t3 = n2;
        } else t3 = d3(e2);
        return "string" == typeof arguments[0] ? t3 : (arguments[0].text = t3, arguments[0]);
      };
      t2.events.push(["preProcessText", p2]);
    })(E3.API), E3.API.autoPrint = function(t2) {
      var e;
      return (t2 = t2 || {}).variant = t2.variant || "non-conform", "javascript" === t2.variant ? this.addJS("print({});") : (this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      })), this;
    }, /**
     * @license
     * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e = function() {
        var t3 = void 0;
        Object.defineProperty(this, "pdf", { get: function() {
          return t3;
        }, set: function(e3) {
          t3 = e3;
        } });
        var e2 = 150;
        Object.defineProperty(this, "width", { get: function() {
          return e2;
        }, set: function(t4) {
          e2 = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 150 : t4, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e2 + 1);
        } });
        var n = 300;
        Object.defineProperty(this, "height", { get: function() {
          return n;
        }, set: function(t4) {
          n = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 300 : t4, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = n + 1);
        } });
        var r = [];
        Object.defineProperty(this, "childNodes", { get: function() {
          return r;
        }, set: function(t4) {
          r = t4;
        } });
        var i2 = {};
        Object.defineProperty(this, "style", { get: function() {
          return i2;
        }, set: function(t4) {
          i2 = t4;
        } }), Object.defineProperty(this, "parentNode", {});
      };
      e.prototype.getContext = function(t3, e2) {
        var n;
        if ("2d" !== (t3 = t3 || "2d")) return null;
        for (n in e2) this.pdf.context2d.hasOwnProperty(n) && (this.pdf.context2d[n] = e2[n]);
        return this.pdf.context2d._canvas = this, this.pdf.context2d;
      }, e.prototype.toDataURL = function() {
        throw new Error("toDataURL is not implemented.");
      }, t2.events.push(["initialized", function() {
        this.canvas = new e(), this.canvas.pdf = this;
      }]);
    })(E3.API), (function(e) {
      var n = { left: 0, top: 0, bottom: 0, right: 0 }, r = false, i2 = function() {
        void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, n), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
      }, a2 = function() {
        this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
      }, o2 = function() {
        var t2 = arguments[0];
        Object.defineProperty(this, "x", { enumerable: true, get: function() {
          return t2;
        }, set: function(e3) {
          t2 = e3;
        } });
        var e2 = arguments[1];
        Object.defineProperty(this, "y", { enumerable: true, get: function() {
          return e2;
        }, set: function(t3) {
          e2 = t3;
        } });
        var n2 = arguments[2];
        Object.defineProperty(this, "width", { enumerable: true, get: function() {
          return n2;
        }, set: function(t3) {
          n2 = t3;
        } });
        var r2 = arguments[3];
        Object.defineProperty(this, "height", { enumerable: true, get: function() {
          return r2;
        }, set: function(t3) {
          r2 = t3;
        } });
        var i3 = arguments[4];
        Object.defineProperty(this, "text", { enumerable: true, get: function() {
          return i3;
        }, set: function(t3) {
          i3 = t3;
        } });
        var a3 = arguments[5];
        Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
          return a3;
        }, set: function(t3) {
          a3 = t3;
        } });
        var o3 = arguments[6];
        return Object.defineProperty(this, "align", { enumerable: true, get: function() {
          return o3;
        }, set: function(t3) {
          o3 = t3;
        } }), this;
      };
      o2.prototype.clone = function() {
        return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
      }, o2.prototype.toArray = function() {
        return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
      }, e.setHeaderFunction = function(t2) {
        return i2.call(this), this.internal.__cell__.headerFunction = "function" == typeof t2 ? t2 : void 0, this;
      }, e.getTextDimensions = function(t2, e2) {
        i2.call(this);
        var n2 = (e2 = e2 || {}).fontSize || this.getFontSize(), r2 = e2.font || this.getFont(), a3 = e2.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, u3 = 0, c2 = this;
        if (!Array.isArray(t2) && "string" != typeof t2) {
          if ("number" != typeof t2) throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
          t2 = String(t2);
        }
        var l4 = e2.maxWidth;
        l4 > 0 ? "string" == typeof t2 ? t2 = this.splitTextToSize(t2, l4) : "[object Array]" === Object.prototype.toString.call(t2) && (t2 = t2.reduce(function(t3, e3) {
          return t3.concat(c2.splitTextToSize(e3, l4));
        }, [])) : t2 = Array.isArray(t2) ? t2 : [t2];
        for (var h2 = 0; h2 < t2.length; h2++) o3 < (u3 = this.getStringUnitWidth(t2[h2], { font: r2 }) * n2) && (o3 = u3);
        return 0 !== o3 && (s3 = t2.length), { w: o3 /= a3, h: Math.max((s3 * n2 * this.getLineHeightFactor() - n2 * (this.getLineHeightFactor() - 1)) / a3, 0) };
      }, e.cellAddPage = function() {
        i2.call(this), this.addPage();
        var t2 = this.internal.__cell__.margins || n;
        return this.internal.__cell__.lastCell = new o2(t2.left, t2.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
      };
      var s2 = e.cell = function() {
        var t2;
        t2 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i2.call(this);
        var e2 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || n, u3 = this.internal.__cell__.tableHeaderRow, c2 = this.internal.__cell__.printHeaders;
        return void 0 !== e2.lineNumber && (e2.lineNumber === t2.lineNumber ? (t2.x = (e2.x || 0) + (e2.width || 0), t2.y = e2.y || 0) : e2.y + e2.height + t2.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t2.y = s3.top, c2 && u3 && (this.printHeaderRow(t2.lineNumber, true), t2.y += u3[0].height)) : t2.y = e2.y + e2.height || t2.y), void 0 !== t2.text[0] && (this.rect(t2.x, t2.y, t2.width, t2.height, true === r ? "FD" : void 0), "right" === t2.align ? this.text(t2.text, t2.x + t2.width - a3, t2.y + a3, { align: "right", baseline: "top" }) : "center" === t2.align ? this.text(t2.text, t2.x + t2.width / 2, t2.y + a3, { align: "center", baseline: "top", maxWidth: t2.width - a3 - a3 }) : this.text(t2.text, t2.x + a3, t2.y + a3, { align: "left", baseline: "top", maxWidth: t2.width - a3 - a3 })), this.internal.__cell__.lastCell = t2, this;
      };
      e.table = function(e2, r2, c2, l4, h2) {
        if (i2.call(this), !c2) throw new Error("No data for PDF table.");
        var f2, d3, p2, g2, m3 = [], v3 = [], b3 = [], y3 = {}, w3 = {}, N4 = [], L4 = [], x3 = (h2 = h2 || {}).autoSize || false, A3 = false !== h2.printHeaders, S4 = h2.css && void 0 !== h2.css["font-size"] ? 16 * h2.css["font-size"] : h2.fontSize || 12, _3 = h2.margins || Object.assign({ width: this.getPageWidth() }, n), P4 = "number" == typeof h2.padding ? h2.padding : 3, k3 = h2.headerBackgroundColor || "#c8c8c8", F14 = h2.headerTextColor || "#000";
        if (a2.call(this), this.internal.__cell__.printHeaders = A3, this.internal.__cell__.margins = _3, this.internal.__cell__.table_font_size = S4, this.internal.__cell__.padding = P4, this.internal.__cell__.headerBackgroundColor = k3, this.internal.__cell__.headerTextColor = F14, this.setFontSize(S4), null == l4) v3 = m3 = Object.keys(c2[0]), b3 = m3.map(function() {
          return "left";
        });
        else if (Array.isArray(l4) && "object" === _typeof(l4[0])) for (m3 = l4.map(function(t2) {
          return t2.name;
        }), v3 = l4.map(function(t2) {
          return t2.prompt || t2.name || "";
        }), b3 = l4.map(function(t2) {
          return t2.align || "left";
        }), f2 = 0; f2 < l4.length; f2 += 1) w3[l4[f2].name] = 0.7499990551181103 * l4[f2].width;
        else Array.isArray(l4) && "string" == typeof l4[0] && (v3 = m3 = l4, b3 = m3.map(function() {
          return "left";
        }));
        if (x3 || Array.isArray(l4) && "string" == typeof l4[0]) for (f2 = 0; f2 < m3.length; f2 += 1) {
          for (y3[g2 = m3[f2]] = c2.map(function(t2) {
            return t2[g2];
          }), this.setFont(void 0, "bold"), N4.push(this.getTextDimensions(v3[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d3 = y3[g2], this.setFont(void 0, "normal"), p2 = 0; p2 < d3.length; p2 += 1) N4.push(this.getTextDimensions(d3[p2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
          w3[g2] = Math.max.apply(null, N4) + P4 + P4, N4 = [];
        }
        if (A3) {
          var I4 = {};
          for (f2 = 0; f2 < m3.length; f2 += 1) I4[m3[f2]] = {}, I4[m3[f2]].text = v3[f2], I4[m3[f2]].align = b3[f2];
          var j3 = u2.call(this, I4, w3);
          L4 = m3.map(function(t2) {
            return new o2(e2, r2, w3[t2], j3, I4[t2].text, void 0, I4[t2].align);
          }), this.setTableHeaderRow(L4), this.printHeaderRow(1, false);
        }
        var C4 = l4.reduce(function(t2, e3) {
          return t2[e3.name] = e3.align, t2;
        }, {});
        for (f2 = 0; f2 < c2.length; f2 += 1) {
          "rowStart" in h2 && h2.rowStart instanceof Function && h2.rowStart({ row: f2, data: c2[f2] }, this);
          var O3 = u2.call(this, c2[f2], w3);
          for (p2 = 0; p2 < m3.length; p2 += 1) {
            var B4 = c2[f2][m3[p2]];
            "cellStart" in h2 && h2.cellStart instanceof Function && h2.cellStart({ row: f2, col: p2, data: B4 }, this), s2.call(this, new o2(e2, r2, w3[m3[p2]], O3, B4, f2 + 2, C4[m3[p2]]));
          }
        }
        return this.internal.__cell__.table_x = e2, this.internal.__cell__.table_y = r2, this;
      };
      var u2 = function(t2, e2) {
        var n2 = this.internal.__cell__.padding, r2 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;
        return Object.keys(t2).map(function(r3) {
          var i4 = t2[r3];
          return this.splitTextToSize(i4.hasOwnProperty("text") ? i4.text : i4, e2[r3] - n2 - n2);
        }, this).map(function(t3) {
          return this.getLineHeightFactor() * t3.length * r2 / i3 + n2 + n2;
        }, this).reduce(function(t3, e3) {
          return Math.max(t3, e3);
        }, 0);
      };
      e.setTableHeaderRow = function(t2) {
        i2.call(this), this.internal.__cell__.tableHeaderRow = t2;
      }, e.printHeaderRow = function(t2, e2) {
        if (i2.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
        var n2;
        if (r = true, "function" == typeof this.internal.__cell__.headerFunction) {
          var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
          this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
        }
        this.setFont(void 0, "bold");
        for (var u3 = [], c2 = 0; c2 < this.internal.__cell__.tableHeaderRow.length; c2 += 1) {
          n2 = this.internal.__cell__.tableHeaderRow[c2].clone(), e2 && (n2.y = this.internal.__cell__.margins.top || 0, u3.push(n2)), n2.lineNumber = t2;
          var l4 = this.getTextColor();
          this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, n2), this.setTextColor(l4);
        }
        u3.length > 0 && this.setTableHeaderRow(u3), this.setFont(void 0, "normal"), r = false;
      };
    })(E3.API);
    Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] };
    kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
    Ft2 = _t(kt);
    It = [100, 200, 300, 400, 500, 600, 700, 800, 900];
    jt = _t(It);
    Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" };
    Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
    Jt = ["times"];
    !(function(e) {
      var n, r, i2, a2, s2, u2, c2, l4, f2, d3 = function(t2) {
        return t2 = t2 || {}, this.isStrokeTransparent = t2.isStrokeTransparent || false, this.strokeOpacity = t2.strokeOpacity || 1, this.strokeStyle = t2.strokeStyle || "#000000", this.fillStyle = t2.fillStyle || "#000000", this.isFillTransparent = t2.isFillTransparent || false, this.fillOpacity = t2.fillOpacity || 1, this.font = t2.font || "10px sans-serif", this.textBaseline = t2.textBaseline || "alphabetic", this.textAlign = t2.textAlign || "left", this.lineWidth = t2.lineWidth || 1, this.lineJoin = t2.lineJoin || "miter", this.lineCap = t2.lineCap || "butt", this.path = t2.path || [], this.transform = void 0 !== t2.transform ? t2.transform.clone() : new l4(), this.globalCompositeOperation = t2.globalCompositeOperation || "normal", this.globalAlpha = t2.globalAlpha || 1, this.clip_path = t2.clip_path || [], this.currentPoint = t2.currentPoint || new u2(), this.miterLimit = t2.miterLimit || 10, this.lastPoint = t2.lastPoint || new u2(), this.lineDashOffset = t2.lineDashOffset || 0, this.lineDash = t2.lineDash || [], this.margin = t2.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t2.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t2.ignoreClearRect || t2.ignoreClearRect, this;
      };
      e.events.push(["initialized", function() {
        this.context2d = new p2(this), n = this.internal.f2, r = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, a2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, u2 = this.internal.Point, c2 = this.internal.Rectangle, l4 = this.internal.Matrix, f2 = new d3();
      }]);
      var p2 = function(t2) {
        Object.defineProperty(this, "canvas", { get: function() {
          return { parentNode: false, style: false };
        } });
        var e2 = t2;
        Object.defineProperty(this, "pdf", { get: function() {
          return e2;
        } });
        var n2 = false;
        Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
          return n2;
        }, set: function(t3) {
          n2 = Boolean(t3);
        } });
        var r2 = false;
        Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
          return r2;
        }, set: function(t3) {
          r2 = Boolean(t3);
        } });
        var i3 = 0;
        Object.defineProperty(this, "posX", { get: function() {
          return i3;
        }, set: function(t3) {
          isNaN(t3) || (i3 = t3);
        } });
        var a3 = 0;
        Object.defineProperty(this, "posY", { get: function() {
          return a3;
        }, set: function(t3) {
          isNaN(t3) || (a3 = t3);
        } }), Object.defineProperty(this, "margin", { get: function() {
          return f2.margin;
        }, set: function(t3) {
          var e3;
          "number" == typeof t3 ? e3 = [t3, t3, t3, t3] : ((e3 = new Array(4))[0] = t3[0], e3[1] = t3.length >= 2 ? t3[1] : e3[0], e3[2] = t3.length >= 3 ? t3[2] : e3[0], e3[3] = t3.length >= 4 ? t3[3] : e3[1]), f2.margin = e3;
        } });
        var o2 = false;
        Object.defineProperty(this, "autoPaging", { get: function() {
          return o2;
        }, set: function(t3) {
          o2 = t3;
        } });
        var s3 = 0;
        Object.defineProperty(this, "lastBreak", { get: function() {
          return s3;
        }, set: function(t3) {
          s3 = t3;
        } });
        var u3 = [];
        Object.defineProperty(this, "pageBreaks", { get: function() {
          return u3;
        }, set: function(t3) {
          u3 = t3;
        } }), Object.defineProperty(this, "ctx", { get: function() {
          return f2;
        }, set: function(t3) {
          t3 instanceof d3 && (f2 = t3);
        } }), Object.defineProperty(this, "path", { get: function() {
          return f2.path;
        }, set: function(t3) {
          f2.path = t3;
        } });
        var c3 = [];
        Object.defineProperty(this, "ctxStack", { get: function() {
          return c3;
        }, set: function(t3) {
          c3 = t3;
        } }), Object.defineProperty(this, "fillStyle", { get: function() {
          return this.ctx.fillStyle;
        }, set: function(t3) {
          var e3;
          e3 = g2(t3), this.ctx.fillStyle = e3.style, this.ctx.isFillTransparent = 0 === e3.a, this.ctx.fillOpacity = e3.a, this.pdf.setFillColor(e3.r, e3.g, e3.b, { a: e3.a }), this.pdf.setTextColor(e3.r, e3.g, e3.b, { a: e3.a });
        } }), Object.defineProperty(this, "strokeStyle", { get: function() {
          return this.ctx.strokeStyle;
        }, set: function(t3) {
          var e3 = g2(t3);
          this.ctx.strokeStyle = e3.style, this.ctx.isStrokeTransparent = 0 === e3.a, this.ctx.strokeOpacity = e3.a, 0 === e3.a ? this.pdf.setDrawColor(255, 255, 255) : (e3.a, this.pdf.setDrawColor(e3.r, e3.g, e3.b));
        } }), Object.defineProperty(this, "lineCap", { get: function() {
          return this.ctx.lineCap;
        }, set: function(t3) {
          -1 !== ["butt", "round", "square"].indexOf(t3) && (this.ctx.lineCap = t3, this.pdf.setLineCap(t3));
        } }), Object.defineProperty(this, "lineWidth", { get: function() {
          return this.ctx.lineWidth;
        }, set: function(t3) {
          isNaN(t3) || (this.ctx.lineWidth = t3, this.pdf.setLineWidth(t3));
        } }), Object.defineProperty(this, "lineJoin", { get: function() {
          return this.ctx.lineJoin;
        }, set: function(t3) {
          -1 !== ["bevel", "round", "miter"].indexOf(t3) && (this.ctx.lineJoin = t3, this.pdf.setLineJoin(t3));
        } }), Object.defineProperty(this, "miterLimit", { get: function() {
          return this.ctx.miterLimit;
        }, set: function(t3) {
          isNaN(t3) || (this.ctx.miterLimit = t3, this.pdf.setMiterLimit(t3));
        } }), Object.defineProperty(this, "textBaseline", { get: function() {
          return this.ctx.textBaseline;
        }, set: function(t3) {
          this.ctx.textBaseline = t3;
        } }), Object.defineProperty(this, "textAlign", { get: function() {
          return this.ctx.textAlign;
        }, set: function(t3) {
          -1 !== ["right", "end", "center", "left", "start"].indexOf(t3) && (this.ctx.textAlign = t3);
        } });
        var l5 = null;
        var h2 = null;
        Object.defineProperty(this, "fontFaces", { get: function() {
          return h2;
        }, set: function(t3) {
          l5 = null, h2 = t3;
        } }), Object.defineProperty(this, "font", { get: function() {
          return this.ctx.font;
        }, set: function(t3) {
          var e3;
          if (this.ctx.font = t3, null !== (e3 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t3))) {
            var n3 = e3[1];
            e3[2];
            var r3 = e3[3], i4 = e3[4];
            e3[5];
            var a4 = e3[6], o3 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];
            i4 = "px" === o3 ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : "em" === o3 ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);
            var s4 = (function(t4) {
              var e4, n4, r4 = [], i5 = t4.trim();
              if ("" === i5) return Jt;
              if (i5 in Mt) return [Mt[i5]];
              for (; "" !== i5; ) {
                switch (n4 = null, e4 = (i5 = Et(i5)).charAt(0)) {
                  case '"':
                  case "'":
                    n4 = Rt(i5.substring(1), e4);
                    break;
                  default:
                    n4 = Dt(i5);
                }
                if (null === n4) return Jt;
                if (r4.push(n4[0]), "" !== (i5 = Et(n4[1])) && "," !== i5.charAt(0)) return Jt;
                i5 = i5.replace(/^,/, "");
              }
              return r4;
            })(a4);
            if (this.fontFaces) {
              var u4 = (function(t4, e4) {
                if (null === l5) {
                  var n4 = (function(t5) {
                    var e5 = [];
                    return Object.keys(t5).forEach(function(n5) {
                      t5[n5].forEach(function(t6) {
                        var r4 = null;
                        switch (t6) {
                          case "bold":
                            r4 = { family: n5, weight: "bold" };
                            break;
                          case "italic":
                            r4 = { family: n5, style: "italic" };
                            break;
                          case "bolditalic":
                            r4 = { family: n5, weight: "bold", style: "italic" };
                            break;
                          case "":
                          case "normal":
                            r4 = { family: n5 };
                        }
                        null !== r4 && (r4.ref = { name: n5, style: t6 }, e5.push(r4));
                      });
                    }), e5;
                  })(t4.getFontList());
                  l5 = (function(t5) {
                    for (var e5 = {}, n5 = 0; n5 < t5.length; ++n5) {
                      var r4 = Ct(t5[n5]), i5 = r4.family, a5 = r4.stretch, o4 = r4.style, s5 = r4.weight;
                      e5[i5] = e5[i5] || {}, e5[i5][a5] = e5[i5][a5] || {}, e5[i5][a5][o4] = e5[i5][a5][o4] || {}, e5[i5][a5][o4][s5] = r4;
                    }
                    return e5;
                  })(n4.concat(e4));
                }
                return l5;
              })(this.pdf, this.fontFaces), c4 = s4.map(function(t4) {
                return { family: t4, stretch: "normal", weight: r3, style: n3 };
              }), h3 = (function(t4, e4, n4) {
                for (var r4 = (n4 = n4 || {}).defaultFontFamily || "times", i5 = Object.assign({}, Bt, n4.genericFontFamilies || {}), a5 = null, o4 = null, s5 = 0; s5 < e4.length; ++s5) if (i5[(a5 = Ct(e4[s5])).family] && (a5.family = i5[a5.family]), t4.hasOwnProperty(a5.family)) {
                  o4 = t4[a5.family];
                  break;
                }
                if (!(o4 = o4 || t4[r4])) throw new Error("Could not find a font-family for the rule '" + qt(a5) + "' and default family '" + r4 + "'.");
                if (o4 = (function(t5, e5) {
                  if (e5[t5]) return e5[t5];
                  var n5 = Ft2[t5], r5 = n5 <= Ft2.normal ? -1 : 1, i6 = Ot(e5, kt, n5, r5);
                  if (!i6) throw new Error("Could not find a matching font-stretch value for " + t5);
                  return i6;
                })(a5.stretch, o4), o4 = (function(t5, e5) {
                  if (e5[t5]) return e5[t5];
                  for (var n5 = Pt[t5], r5 = 0; r5 < n5.length; ++r5) if (e5[n5[r5]]) return e5[n5[r5]];
                  throw new Error("Could not find a matching font-style for " + t5);
                })(a5.style, o4), !(o4 = (function(t5, e5) {
                  if (e5[t5]) return e5[t5];
                  if (400 === t5 && e5[500]) return e5[500];
                  if (500 === t5 && e5[400]) return e5[400];
                  var n5 = jt[t5], r5 = Ot(e5, It, n5, t5 < 400 ? -1 : 1);
                  if (!r5) throw new Error("Could not find a matching font-weight for value " + t5);
                  return r5;
                })(a5.weight, o4))) throw new Error("Failed to resolve a font for the rule '" + qt(a5) + "'.");
                return o4;
              })(u4, c4);
              this.pdf.setFont(h3.ref.name, h3.ref.style);
            } else {
              var f3 = "";
              ("bold" === r3 || parseInt(r3, 10) >= 700 || "bold" === n3) && (f3 = "bold"), "italic" === n3 && (f3 += "italic"), 0 === f3.length && (f3 = "normal");
              for (var d4 = "", p3 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, g3 = 0; g3 < s4.length; g3++) {
                if (void 0 !== this.pdf.internal.getFont(s4[g3], f3, { noFallback: true, disableWarning: true })) {
                  d4 = s4[g3];
                  break;
                }
                if ("bolditalic" === f3 && void 0 !== this.pdf.internal.getFont(s4[g3], "bold", { noFallback: true, disableWarning: true })) d4 = s4[g3], f3 = "bold";
                else if (void 0 !== this.pdf.internal.getFont(s4[g3], "normal", { noFallback: true, disableWarning: true })) {
                  d4 = s4[g3], f3 = "normal";
                  break;
                }
              }
              if ("" === d4) {
                for (var m4 = 0; m4 < s4.length; m4++) if (p3[s4[m4]]) {
                  d4 = p3[s4[m4]];
                  break;
                }
              }
              d4 = "" === d4 ? "Times" : d4, this.pdf.setFont(d4, f3);
            }
          }
        } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
          return this.ctx.globalCompositeOperation;
        }, set: function(t3) {
          this.ctx.globalCompositeOperation = t3;
        } }), Object.defineProperty(this, "globalAlpha", { get: function() {
          return this.ctx.globalAlpha;
        }, set: function(t3) {
          this.ctx.globalAlpha = t3;
        } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
          return this.ctx.lineDashOffset;
        }, set: function(t3) {
          this.ctx.lineDashOffset = t3, T4.call(this);
        } }), Object.defineProperty(this, "lineDash", { get: function() {
          return this.ctx.lineDash;
        }, set: function(t3) {
          this.ctx.lineDash = t3, T4.call(this);
        } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
          return this.ctx.ignoreClearRect;
        }, set: function(t3) {
          this.ctx.ignoreClearRect = Boolean(t3);
        } });
      };
      p2.prototype.setLineDash = function(t2) {
        this.lineDash = t2;
      }, p2.prototype.getLineDash = function() {
        return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
      }, p2.prototype.fill = function() {
        x3.call(this, "fill", false);
      }, p2.prototype.stroke = function() {
        x3.call(this, "stroke", false);
      }, p2.prototype.beginPath = function() {
        this.path = [{ type: "begin" }];
      }, p2.prototype.moveTo = function(t2, e2) {
        if (isNaN(t2) || isNaN(e2)) throw o.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
        var n2 = this.ctx.transform.applyToPoint(new u2(t2, e2));
        this.path.push({ type: "mt", x: n2.x, y: n2.y }), this.ctx.lastPoint = new u2(t2, e2);
      }, p2.prototype.closePath = function() {
        var e2 = new u2(0, 0), n2 = 0;
        for (n2 = this.path.length - 1; -1 !== n2; n2--) if ("begin" === this.path[n2].type && "object" === _typeof(this.path[n2 + 1]) && "number" == typeof this.path[n2 + 1].x) {
          e2 = new u2(this.path[n2 + 1].x, this.path[n2 + 1].y);
          break;
        }
        this.path.push({ type: "close" }), this.ctx.lastPoint = new u2(e2.x, e2.y);
      }, p2.prototype.lineTo = function(t2, e2) {
        if (isNaN(t2) || isNaN(e2)) throw o.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
        var n2 = this.ctx.transform.applyToPoint(new u2(t2, e2));
        this.path.push({ type: "lt", x: n2.x, y: n2.y }), this.ctx.lastPoint = new u2(n2.x, n2.y);
      }, p2.prototype.clip = function() {
        this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), x3.call(this, null, true);
      }, p2.prototype.quadraticCurveTo = function(t2, e2, n2, r2) {
        if (isNaN(n2) || isNaN(r2) || isNaN(t2) || isNaN(e2)) throw o.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
        var i3 = this.ctx.transform.applyToPoint(new u2(n2, r2)), a3 = this.ctx.transform.applyToPoint(new u2(t2, e2));
        this.path.push({ type: "qct", x1: a3.x, y1: a3.y, x: i3.x, y: i3.y }), this.ctx.lastPoint = new u2(i3.x, i3.y);
      }, p2.prototype.bezierCurveTo = function(t2, e2, n2, r2, i3, a3) {
        if (isNaN(i3) || isNaN(a3) || isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2)) throw o.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
        var s3 = this.ctx.transform.applyToPoint(new u2(i3, a3)), c3 = this.ctx.transform.applyToPoint(new u2(t2, e2)), l5 = this.ctx.transform.applyToPoint(new u2(n2, r2));
        this.path.push({ type: "bct", x1: c3.x, y1: c3.y, x2: l5.x, y2: l5.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new u2(s3.x, s3.y);
      }, p2.prototype.arc = function(t2, e2, n2, r2, i3, a3) {
        if (isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2) || isNaN(i3)) throw o.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
        if (a3 = Boolean(a3), !this.ctx.transform.isIdentity) {
          var s3 = this.ctx.transform.applyToPoint(new u2(t2, e2));
          t2 = s3.x, e2 = s3.y;
          var c3 = this.ctx.transform.applyToPoint(new u2(0, n2)), l5 = this.ctx.transform.applyToPoint(new u2(0, 0));
          n2 = Math.sqrt(Math.pow(c3.x - l5.x, 2) + Math.pow(c3.y - l5.y, 2));
        }
        Math.abs(i3 - r2) >= 2 * Math.PI && (r2 = 0, i3 = 2 * Math.PI), this.path.push({ type: "arc", x: t2, y: e2, radius: n2, startAngle: r2, endAngle: i3, counterclockwise: a3 });
      }, p2.prototype.arcTo = function(t2, e2, n2, r2, i3) {
        throw new Error("arcTo not implemented.");
      }, p2.prototype.rect = function(t2, e2, n2, r2) {
        if (isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2)) throw o.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
        this.moveTo(t2, e2), this.lineTo(t2 + n2, e2), this.lineTo(t2 + n2, e2 + r2), this.lineTo(t2, e2 + r2), this.lineTo(t2, e2), this.lineTo(t2 + n2, e2), this.lineTo(t2, e2);
      }, p2.prototype.fillRect = function(t2, e2, n2, r2) {
        if (isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2)) throw o.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
        if (!m3.call(this)) {
          var i3 = {};
          "butt" !== this.lineCap && (i3.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i3.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t2, e2, n2, r2), this.fill(), i3.hasOwnProperty("lineCap") && (this.lineCap = i3.lineCap), i3.hasOwnProperty("lineJoin") && (this.lineJoin = i3.lineJoin);
        }
      }, p2.prototype.strokeRect = function(t2, e2, n2, r2) {
        if (isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2)) throw o.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
        v3.call(this) || (this.beginPath(), this.rect(t2, e2, n2, r2), this.stroke());
      }, p2.prototype.clearRect = function(t2, e2, n2, r2) {
        if (isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2)) throw o.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
        this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t2, e2, n2, r2));
      }, p2.prototype.save = function(t2) {
        t2 = "boolean" != typeof t2 || t2;
        for (var e2 = this.pdf.internal.getCurrentPageInfo().pageNumber, n2 = 0; n2 < this.pdf.internal.getNumberOfPages(); n2++) this.pdf.setPage(n2 + 1), this.pdf.internal.out("q");
        if (this.pdf.setPage(e2), t2) {
          this.ctx.fontSize = this.pdf.internal.getFontSize();
          var r2 = new d3(this.ctx);
          this.ctxStack.push(this.ctx), this.ctx = r2;
        }
      }, p2.prototype.restore = function(t2) {
        t2 = "boolean" != typeof t2 || t2;
        for (var e2 = this.pdf.internal.getCurrentPageInfo().pageNumber, n2 = 0; n2 < this.pdf.internal.getNumberOfPages(); n2++) this.pdf.setPage(n2 + 1), this.pdf.internal.out("Q");
        this.pdf.setPage(e2), t2 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
      }, p2.prototype.toDataURL = function() {
        throw new Error("toDataUrl not implemented.");
      };
      var g2 = function(t2) {
        var e2, n2, r2, i3;
        if (true === t2.isCanvasGradient && (t2 = t2.getColor()), !t2) return { r: 0, g: 0, b: 0, a: 0, style: t2 };
        if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t2)) e2 = 0, n2 = 0, r2 = 0, i3 = 0;
        else {
          var a3 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t2);
          if (null !== a3) e2 = parseInt(a3[1]), n2 = parseInt(a3[2]), r2 = parseInt(a3[3]), i3 = 1;
          else if (null !== (a3 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t2))) e2 = parseInt(a3[1]), n2 = parseInt(a3[2]), r2 = parseInt(a3[3]), i3 = parseFloat(a3[4]);
          else {
            if (i3 = 1, "string" == typeof t2 && "#" !== t2.charAt(0)) {
              var o2 = new h(t2);
              t2 = o2.ok ? o2.toHex() : "#000000";
            }
            4 === t2.length ? (e2 = t2.substring(1, 2), e2 += e2, n2 = t2.substring(2, 3), n2 += n2, r2 = t2.substring(3, 4), r2 += r2) : (e2 = t2.substring(1, 3), n2 = t2.substring(3, 5), r2 = t2.substring(5, 7)), e2 = parseInt(e2, 16), n2 = parseInt(n2, 16), r2 = parseInt(r2, 16);
          }
        }
        return { r: e2, g: n2, b: r2, a: i3, style: t2 };
      }, m3 = function() {
        return this.ctx.isFillTransparent || 0 == this.globalAlpha;
      }, v3 = function() {
        return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
      };
      p2.prototype.fillText = function(t2, e2, n2, r2) {
        if (isNaN(e2) || isNaN(n2) || "string" != typeof t2) throw o.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
        if (r2 = isNaN(r2) ? void 0 : r2, !m3.call(this)) {
          var i3 = E4(this.ctx.transform.rotation), a3 = this.ctx.transform.scaleX;
          j3.call(this, { text: t2, x: e2, y: n2, scale: a3, angle: i3, align: this.textAlign, maxWidth: r2 });
        }
      }, p2.prototype.strokeText = function(t2, e2, n2, r2) {
        if (isNaN(e2) || isNaN(n2) || "string" != typeof t2) throw o.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
        if (!v3.call(this)) {
          r2 = isNaN(r2) ? void 0 : r2;
          var i3 = E4(this.ctx.transform.rotation), a3 = this.ctx.transform.scaleX;
          j3.call(this, { text: t2, x: e2, y: n2, scale: a3, renderingMode: "stroke", angle: i3, align: this.textAlign, maxWidth: r2 });
        }
      }, p2.prototype.measureText = function(t2) {
        if ("string" != typeof t2) throw o.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
        var e2 = this.pdf, n2 = this.pdf.internal.scaleFactor, r2 = e2.internal.getFontSize(), i3 = e2.getStringUnitWidth(t2) * r2 / e2.internal.scaleFactor;
        return new function(t3) {
          var e3 = (t3 = t3 || {}).width || 0;
          return Object.defineProperty(this, "width", { get: function() {
            return e3;
          } }), this;
        }({ width: i3 *= Math.round(96 * n2 / 72 * 1e4) / 1e4 });
      }, p2.prototype.scale = function(t2, e2) {
        if (isNaN(t2) || isNaN(e2)) throw o.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
        var n2 = new l4(t2, 0, 0, e2, 0, 0);
        this.ctx.transform = this.ctx.transform.multiply(n2);
      }, p2.prototype.rotate = function(t2) {
        if (isNaN(t2)) throw o.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
        var e2 = new l4(Math.cos(t2), Math.sin(t2), -Math.sin(t2), Math.cos(t2), 0, 0);
        this.ctx.transform = this.ctx.transform.multiply(e2);
      }, p2.prototype.translate = function(t2, e2) {
        if (isNaN(t2) || isNaN(e2)) throw o.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
        var n2 = new l4(1, 0, 0, 1, t2, e2);
        this.ctx.transform = this.ctx.transform.multiply(n2);
      }, p2.prototype.transform = function(t2, e2, n2, r2, i3, a3) {
        if (isNaN(t2) || isNaN(e2) || isNaN(n2) || isNaN(r2) || isNaN(i3) || isNaN(a3)) throw o.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
        var s3 = new l4(t2, e2, n2, r2, i3, a3);
        this.ctx.transform = this.ctx.transform.multiply(s3);
      }, p2.prototype.setTransform = function(t2, e2, n2, r2, i3, a3) {
        t2 = isNaN(t2) ? 1 : t2, e2 = isNaN(e2) ? 0 : e2, n2 = isNaN(n2) ? 0 : n2, r2 = isNaN(r2) ? 1 : r2, i3 = isNaN(i3) ? 0 : i3, a3 = isNaN(a3) ? 0 : a3, this.ctx.transform = new l4(t2, e2, n2, r2, i3, a3);
      };
      var b3 = function() {
        return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
      };
      p2.prototype.drawImage = function(t2, e2, n2, r2, i3, a3, o2, s3, u3) {
        var h2 = this.pdf.getImageProperties(t2), f3 = 1, d4 = 1, p3 = 1, g3 = 1;
        void 0 !== r2 && void 0 !== s3 && (p3 = s3 / r2, g3 = u3 / i3, f3 = h2.width / r2 * s3 / r2, d4 = h2.height / i3 * u3 / i3), void 0 === a3 && (a3 = e2, o2 = n2, e2 = 0, n2 = 0), void 0 !== r2 && void 0 === s3 && (s3 = r2, u3 = i3), void 0 === r2 && void 0 === s3 && (s3 = h2.width, u3 = h2.height);
        for (var m4, v4 = this.ctx.transform.decompose(), w4 = E4(v4.rotate.shx), x4 = new l4(), S5 = (x4 = (x4 = (x4 = x4.multiply(v4.translate)).multiply(v4.skew)).multiply(v4.scale)).applyToRectangle(new c2(a3 - e2 * p3, o2 - n2 * g3, r2 * f3, i3 * d4)), _4 = y3.call(this, S5), P5 = [], k4 = 0; k4 < _4.length; k4 += 1) -1 === P5.indexOf(_4[k4]) && P5.push(_4[k4]);
        if (L4(P5), this.autoPaging) for (var F15 = P5[0], I5 = P5[P5.length - 1], j4 = F15; j4 < I5 + 1; j4++) {
          this.pdf.setPage(j4);
          var C5 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O4 = 1 === j4 ? this.posY + this.margin[0] : this.margin[0], B5 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M5 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], q4 = 1 === j4 ? 0 : B5 + (j4 - 2) * M5;
          if (0 !== this.ctx.clip_path.length) {
            var R4 = this.path;
            m4 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N4(m4, this.posX + this.margin[3], -q4 + O4 + this.ctx.prevPageLastElemOffset), A3.call(this, "fill", true), this.path = R4;
          }
          var D5 = JSON.parse(JSON.stringify(S5));
          D5 = N4([D5], this.posX + this.margin[3], -q4 + O4 + this.ctx.prevPageLastElemOffset)[0];
          var T5 = (j4 > F15 || j4 < I5) && b3.call(this);
          T5 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], C5, M5, null).clip().discardPath()), this.pdf.addImage(t2, "JPEG", D5.x, D5.y, D5.w, D5.h, null, null, w4), T5 && this.pdf.restoreGraphicsState();
        }
        else this.pdf.addImage(t2, "JPEG", S5.x, S5.y, S5.w, S5.h, null, null, w4);
      };
      var y3 = function(t2, e2, n2) {
        var r2 = [];
        e2 = e2 || this.pdf.internal.pageSize.width, n2 = n2 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
        var i3 = this.posY + this.ctx.prevPageLastElemOffset;
        switch (t2.type) {
          default:
          case "mt":
          case "lt":
            r2.push(Math.floor((t2.y + i3) / n2) + 1);
            break;
          case "arc":
            r2.push(Math.floor((t2.y + i3 - t2.radius) / n2) + 1), r2.push(Math.floor((t2.y + i3 + t2.radius) / n2) + 1);
            break;
          case "qct":
            var a3 = R3(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x, t2.y);
            r2.push(Math.floor((a3.y + i3) / n2) + 1), r2.push(Math.floor((a3.y + a3.h + i3) / n2) + 1);
            break;
          case "bct":
            var o2 = D4(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x2, t2.y2, t2.x, t2.y);
            r2.push(Math.floor((o2.y + i3) / n2) + 1), r2.push(Math.floor((o2.y + o2.h + i3) / n2) + 1);
            break;
          case "rect":
            r2.push(Math.floor((t2.y + i3) / n2) + 1), r2.push(Math.floor((t2.y + t2.h + i3) / n2) + 1);
        }
        for (var s3 = 0; s3 < r2.length; s3 += 1) for (; this.pdf.internal.getNumberOfPages() < r2[s3]; ) w3.call(this);
        return r2;
      }, w3 = function() {
        var t2 = this.fillStyle, e2 = this.strokeStyle, n2 = this.font, r2 = this.lineCap, i3 = this.lineWidth, a3 = this.lineJoin;
        this.pdf.addPage(), this.fillStyle = t2, this.strokeStyle = e2, this.font = n2, this.lineCap = r2, this.lineWidth = i3, this.lineJoin = a3;
      }, N4 = function(t2, e2, n2) {
        for (var r2 = 0; r2 < t2.length; r2++) switch (t2[r2].type) {
          case "bct":
            t2[r2].x2 += e2, t2[r2].y2 += n2;
          case "qct":
            t2[r2].x1 += e2, t2[r2].y1 += n2;
          default:
            t2[r2].x += e2, t2[r2].y += n2;
        }
        return t2;
      }, L4 = function(t2) {
        return t2.sort(function(t3, e2) {
          return t3 - e2;
        });
      }, x3 = function(t2, e2) {
        for (var n2, r2, i3 = this.fillStyle, a3 = this.strokeStyle, o2 = this.lineCap, s3 = this.lineWidth, u3 = Math.abs(s3 * this.ctx.transform.scaleX), c3 = this.lineJoin, l5 = JSON.parse(JSON.stringify(this.path)), h2 = JSON.parse(JSON.stringify(this.path)), f3 = [], d4 = 0; d4 < h2.length; d4++) if (void 0 !== h2[d4].x) for (var p3 = y3.call(this, h2[d4]), g3 = 0; g3 < p3.length; g3 += 1) -1 === f3.indexOf(p3[g3]) && f3.push(p3[g3]);
        for (var m4 = 0; m4 < f3.length; m4++) for (; this.pdf.internal.getNumberOfPages() < f3[m4]; ) w3.call(this);
        if (L4(f3), this.autoPaging) for (var v4 = f3[0], x4 = f3[f3.length - 1], S5 = v4; S5 < x4 + 1; S5++) {
          this.pdf.setPage(S5), this.fillStyle = i3, this.strokeStyle = a3, this.lineCap = o2, this.lineWidth = u3, this.lineJoin = c3;
          var _4 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P5 = 1 === S5 ? this.posY + this.margin[0] : this.margin[0], k4 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], F15 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], I5 = 1 === S5 ? 0 : k4 + (S5 - 2) * F15;
          if (0 !== this.ctx.clip_path.length) {
            var j4 = this.path;
            n2 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N4(n2, this.posX + this.margin[3], -I5 + P5 + this.ctx.prevPageLastElemOffset), A3.call(this, t2, true), this.path = j4;
          }
          if (r2 = JSON.parse(JSON.stringify(l5)), this.path = N4(r2, this.posX + this.margin[3], -I5 + P5 + this.ctx.prevPageLastElemOffset), false === e2 || 0 === S5) {
            var C5 = (S5 > v4 || S5 < x4) && b3.call(this);
            C5 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _4, F15, null).clip().discardPath()), A3.call(this, t2, e2), C5 && this.pdf.restoreGraphicsState();
          }
          this.lineWidth = s3;
        }
        else this.lineWidth = u3, A3.call(this, t2, e2), this.lineWidth = s3;
        this.path = l5;
      }, A3 = function(t2, e2) {
        if (("stroke" !== t2 || e2 || !v3.call(this)) && ("stroke" === t2 || e2 || !m3.call(this))) {
          for (var n2, r2, i3 = [], a3 = this.path, o2 = 0; o2 < a3.length; o2++) {
            var s3 = a3[o2];
            switch (s3.type) {
              case "begin":
                i3.push({ begin: true });
                break;
              case "close":
                i3.push({ close: true });
                break;
              case "mt":
                i3.push({ start: s3, deltas: [], abs: [] });
                break;
              case "lt":
                var u3 = i3.length;
                if (a3[o2 - 1] && !isNaN(a3[o2 - 1].x) && (n2 = [s3.x - a3[o2 - 1].x, s3.y - a3[o2 - 1].y], u3 > 0)) {
                  for (; u3 >= 0; u3--) if (true !== i3[u3 - 1].close && true !== i3[u3 - 1].begin) {
                    i3[u3 - 1].deltas.push(n2), i3[u3 - 1].abs.push(s3);
                    break;
                  }
                }
                break;
              case "bct":
                n2 = [s3.x1 - a3[o2 - 1].x, s3.y1 - a3[o2 - 1].y, s3.x2 - a3[o2 - 1].x, s3.y2 - a3[o2 - 1].y, s3.x - a3[o2 - 1].x, s3.y - a3[o2 - 1].y], i3[i3.length - 1].deltas.push(n2);
                break;
              case "qct":
                var c3 = a3[o2 - 1].x + 2 / 3 * (s3.x1 - a3[o2 - 1].x), l5 = a3[o2 - 1].y + 2 / 3 * (s3.y1 - a3[o2 - 1].y), h2 = s3.x + 2 / 3 * (s3.x1 - s3.x), f3 = s3.y + 2 / 3 * (s3.y1 - s3.y), d4 = s3.x, p3 = s3.y;
                n2 = [c3 - a3[o2 - 1].x, l5 - a3[o2 - 1].y, h2 - a3[o2 - 1].x, f3 - a3[o2 - 1].y, d4 - a3[o2 - 1].x, p3 - a3[o2 - 1].y], i3[i3.length - 1].deltas.push(n2);
                break;
              case "arc":
                i3.push({ deltas: [], abs: [], arc: true }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s3);
            }
          }
          r2 = e2 ? null : "stroke" === t2 ? "stroke" : "fill";
          for (var g3 = false, b4 = 0; b4 < i3.length; b4++) if (i3[b4].arc) for (var y4 = i3[b4].abs, w4 = 0; w4 < y4.length; w4++) {
            var N5 = y4[w4];
            "arc" === N5.type ? P4.call(this, N5.x, N5.y, N5.radius, N5.startAngle, N5.endAngle, N5.counterclockwise, void 0, e2, !g3) : C4.call(this, N5.x, N5.y), g3 = true;
          }
          else if (true === i3[b4].close) this.pdf.internal.out("h"), g3 = false;
          else if (true !== i3[b4].begin) {
            var L5 = i3[b4].start.x, x4 = i3[b4].start.y;
            O3.call(this, i3[b4].deltas, L5, x4), g3 = true;
          }
          r2 && k3.call(this, r2), e2 && F14.call(this);
        }
      }, S4 = function(t2) {
        var e2 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, n2 = e2 * (this.pdf.internal.getLineHeightFactor() - 1);
        switch (this.ctx.textBaseline) {
          case "bottom":
            return t2 - n2;
          case "top":
            return t2 + e2 - n2;
          case "hanging":
            return t2 + e2 - 2 * n2;
          case "middle":
            return t2 + e2 / 2 - n2;
          default:
            return t2;
        }
      }, _3 = function(t2) {
        return t2 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
      };
      p2.prototype.createLinearGradient = function() {
        var t2 = function() {
        };
        return t2.colorStops = [], t2.addColorStop = function(t3, e2) {
          this.colorStops.push([t3, e2]);
        }, t2.getColor = function() {
          return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
        }, t2.isCanvasGradient = true, t2;
      }, p2.prototype.createPattern = function() {
        return this.createLinearGradient();
      }, p2.prototype.createRadialGradient = function() {
        return this.createLinearGradient();
      };
      var P4 = function(t2, e2, n2, r2, i3, a3, o2, s3, u3) {
        for (var c3 = M4.call(this, n2, r2, i3, a3), l5 = 0; l5 < c3.length; l5++) {
          var h2 = c3[l5];
          0 === l5 && (u3 ? I4.call(this, h2.x1 + t2, h2.y1 + e2) : C4.call(this, h2.x1 + t2, h2.y1 + e2)), B4.call(this, t2, e2, h2.x2, h2.y2, h2.x3, h2.y3, h2.x4, h2.y4);
        }
        s3 ? F14.call(this) : k3.call(this, o2);
      }, k3 = function(t2) {
        switch (t2) {
          case "stroke":
            this.pdf.internal.out("S");
            break;
          case "fill":
            this.pdf.internal.out("f");
        }
      }, F14 = function() {
        this.pdf.clip(), this.pdf.discardPath();
      }, I4 = function(t2, e2) {
        this.pdf.internal.out(r(t2) + " " + i2(e2) + " m");
      }, j3 = function(t2) {
        var e2;
        switch (t2.align) {
          case "right":
          case "end":
            e2 = "right";
            break;
          case "center":
            e2 = "center";
            break;
          default:
            e2 = "left";
        }
        var n2 = this.pdf.getTextDimensions(t2.text), r2 = S4.call(this, t2.y), i3 = _3.call(this, r2) - n2.h, a3 = this.ctx.transform.applyToPoint(new u2(t2.x, r2)), o2 = this.ctx.transform.decompose(), s3 = new l4();
        s3 = (s3 = (s3 = s3.multiply(o2.translate)).multiply(o2.skew)).multiply(o2.scale);
        for (var h2, f3, d4, p3 = this.ctx.transform.applyToRectangle(new c2(t2.x, r2, n2.w, n2.h)), g3 = s3.applyToRectangle(new c2(t2.x, i3, n2.w, n2.h)), m4 = y3.call(this, g3), v4 = [], w4 = 0; w4 < m4.length; w4 += 1) -1 === v4.indexOf(m4[w4]) && v4.push(m4[w4]);
        if (L4(v4), this.autoPaging) for (var x4 = v4[0], P5 = v4[v4.length - 1], k4 = x4; k4 < P5 + 1; k4++) {
          this.pdf.setPage(k4);
          var F15 = 1 === k4 ? this.posY + this.margin[0] : this.margin[0], I5 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], j4 = this.pdf.internal.pageSize.height - this.margin[2], C5 = j4 - this.margin[0], O4 = this.pdf.internal.pageSize.width - this.margin[1], B5 = O4 - this.margin[3], M5 = 1 === k4 ? 0 : I5 + (k4 - 2) * C5;
          if (0 !== this.ctx.clip_path.length) {
            var q4 = this.path;
            h2 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N4(h2, this.posX + this.margin[3], -1 * M5 + F15), A3.call(this, "fill", true), this.path = q4;
          }
          var E5 = N4([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M5 + F15 + this.ctx.prevPageLastElemOffset)[0];
          t2.scale >= 0.01 && (f3 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f3 * t2.scale), d4 = this.lineWidth, this.lineWidth = d4 * t2.scale);
          var R4 = "text" !== this.autoPaging;
          if (R4 || E5.y + E5.h <= j4) {
            if (R4 || E5.y >= F15 && E5.x <= O4) {
              var D5 = R4 ? t2.text : this.pdf.splitTextToSize(t2.text, t2.maxWidth || O4 - E5.x)[0], T5 = N4([JSON.parse(JSON.stringify(p3))], this.posX + this.margin[3], -M5 + F15 + this.ctx.prevPageLastElemOffset)[0], z3 = R4 && (k4 > x4 || k4 < P5) && b3.call(this);
              z3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B5, C5, null).clip().discardPath()), this.pdf.text(D5, T5.x, T5.y, { angle: t2.angle, align: e2, renderingMode: t2.renderingMode }), z3 && this.pdf.restoreGraphicsState();
            }
          } else E5.y < j4 && (this.ctx.prevPageLastElemOffset += j4 - E5.y);
          t2.scale >= 0.01 && (this.pdf.setFontSize(f3), this.lineWidth = d4);
        }
        else t2.scale >= 0.01 && (f3 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f3 * t2.scale), d4 = this.lineWidth, this.lineWidth = d4 * t2.scale), this.pdf.text(t2.text, a3.x + this.posX, a3.y + this.posY, { angle: t2.angle, align: e2, renderingMode: t2.renderingMode, maxWidth: t2.maxWidth }), t2.scale >= 0.01 && (this.pdf.setFontSize(f3), this.lineWidth = d4);
      }, C4 = function(t2, e2, n2, a3) {
        n2 = n2 || 0, a3 = a3 || 0, this.pdf.internal.out(r(t2 + n2) + " " + i2(e2 + a3) + " l");
      }, O3 = function(t2, e2, n2) {
        return this.pdf.lines(t2, e2, n2, null, null);
      }, B4 = function(t2, e2, r2, i3, o2, u3, c3, l5) {
        this.pdf.internal.out([n(a2(r2 + t2)), n(s2(i3 + e2)), n(a2(o2 + t2)), n(s2(u3 + e2)), n(a2(c3 + t2)), n(s2(l5 + e2)), "c"].join(" "));
      }, M4 = function(t2, e2, n2, r2) {
        for (var i3 = 2 * Math.PI, a3 = Math.PI / 2; e2 > n2; ) e2 -= i3;
        var o2 = Math.abs(n2 - e2);
        o2 < i3 && r2 && (o2 = i3 - o2);
        for (var s3 = [], u3 = r2 ? -1 : 1, c3 = e2; o2 > 1e-5; ) {
          var l5 = c3 + u3 * Math.min(o2, a3);
          s3.push(q3.call(this, t2, c3, l5)), o2 -= Math.abs(l5 - c3), c3 = l5;
        }
        return s3;
      }, q3 = function(t2, e2, n2) {
        var r2 = (n2 - e2) / 2, i3 = t2 * Math.cos(r2), a3 = t2 * Math.sin(r2), o2 = i3, s3 = -a3, u3 = o2 * o2 + s3 * s3, c3 = u3 + o2 * i3 + s3 * a3, l5 = 4 / 3 * (Math.sqrt(2 * u3 * c3) - c3) / (o2 * a3 - s3 * i3), h2 = o2 - l5 * s3, f3 = s3 + l5 * o2, d4 = h2, p3 = -f3, g3 = r2 + e2, m4 = Math.cos(g3), v4 = Math.sin(g3);
        return { x1: t2 * Math.cos(e2), y1: t2 * Math.sin(e2), x2: h2 * m4 - f3 * v4, y2: h2 * v4 + f3 * m4, x3: d4 * m4 - p3 * v4, y3: d4 * v4 + p3 * m4, x4: t2 * Math.cos(n2), y4: t2 * Math.sin(n2) };
      }, E4 = function(t2) {
        return 180 * t2 / Math.PI;
      }, R3 = function(t2, e2, n2, r2, i3, a3) {
        var o2 = t2 + 0.5 * (n2 - t2), s3 = e2 + 0.5 * (r2 - e2), u3 = i3 + 0.5 * (n2 - i3), l5 = a3 + 0.5 * (r2 - a3), h2 = Math.min(t2, i3, o2, u3), f3 = Math.max(t2, i3, o2, u3), d4 = Math.min(e2, a3, s3, l5), p3 = Math.max(e2, a3, s3, l5);
        return new c2(h2, d4, f3 - h2, p3 - d4);
      }, D4 = function(t2, e2, n2, r2, i3, a3, o2, s3) {
        var u3, l5, h2, f3, d4, p3, g3, m4, v4, b4, y4, w4, N5, L5, x4 = n2 - t2, A4 = r2 - e2, S5 = i3 - n2, _4 = a3 - r2, P5 = o2 - i3, k4 = s3 - a3;
        for (l5 = 0; l5 < 41; l5++) v4 = (g3 = (h2 = t2 + (u3 = l5 / 40) * x4) + u3 * ((d4 = n2 + u3 * S5) - h2)) + u3 * (d4 + u3 * (i3 + u3 * P5 - d4) - g3), b4 = (m4 = (f3 = e2 + u3 * A4) + u3 * ((p3 = r2 + u3 * _4) - f3)) + u3 * (p3 + u3 * (a3 + u3 * k4 - p3) - m4), 0 == l5 ? (y4 = v4, w4 = b4, N5 = v4, L5 = b4) : (y4 = Math.min(y4, v4), w4 = Math.min(w4, b4), N5 = Math.max(N5, v4), L5 = Math.max(L5, b4));
        return new c2(Math.round(y4), Math.round(w4), Math.round(N5 - y4), Math.round(L5 - w4));
      }, T4 = function() {
        if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
          var t2, e2, n2 = (t2 = this.ctx.lineDash, e2 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t2, lineDashOffset: e2 }));
          this.prevLineDash !== n2 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = n2);
        }
      };
    })(E3.API), /**
     * @license
     * jsPDF filters PlugIn
     * Copyright (c) 2014 Aras Abbasi
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var n = function(t3) {
        var e, n2, r2, i3, a3, o3, s2, u2, c2, l4;
        for (/[^\x00-\xFF]/.test(t3), n2 = [], r2 = 0, i3 = (t3 += e = "\0\0\0\0".slice(t3.length % 4 || 4)).length; i3 > r2; r2 += 4) 0 !== (a3 = (t3.charCodeAt(r2) << 24) + (t3.charCodeAt(r2 + 1) << 16) + (t3.charCodeAt(r2 + 2) << 8) + t3.charCodeAt(r2 + 3)) ? (o3 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (l4 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, n2.push(o3 + 33, s2 + 33, u2 + 33, c2 + 33, l4 + 33)) : n2.push(122);
        return (function(t4, e2) {
          for (var n3 = e2; n3 > 0; n3--) t4.pop();
        })(n2, e.length), String.fromCharCode.apply(String, n2) + "~>";
      }, r = function(t3) {
        var e, n2, r2, i3, a3, o3 = String, s2 = "length", u2 = 255, c2 = "charCodeAt", l4 = "slice", h2 = "replace";
        for (t3[l4](-2), t3 = t3[l4](0, -2)[h2](/\s/g, "")[h2]("z", "!!!!!"), r2 = [], i3 = 0, a3 = (t3 += e = "uuuuu"[l4](t3[s2] % 5 || 5))[s2]; a3 > i3; i3 += 5) n2 = 52200625 * (t3[c2](i3) - 33) + 614125 * (t3[c2](i3 + 1) - 33) + 7225 * (t3[c2](i3 + 2) - 33) + 85 * (t3[c2](i3 + 3) - 33) + (t3[c2](i3 + 4) - 33), r2.push(u2 & n2 >> 24, u2 & n2 >> 16, u2 & n2 >> 8, u2 & n2);
        return (function(t4, e2) {
          for (var n3 = e2; n3 > 0; n3--) t4.pop();
        })(r2, e[s2]), o3.fromCharCode.apply(o3, r2);
      }, i2 = function(t3) {
        return t3.split("").map(function(t4) {
          return ("0" + t4.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">";
      }, a2 = function(t3) {
        var e = new RegExp(/^([0-9A-Fa-f]{2})+$/);
        if (-1 !== (t3 = t3.replace(/\s/g, "")).indexOf(">") && (t3 = t3.substr(0, t3.indexOf(">"))), t3.length % 2 && (t3 += "0"), false === e.test(t3)) return "";
        for (var n2 = "", r2 = 0; r2 < t3.length; r2 += 2) n2 += String.fromCharCode("0x" + (t3[r2] + t3[r2 + 1]));
        return n2;
      }, o2 = function(t3) {
        for (var n2 = new Uint8Array(t3.length), r2 = t3.length; r2--; ) n2[r2] = t3.charCodeAt(r2);
        return (n2 = zlibSync(n2)).reduce(function(t4, e) {
          return t4 + String.fromCharCode(e);
        }, "");
      };
      t2.processDataByFilters = function(t3, e) {
        var s2 = 0, u2 = t3 || "", c2 = [];
        for ("string" == typeof (e = e || []) && (e = [e]), s2 = 0; s2 < e.length; s2 += 1) switch (e[s2]) {
          case "ASCII85Decode":
          case "/ASCII85Decode":
            u2 = r(u2), c2.push("/ASCII85Encode");
            break;
          case "ASCII85Encode":
          case "/ASCII85Encode":
            u2 = n(u2), c2.push("/ASCII85Decode");
            break;
          case "ASCIIHexDecode":
          case "/ASCIIHexDecode":
            u2 = a2(u2), c2.push("/ASCIIHexEncode");
            break;
          case "ASCIIHexEncode":
          case "/ASCIIHexEncode":
            u2 = i2(u2), c2.push("/ASCIIHexDecode");
            break;
          case "FlateEncode":
          case "/FlateEncode":
            u2 = o2(u2), c2.push("/FlateDecode");
            break;
          default:
            throw new Error('The filter: "' + e[s2] + '" is not implemented');
        }
        return { data: u2, reverseChain: c2.reverse().join(" ") };
      };
    })(E3.API), /**
     * @license
     * jsPDF fileloading PlugIn
     * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      t2.loadFile = function(t3, e, n) {
        return (function(t4, e2, n2) {
          e2 = false !== e2, n2 = "function" == typeof n2 ? n2 : function() {
          };
          var r = void 0;
          try {
            r = (function(t5, e3, n3) {
              var r2 = new XMLHttpRequest(), i2 = 0, a2 = function(t6) {
                var e4 = t6.length, n4 = [], r3 = String.fromCharCode;
                for (i2 = 0; i2 < e4; i2 += 1) n4.push(r3(255 & t6.charCodeAt(i2)));
                return n4.join("");
              };
              if (r2.open("GET", t5, !e3), r2.overrideMimeType("text/plain; charset=x-user-defined"), false === e3 && (r2.onload = function() {
                200 === r2.status ? n3(a2(this.responseText)) : n3(void 0);
              }), r2.send(null), e3 && 200 === r2.status) return a2(r2.responseText);
            })(t4, e2, n2);
          } catch (i2) {
          }
          return r;
        })(t3, e, n);
      }, t2.loadImageFile = t2.loadFile;
    })(E3.API), (function(e) {
      function n() {
        return (i.html2canvas ? Promise.resolve(i.html2canvas) : import("./chunk-A5U54ESH.js")).catch(function(t2) {
          return Promise.reject(new Error("Could not load html2canvas: " + t2));
        }).then(function(t2) {
          return t2.default ? t2.default : t2;
        });
      }
      function r() {
        return (i.DOMPurify ? Promise.resolve(i.DOMPurify) : import("./chunk-CE55FLLF.js")).catch(function(t2) {
          return Promise.reject(new Error("Could not load dompurify: " + t2));
        }).then(function(t2) {
          return t2.default ? t2.default : t2;
        });
      }
      var a2 = function(e2) {
        var n2 = _typeof(e2);
        return "undefined" === n2 ? "undefined" : "string" === n2 || e2 instanceof String ? "string" : "number" === n2 || e2 instanceof Number ? "number" : "function" === n2 || e2 instanceof Function ? "function" : e2 && e2.constructor === Array ? "array" : e2 && 1 === e2.nodeType ? "element" : "object" === n2 ? "object" : "unknown";
      }, o2 = function(t2, e2) {
        var n2 = document.createElement(t2);
        for (var r2 in e2.className && (n2.className = e2.className), e2.innerHTML && e2.dompurify && (n2.innerHTML = e2.dompurify.sanitize(e2.innerHTML)), e2.style) n2.style[r2] = e2.style[r2];
        return n2;
      }, s2 = function t2(e2, n2) {
        for (var r2 = 3 === e2.nodeType ? document.createTextNode(e2.nodeValue) : e2.cloneNode(false), i2 = e2.firstChild; i2; i2 = i2.nextSibling) true !== n2 && 1 === i2.nodeType && "SCRIPT" === i2.nodeName || r2.appendChild(t2(i2, n2));
        return 1 === e2.nodeType && ("CANVAS" === e2.nodeName ? (r2.width = e2.width, r2.height = e2.height, r2.getContext("2d").drawImage(e2, 0, 0)) : "TEXTAREA" !== e2.nodeName && "SELECT" !== e2.nodeName || (r2.value = e2.value), r2.addEventListener("load", function() {
          r2.scrollTop = e2.scrollTop, r2.scrollLeft = e2.scrollLeft;
        }, true)), r2;
      }, u2 = function t2(e2) {
        var n2 = Object.assign(t2.convert(Promise.resolve()), JSON.parse(JSON.stringify(t2.template))), r2 = t2.convert(Promise.resolve(), n2);
        return (r2 = r2.setProgress(1, t2, 1, [t2])).set(e2);
      };
      (u2.prototype = Object.create(Promise.prototype)).constructor = u2, u2.convert = function(t2, e2) {
        return t2.__proto__ = e2 || u2.prototype, t2;
      }, u2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
      } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, u2.prototype.from = function(t2, e2) {
        return this.then(function() {
          switch (e2 = e2 || (function(t3) {
            switch (a2(t3)) {
              case "string":
                return "string";
              case "element":
                return "canvas" === t3.nodeName.toLowerCase() ? "canvas" : "element";
              default:
                return "unknown";
            }
          })(t2), e2) {
            case "string":
              return this.then(r).then(function(e3) {
                return this.set({ src: o2("div", { innerHTML: t2, dompurify: e3 }) });
              });
            case "element":
              return this.set({ src: t2 });
            case "canvas":
              return this.set({ canvas: t2 });
            case "img":
              return this.set({ img: t2 });
            default:
              return this.error("Unknown source type.");
          }
        });
      }, u2.prototype.to = function(t2) {
        switch (t2) {
          case "container":
            return this.toContainer();
          case "canvas":
            return this.toCanvas();
          case "img":
            return this.toImg();
          case "pdf":
            return this.toPdf();
          default:
            return this.error("Invalid target.");
        }
      }, u2.prototype.toContainer = function() {
        return this.thenList([function() {
          return this.prop.src || this.error("Cannot duplicate - no source HTML.");
        }, function() {
          return this.prop.pageSize || this.setPageSize();
        }]).then(function() {
          var t2 = { position: "relative", display: "inline-block", width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e2 = s2(this.prop.src, this.opt.html2canvas.javascriptEnabled);
          "BODY" === e2.tagName && (t2.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2("div", { className: "html2pdf__container", style: t2 }), this.prop.container.appendChild(e2), this.prop.container.firstChild.appendChild(o2("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
        });
      }, u2.prototype.toCanvas = function() {
        var t2 = [function() {
          return document.body.contains(this.prop.container) || this.toContainer();
        }];
        return this.thenList(t2).then(n).then(function(t3) {
          var e2 = Object.assign({}, this.opt.html2canvas);
          return delete e2.onrendered, t3(this.prop.container, e2);
        }).then(function(t3) {
          (this.opt.html2canvas.onrendered || function() {
          })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
        });
      }, u2.prototype.toContext2d = function() {
        var t2 = [function() {
          return document.body.contains(this.prop.container) || this.toContainer();
        }];
        return this.thenList(t2).then(n).then(function(t3) {
          var e2 = this.opt.jsPDF, n2 = this.opt.fontFaces, r2 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i2 = Object.assign({ async: true, allowTaint: true, scale: r2, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
          if (delete i2.onrendered, e2.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e2.context2d.posX = this.opt.x, e2.context2d.posY = this.opt.y, e2.context2d.margin = this.opt.margin, e2.context2d.fontFaces = n2, n2) for (var a3 = 0; a3 < n2.length; ++a3) {
            var o3 = n2[a3], s3 = o3.src.find(function(t4) {
              return "truetype" === t4.format;
            });
            s3 && e2.addFont(s3.url, o3.ref.name, o3.ref.style);
          }
          return i2.windowHeight = i2.windowHeight || 0, i2.windowHeight = 0 == i2.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i2.windowHeight, e2.context2d.save(true), t3(this.prop.container, i2);
        }).then(function(t3) {
          this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
          })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
        });
      }, u2.prototype.toImg = function() {
        return this.thenList([function() {
          return this.prop.canvas || this.toCanvas();
        }]).then(function() {
          var t2 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
          this.prop.img = document.createElement("img"), this.prop.img.src = t2;
        });
      }, u2.prototype.toPdf = function() {
        return this.thenList([function() {
          return this.toContext2d();
        }]).then(function() {
          this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
        });
      }, u2.prototype.output = function(t2, e2, n2) {
        return "img" === (n2 = n2 || "pdf").toLowerCase() || "image" === n2.toLowerCase() ? this.outputImg(t2, e2) : this.outputPdf(t2, e2);
      }, u2.prototype.outputPdf = function(t2, e2) {
        return this.thenList([function() {
          return this.prop.pdf || this.toPdf();
        }]).then(function() {
          return this.prop.pdf.output(t2, e2);
        });
      }, u2.prototype.outputImg = function(t2) {
        return this.thenList([function() {
          return this.prop.img || this.toImg();
        }]).then(function() {
          switch (t2) {
            case void 0:
            case "img":
              return this.prop.img;
            case "datauristring":
            case "dataurlstring":
              return this.prop.img.src;
            case "datauri":
            case "dataurl":
              return document.location.href = this.prop.img.src;
            default:
              throw 'Image output type "' + t2 + '" is not supported.';
          }
        });
      }, u2.prototype.save = function(t2) {
        return this.thenList([function() {
          return this.prop.pdf || this.toPdf();
        }]).set(t2 ? { filename: t2 } : null).then(function() {
          this.prop.pdf.save(this.opt.filename);
        });
      }, u2.prototype.doCallback = function() {
        return this.thenList([function() {
          return this.prop.pdf || this.toPdf();
        }]).then(function() {
          this.prop.callback(this.prop.pdf);
        });
      }, u2.prototype.set = function(t2) {
        if ("object" !== a2(t2)) return this;
        var e2 = Object.keys(t2 || {}).map(function(e3) {
          if (e3 in u2.template.prop) return function() {
            this.prop[e3] = t2[e3];
          };
          switch (e3) {
            case "margin":
              return this.setMargin.bind(this, t2.margin);
            case "jsPDF":
              return function() {
                return this.opt.jsPDF = t2.jsPDF, this.setPageSize();
              };
            case "pageSize":
              return this.setPageSize.bind(this, t2.pageSize);
            default:
              return function() {
                this.opt[e3] = t2[e3];
              };
          }
        }, this);
        return this.then(function() {
          return this.thenList(e2);
        });
      }, u2.prototype.get = function(t2, e2) {
        return this.then(function() {
          var n2 = t2 in u2.template.prop ? this.prop[t2] : this.opt[t2];
          return e2 ? e2(n2) : n2;
        });
      }, u2.prototype.setMargin = function(t2) {
        return this.then(function() {
          switch (a2(t2)) {
            case "number":
              t2 = [t2, t2, t2, t2];
            case "array":
              if (2 === t2.length && (t2 = [t2[0], t2[1], t2[0], t2[1]]), 4 === t2.length) break;
            default:
              return this.error("Invalid margin array.");
          }
          this.opt.margin = t2;
        }).then(this.setPageSize);
      }, u2.prototype.setPageSize = function(t2) {
        function e2(t3, e3) {
          return Math.floor(t3 * e3 / 72 * 96);
        }
        return this.then(function() {
          (t2 = t2 || E3.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t2.inner = { width: t2.width - this.opt.margin[1] - this.opt.margin[3], height: t2.height - this.opt.margin[0] - this.opt.margin[2] }, t2.inner.px = { width: e2(t2.inner.width, t2.k), height: e2(t2.inner.height, t2.k) }, t2.inner.ratio = t2.inner.height / t2.inner.width), this.prop.pageSize = t2;
        });
      }, u2.prototype.setProgress = function(t2, e2, n2, r2) {
        return null != t2 && (this.progress.val = t2), null != e2 && (this.progress.state = e2), null != n2 && (this.progress.n = n2), null != r2 && (this.progress.stack = r2), this.progress.ratio = this.progress.val / this.progress.state, this;
      }, u2.prototype.updateProgress = function(t2, e2, n2, r2) {
        return this.setProgress(t2 ? this.progress.val + t2 : null, e2 || null, n2 ? this.progress.n + n2 : null, r2 ? this.progress.stack.concat(r2) : null);
      }, u2.prototype.then = function(t2, e2) {
        var n2 = this;
        return this.thenCore(t2, e2, function(t3, e3) {
          return n2.updateProgress(null, null, 1, [t3]), Promise.prototype.then.call(this, function(e4) {
            return n2.updateProgress(null, t3), e4;
          }).then(t3, e3).then(function(t4) {
            return n2.updateProgress(1), t4;
          });
        });
      }, u2.prototype.thenCore = function(t2, e2, n2) {
        n2 = n2 || Promise.prototype.then;
        var r2 = this;
        t2 && (t2 = t2.bind(r2)), e2 && (e2 = e2.bind(r2));
        var i2 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? r2 : u2.convert(Object.assign({}, r2), Promise.prototype), a3 = n2.call(i2, t2, e2);
        return u2.convert(a3, r2.__proto__);
      }, u2.prototype.thenExternal = function(t2, e2) {
        return Promise.prototype.then.call(this, t2, e2);
      }, u2.prototype.thenList = function(t2) {
        var e2 = this;
        return t2.forEach(function(t3) {
          e2 = e2.thenCore(t3);
        }), e2;
      }, u2.prototype.catch = function(t2) {
        t2 && (t2 = t2.bind(this));
        var e2 = Promise.prototype.catch.call(this, t2);
        return u2.convert(e2, this);
      }, u2.prototype.catchExternal = function(t2) {
        return Promise.prototype.catch.call(this, t2);
      }, u2.prototype.error = function(t2) {
        return this.then(function() {
          throw new Error(t2);
        });
      }, u2.prototype.using = u2.prototype.set, u2.prototype.saveAs = u2.prototype.save, u2.prototype.export = u2.prototype.output, u2.prototype.run = u2.prototype.then, E3.getPageSize = function(e2, n2, r2) {
        if ("object" === _typeof(e2)) {
          var i2 = e2;
          e2 = i2.orientation, n2 = i2.unit || n2, r2 = i2.format || r2;
        }
        n2 = n2 || "mm", r2 = r2 || "a4", e2 = ("" + (e2 || "P")).toLowerCase();
        var a3, o3 = ("" + r2).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
        switch (n2) {
          case "pt":
            a3 = 1;
            break;
          case "mm":
            a3 = 72 / 25.4;
            break;
          case "cm":
            a3 = 72 / 2.54;
            break;
          case "in":
            a3 = 72;
            break;
          case "px":
            a3 = 0.75;
            break;
          case "pc":
          case "em":
            a3 = 12;
            break;
          case "ex":
            a3 = 6;
            break;
          default:
            throw "Invalid unit: " + n2;
        }
        var u3, c2 = 0, l4 = 0;
        if (s3.hasOwnProperty(o3)) c2 = s3[o3][1] / a3, l4 = s3[o3][0] / a3;
        else try {
          c2 = r2[1], l4 = r2[0];
        } catch (h2) {
          throw new Error("Invalid format: " + r2);
        }
        if ("p" === e2 || "portrait" === e2) e2 = "p", l4 > c2 && (u3 = l4, l4 = c2, c2 = u3);
        else {
          if ("l" !== e2 && "landscape" !== e2) throw "Invalid orientation: " + e2;
          e2 = "l", c2 > l4 && (u3 = l4, l4 = c2, c2 = u3);
        }
        return { width: l4, height: c2, unit: n2, k: a3, orientation: e2 };
      }, e.html = function(t2, e2) {
        (e2 = e2 || {}).callback = e2.callback || function() {
        }, e2.html2canvas = e2.html2canvas || {}, e2.html2canvas.canvas = e2.html2canvas.canvas || this.canvas, e2.jsPDF = e2.jsPDF || this, e2.fontFaces = e2.fontFaces ? e2.fontFaces.map(Ct) : null;
        var n2 = new u2(e2);
        return e2.worker ? n2 : n2.from(t2).doCallback();
      };
    })(E3.API), E3.API.addJS = function(t2) {
      return Ut2 = t2, this.internal.events.subscribe("postPutResources", function() {
        Tt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Tt + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ut2 + ")"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        void 0 !== Tt && void 0 !== zt && this.internal.out("/Names <</JavaScript " + Tt + " 0 R>>");
      }), this;
    }, /**
     * @license
     * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e;
      t2.events.push(["postPutResources", function() {
        var t3 = this, n = /^(\d+) 0 obj$/;
        if (this.outline.root.children.length > 0) for (var r = t3.outline.render().split(/\r\n/), i2 = 0; i2 < r.length; i2++) {
          var a2 = r[i2], o2 = n.exec(a2);
          if (null != o2) {
            var s2 = o2[1];
            t3.internal.newObjectDeferredBegin(s2, false);
          }
          t3.internal.write(a2);
        }
        if (this.outline.createNamedDestinations) {
          var u2 = this.internal.pages.length, c2 = [];
          for (i2 = 0; i2 < u2; i2++) {
            var l4 = t3.internal.newObject();
            c2.push(l4);
            var h2 = t3.internal.getPageInfo(i2 + 1);
            t3.internal.write("<< /D[" + h2.objId + " 0 R /XYZ null null null]>> endobj");
          }
          var f2 = t3.internal.newObject();
          for (t3.internal.write("<< /Names [ "), i2 = 0; i2 < c2.length; i2++) t3.internal.write("(page_" + (i2 + 1) + ")" + c2[i2] + " 0 R");
          t3.internal.write(" ] >>", "endobj"), e = t3.internal.newObject(), t3.internal.write("<< /Dests " + f2 + " 0 R"), t3.internal.write(">>", "endobj");
        }
      }]), t2.events.push(["putCatalog", function() {
        var t3 = this;
        t3.outline.root.children.length > 0 && (t3.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && t3.internal.write("/Names " + e + " 0 R"));
      }]), t2.events.push(["initialized", function() {
        var t3 = this;
        t3.outline = { createNamedDestinations: false, root: { children: [] } }, t3.outline.add = function(t4, e2, n) {
          var r = { title: e2, options: n, children: [] };
          return null == t4 && (t4 = this.root), t4.children.push(r), r;
        }, t3.outline.render = function() {
          return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t3, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
        }, t3.outline.genIds_r = function(e2) {
          e2.id = t3.internal.newObjectDeferred();
          for (var n = 0; n < e2.children.length; n++) this.genIds_r(e2.children[n]);
        }, t3.outline.renderRoot = function(t4) {
          this.objStart(t4), this.line("/Type /Outlines"), t4.children.length > 0 && (this.line("/First " + this.makeRef(t4.children[0])), this.line("/Last " + this.makeRef(t4.children[t4.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t4)), this.objEnd();
        }, t3.outline.renderItems = function(e2) {
          for (var n = this.ctx.pdf.internal.getVerticalCoordinateString, r = 0; r < e2.children.length; r++) {
            var i2 = e2.children[r];
            this.objStart(i2), this.line("/Title " + this.makeString(i2.title)), this.line("/Parent " + this.makeRef(e2)), r > 0 && this.line("/Prev " + this.makeRef(e2.children[r - 1])), r < e2.children.length - 1 && this.line("/Next " + this.makeRef(e2.children[r + 1])), i2.children.length > 0 && (this.line("/First " + this.makeRef(i2.children[0])), this.line("/Last " + this.makeRef(i2.children[i2.children.length - 1])));
            var a2 = this.count = this.count_r({ count: 0 }, i2);
            if (a2 > 0 && this.line("/Count " + a2), i2.options && i2.options.pageNumber) {
              var o2 = t3.internal.getPageInfo(i2.options.pageNumber);
              this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + n(0) + " 0]");
            }
            this.objEnd();
          }
          for (var s2 = 0; s2 < e2.children.length; s2++) this.renderItems(e2.children[s2]);
        }, t3.outline.line = function(t4) {
          this.ctx.val += t4 + "\r\n";
        }, t3.outline.makeRef = function(t4) {
          return t4.id + " 0 R";
        }, t3.outline.makeString = function(e2) {
          return "(" + t3.internal.pdfEscape(e2) + ")";
        }, t3.outline.objStart = function(t4) {
          this.ctx.val += "\r\n" + t4.id + " 0 obj\r\n<<\r\n";
        }, t3.outline.objEnd = function() {
          this.ctx.val += ">> \r\nendobj\r\n";
        }, t3.outline.count_r = function(t4, e2) {
          for (var n = 0; n < e2.children.length; n++) t4.count++, this.count_r(t4, e2.children[n]);
          return t4.count;
        };
      }]);
    })(E3.API), /**
     * @license
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e = [192, 193, 194, 195, 196, 197, 198, 199];
      t2.processJPEG = function(t3, n, r, i2, a2, o2) {
        var s2, u2 = this.decode.DCT_DECODE, c2 = null;
        if ("string" == typeof t3 || this.__addimage__.isArrayBuffer(t3) || this.__addimage__.isArrayBufferView(t3)) {
          switch (t3 = a2 || t3, t3 = this.__addimage__.isArrayBuffer(t3) ? new Uint8Array(t3) : t3, s2 = (function(t4) {
            for (var n2, r2 = 256 * t4.charCodeAt(4) + t4.charCodeAt(5), i3 = t4.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i3; o3 += 2) {
              if (o3 += r2, -1 !== e.indexOf(t4.charCodeAt(o3 + 1))) {
                n2 = 256 * t4.charCodeAt(o3 + 5) + t4.charCodeAt(o3 + 6), a3 = { width: 256 * t4.charCodeAt(o3 + 7) + t4.charCodeAt(o3 + 8), height: n2, numcomponents: t4.charCodeAt(o3 + 9) };
                break;
              }
              r2 = 256 * t4.charCodeAt(o3 + 2) + t4.charCodeAt(o3 + 3);
            }
            return a3;
          })(t3 = this.__addimage__.isArrayBufferView(t3) ? this.__addimage__.arrayBufferToBinaryString(t3) : t3), s2.numcomponents) {
            case 1:
              o2 = this.color_spaces.DEVICE_GRAY;
              break;
            case 4:
              o2 = this.color_spaces.DEVICE_CMYK;
              break;
            case 3:
              o2 = this.color_spaces.DEVICE_RGB;
          }
          c2 = { data: t3, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: u2, index: n, alias: r };
        }
        return c2;
      };
    })(E3.API), E3.API.processPNG = function(t2, i2, a2, o2) {
      if (this.__addimage__.isArrayBuffer(t2) && (t2 = new Uint8Array(t2)), this.__addimage__.isArrayBufferView(t2)) {
        var s2, u2 = decodePng(t2, { checkCrc: true }), c2 = u2.width, l4 = u2.height, h2 = u2.channels, f2 = u2.palette, d3 = u2.depth;
        s2 = f2 && 1 === h2 ? (function(t3) {
          for (var e = t3.width, r = t3.height, i3 = t3.data, a3 = t3.palette, o3 = t3.depth, s3 = false, u3 = [], c3 = [], l5 = void 0, h3 = false, f3 = 0, d4 = 0; d4 < a3.length; d4++) {
            var p3 = _slicedToArray(a3[d4], 4), g3 = p3[0], m4 = p3[1], v4 = p3[2], b4 = p3[3];
            u3.push(g3, m4, v4), null != b4 && (0 === b4 ? (f3++, c3.length < 1 && c3.push(d4)) : b4 < 255 && (h3 = true));
          }
          if (h3 || f3 > 1) {
            s3 = true, c3 = void 0;
            var y4 = e * r;
            l5 = new Uint8Array(y4);
            for (var w4 = new DataView(i3.buffer), N5 = 0; N5 < y4; N5++) {
              var L5 = re2(w4, N5, o3), x4 = _slicedToArray(a3[L5], 4)[3];
              l5[N5] = x4;
            }
          } else 0 === f3 && (c3 = void 0);
          return { colorSpace: "Indexed", colorsPerPixel: 1, sMaskBitsPerComponent: s3 ? 8 : void 0, colorBytes: i3, alphaBytes: l5, needSMask: s3, palette: u3, mask: c3 };
        })(u2) : 2 === h2 || 4 === h2 ? (function(t3) {
          for (var e = t3.data, n = t3.width, r = t3.height, i3 = t3.channels, a3 = t3.depth, o3 = 2 === i3 ? "DeviceGray" : "DeviceRGB", s3 = i3 - 1, u3 = n * r, c3 = s3, l5 = u3 * c3, h3 = 1 * u3, f3 = Math.ceil(l5 * a3 / 8), d4 = Math.ceil(h3 * a3 / 8), p3 = new Uint8Array(f3), g3 = new Uint8Array(d4), m4 = new DataView(e.buffer), v4 = new DataView(p3.buffer), b4 = new DataView(g3.buffer), y4 = false, w4 = 0; w4 < u3; w4++) {
            for (var N5 = w4 * i3, L5 = 0; L5 < c3; L5++) ie2(v4, re2(m4, N5 + L5, a3), w4 * c3 + L5, a3);
            var x4 = re2(m4, N5 + c3, a3);
            x4 < (1 << a3) - 1 && (y4 = true), ie2(b4, x4, 1 * w4, a3);
          }
          return { colorSpace: o3, colorsPerPixel: s3, sMaskBitsPerComponent: y4 ? a3 : void 0, colorBytes: p3, alphaBytes: g3, needSMask: y4 };
        })(u2) : (function(t3) {
          var e = t3.data, n = 1 === t3.channels ? "DeviceGray" : "DeviceRGB";
          return { colorSpace: n, colorsPerPixel: "DeviceGray" === n ? 1 : 3, colorBytes: e instanceof Uint16Array ? (function(t4) {
            for (var e2 = t4.length, n2 = new Uint8Array(2 * e2), r = new DataView(n2.buffer, n2.byteOffset, n2.byteLength), i3 = 0; i3 < e2; i3++) r.setUint16(2 * i3, t4[i3], false);
            return n2;
          })(e) : e, needSMask: false };
        })(u2);
        var p2, g2, m3, v3 = s2, b3 = v3.colorSpace, y3 = v3.colorsPerPixel, w3 = v3.sMaskBitsPerComponent, N4 = v3.colorBytes, L4 = v3.alphaBytes, x3 = v3.needSMask, A3 = v3.palette, S4 = v3.mask, _3 = null;
        return o2 !== E3.API.image_compression.NONE && "function" == typeof zlibSync ? (_3 = (function(t3) {
          var e;
          switch (t3) {
            case E3.API.image_compression.FAST:
              e = 11;
              break;
            case E3.API.image_compression.MEDIUM:
              e = 13;
              break;
            case E3.API.image_compression.SLOW:
              e = 14;
              break;
            default:
              e = 12;
          }
          return e;
        })(o2), p2 = this.decode.FLATE_DECODE, g2 = "/Predictor ".concat(_3, " /Colors ").concat(y3, " /BitsPerComponent ").concat(d3, " /Columns ").concat(c2), t2 = Xt(N4, Math.ceil(c2 * y3 * d3 / 8), y3, d3, o2), x3 && (m3 = Xt(L4, Math.ceil(c2 * w3 / 8), 1, w3, o2))) : (p2 = void 0, g2 = void 0, t2 = N4, x3 && (m3 = L4)), (this.__addimage__.isArrayBuffer(t2) || this.__addimage__.isArrayBufferView(t2)) && (t2 = this.__addimage__.arrayBufferToBinaryString(t2)), (m3 && this.__addimage__.isArrayBuffer(m3) || this.__addimage__.isArrayBufferView(m3)) && (m3 = this.__addimage__.arrayBufferToBinaryString(m3)), { alias: a2, data: t2, index: i2, filter: p2, decodeParameters: g2, transparency: S4, palette: A3, sMask: m3, predictor: _3, width: c2, height: l4, bitsPerComponent: d3, sMaskBitsPerComponent: w3, colorSpace: b3 };
      }
    }, (function(t2) {
      t2.processGIF89A = function(e, n, r, i2) {
        var a2 = new oe2(e), o2 = a2.width, s2 = a2.height, u2 = [];
        a2.decodeAndBlitFrameRGBA(0, u2);
        var c2 = { data: u2, width: o2, height: s2 }, l4 = new ue2(100).encode(c2, 100);
        return t2.processJPEG.call(this, l4, n, r, i2);
      }, t2.processGIF87A = t2.processGIF89A;
    })(E3.API), ce2.prototype.parseHeader = function() {
      if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
        var t2 = 0 === this.colors ? 1 << this.bitPP : this.colors;
        this.palette = new Array(t2);
        for (var e = 0; e < t2; e++) {
          var n = this.datav.getUint8(this.pos++, true), r = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
          this.palette[e] = { red: i2, green: r, blue: n, quad: a2 };
        }
      }
      this.height < 0 && (this.height *= -1, this.bottom_up = false);
    }, ce2.prototype.parseBGR = function() {
      this.pos = this.offset;
      try {
        var t2 = "bit" + this.bitPP, e = this.width * this.height * 4;
        this.data = new Uint8Array(e), this[t2]();
      } catch (n) {
        o.log("bit decode error:" + n);
      }
    }, ce2.prototype.bit1 = function() {
      var t2, e = Math.ceil(this.width / 8), n = e % 4;
      for (t2 = this.height - 1; t2 >= 0; t2--) {
        for (var r = this.bottom_up ? t2 : this.height - 1 - t2, i2 = 0; i2 < e; i2++) for (var a2 = this.datav.getUint8(this.pos++, true), o2 = r * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {
          var u2 = this.palette[a2 >> 7 - s2 & 1];
          this.data[o2 + 4 * s2] = u2.blue, this.data[o2 + 4 * s2 + 1] = u2.green, this.data[o2 + 4 * s2 + 2] = u2.red, this.data[o2 + 4 * s2 + 3] = 255;
        }
        0 !== n && (this.pos += 4 - n);
      }
    }, ce2.prototype.bit4 = function() {
      for (var t2 = Math.ceil(this.width / 2), e = t2 % 4, n = this.height - 1; n >= 0; n--) {
        for (var r = this.bottom_up ? n : this.height - 1 - n, i2 = 0; i2 < t2; i2++) {
          var a2 = this.datav.getUint8(this.pos++, true), o2 = r * this.width * 4 + 2 * i2 * 4, s2 = a2 >> 4, u2 = 15 & a2, c2 = this.palette[s2];
          if (this.data[o2] = c2.blue, this.data[o2 + 1] = c2.green, this.data[o2 + 2] = c2.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width) break;
          c2 = this.palette[u2], this.data[o2 + 4] = c2.blue, this.data[o2 + 4 + 1] = c2.green, this.data[o2 + 4 + 2] = c2.red, this.data[o2 + 4 + 3] = 255;
        }
        0 !== e && (this.pos += 4 - e);
      }
    }, ce2.prototype.bit8 = function() {
      for (var t2 = this.width % 4, e = this.height - 1; e >= 0; e--) {
        for (var n = this.bottom_up ? e : this.height - 1 - e, r = 0; r < this.width; r++) {
          var i2 = this.datav.getUint8(this.pos++, true), a2 = n * this.width * 4 + 4 * r;
          if (i2 < this.palette.length) {
            var o2 = this.palette[i2];
            this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
          } else this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
        }
        0 !== t2 && (this.pos += 4 - t2);
      }
    }, ce2.prototype.bit15 = function() {
      for (var t2 = this.width % 3, e = parseInt("11111", 2), n = this.height - 1; n >= 0; n--) {
        for (var r = this.bottom_up ? n : this.height - 1 - n, i2 = 0; i2 < this.width; i2++) {
          var a2 = this.datav.getUint16(this.pos, true);
          this.pos += 2;
          var o2 = (a2 & e) / e * 255 | 0, s2 = (a2 >> 5 & e) / e * 255 | 0, u2 = (a2 >> 10 & e) / e * 255 | 0, c2 = a2 >> 15 ? 255 : 0, l4 = r * this.width * 4 + 4 * i2;
          this.data[l4] = u2, this.data[l4 + 1] = s2, this.data[l4 + 2] = o2, this.data[l4 + 3] = c2;
        }
        this.pos += t2;
      }
    }, ce2.prototype.bit16 = function() {
      for (var t2 = this.width % 3, e = parseInt("11111", 2), n = parseInt("111111", 2), r = this.height - 1; r >= 0; r--) {
        for (var i2 = this.bottom_up ? r : this.height - 1 - r, a2 = 0; a2 < this.width; a2++) {
          var o2 = this.datav.getUint16(this.pos, true);
          this.pos += 2;
          var s2 = (o2 & e) / e * 255 | 0, u2 = (o2 >> 5 & n) / n * 255 | 0, c2 = (o2 >> 11) / e * 255 | 0, l4 = i2 * this.width * 4 + 4 * a2;
          this.data[l4] = c2, this.data[l4 + 1] = u2, this.data[l4 + 2] = s2, this.data[l4 + 3] = 255;
        }
        this.pos += t2;
      }
    }, ce2.prototype.bit24 = function() {
      for (var t2 = this.height - 1; t2 >= 0; t2--) {
        for (var e = this.bottom_up ? t2 : this.height - 1 - t2, n = 0; n < this.width; n++) {
          var r = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e * this.width * 4 + 4 * n;
          this.data[o2] = a2, this.data[o2 + 1] = i2, this.data[o2 + 2] = r, this.data[o2 + 3] = 255;
        }
        this.pos += this.width % 4;
      }
    }, ce2.prototype.bit32 = function() {
      for (var t2 = this.height - 1; t2 >= 0; t2--) for (var e = this.bottom_up ? t2 : this.height - 1 - t2, n = 0; n < this.width; n++) {
        var r = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e * this.width * 4 + 4 * n;
        this.data[s2] = a2, this.data[s2 + 1] = i2, this.data[s2 + 2] = r, this.data[s2 + 3] = o2;
      }
    }, ce2.prototype.getData = function() {
      return this.data;
    }, /**
     * @license
     * Copyright (c) 2018 Aras Abbasi
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      t2.processBMP = function(e, n, r, i2) {
        var a2 = new ce2(e, false), o2 = a2.width, s2 = a2.height, u2 = { data: a2.getData(), width: o2, height: s2 }, c2 = new ue2(100).encode(u2, 100);
        return t2.processJPEG.call(this, c2, n, r, i2);
      };
    })(E3.API), le2.prototype.getData = function() {
      return this.data;
    }, /**
     * @license
     * Copyright (c) 2019 Aras Abbasi
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      t2.processWEBP = function(e, n, r, i2) {
        var a2 = new le2(e), o2 = a2.width, s2 = a2.height, u2 = { data: a2.getData(), width: o2, height: s2 }, c2 = new ue2(100).encode(u2, 100);
        return t2.processJPEG.call(this, c2, n, r, i2);
      };
    })(E3.API), E3.API.processRGBA = function(t2, e, n) {
      for (var r = t2.data, i2 = r.length, a2 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, u2 = 0, c2 = 0; c2 < i2; c2 += 4) {
        var l4 = r[c2], h2 = r[c2 + 1], f2 = r[c2 + 2], d3 = r[c2 + 3];
        a2[s2++] = l4, a2[s2++] = h2, a2[s2++] = f2, o2[u2++] = d3;
      }
      var p2 = this.__addimage__.arrayBufferToBinaryString(a2);
      return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p2, index: e, alias: n, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t2.width, height: t2.height };
    }, E3.API.setLanguage = function(t2) {
      return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t2] && (this.internal.languageSettings.languageCode = t2, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
        this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
      }), this.internal.languageSettings.isSubscribed = true)), this;
    }, Ht2 = E3.API, Wt = Ht2.getCharWidthsArray = function(e, n) {
      var r, i2, a2 = (n = n || {}).font || this.internal.getFont(), o2 = n.fontSize || this.internal.getFontSize(), s2 = n.charSpace || this.internal.getCharSpace(), u2 = n.widths ? n.widths : a2.metadata.Unicode.widths, c2 = u2.fof ? u2.fof : 1, l4 = n.kerning ? n.kerning : a2.metadata.Unicode.kerning, h2 = l4.fof ? l4.fof : 1, f2 = false !== n.doKerning, d3 = 0, p2 = e.length, g2 = 0, m3 = u2[0] || c2, v3 = [];
      for (r = 0; r < p2; r++) i2 = e.charCodeAt(r), "function" == typeof a2.metadata.widthOfString ? v3.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i2)) + s2 * (1e3 / o2) || 0) / 1e3) : (d3 = f2 && "object" === _typeof(l4[i2]) && !isNaN(parseInt(l4[i2][g2], 10)) ? l4[i2][g2] / h2 : 0, v3.push((u2[i2] || m3) / c2 + d3)), g2 = i2;
      return v3;
    }, Vt = Ht2.getStringUnitWidth = function(t2, e) {
      var n = (e = e || {}).fontSize || this.internal.getFontSize(), r = e.font || this.internal.getFont(), i2 = e.charSpace || this.internal.getCharSpace();
      return Ht2.processArabic && (t2 = Ht2.processArabic(t2)), "function" == typeof r.metadata.widthOfString ? r.metadata.widthOfString(t2, n, i2) / n : Wt.apply(this, arguments).reduce(function(t3, e2) {
        return t3 + e2;
      }, 0);
    }, Gt2 = function(t2, e, n, r) {
      for (var i2 = [], a2 = 0, o2 = t2.length, s2 = 0; a2 !== o2 && s2 + e[a2] < n; ) s2 += e[a2], a2++;
      i2.push(t2.slice(0, a2));
      var u2 = a2;
      for (s2 = 0; a2 !== o2; ) s2 + e[a2] > r && (i2.push(t2.slice(u2, a2)), s2 = 0, u2 = a2), s2 += e[a2], a2++;
      return u2 !== a2 && i2.push(t2.slice(u2, a2)), i2;
    }, Yt = function(t2, e, n) {
      n || (n = {});
      var r, i2, a2, o2, s2, u2, c2, l4 = [], h2 = [l4], f2 = n.textIndent || 0, d3 = 0, p2 = 0, g2 = t2.split(" "), m3 = Wt.apply(this, [" ", n])[0];
      if (u2 = -1 === n.lineIndent ? g2[0].length + 2 : n.lineIndent || 0) {
        var v3 = Array(u2).join(" "), b3 = [];
        g2.map(function(t3) {
          (t3 = t3.split(/\s*\n/)).length > 1 ? b3 = b3.concat(t3.map(function(t4, e2) {
            return (e2 && t4.length ? "\n" : "") + t4;
          })) : b3.push(t3[0]);
        }), g2 = b3, u2 = Vt.apply(this, [v3, n]);
      }
      for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
        var y3 = 0;
        if (r = g2[a2], u2 && "\n" == r[0] && (r = r.substr(1), y3 = 1), f2 + d3 + (p2 = (i2 = Wt.apply(this, [r, n])).reduce(function(t3, e2) {
          return t3 + e2;
        }, 0)) > e || y3) {
          if (p2 > e) {
            for (s2 = Gt2.apply(this, [r, i2, e - (f2 + d3), e]), l4.push(s2.shift()), l4 = [s2.pop()]; s2.length; ) h2.push([s2.shift()]);
            p2 = i2.slice(r.length - (l4[0] ? l4[0].length : 0)).reduce(function(t3, e2) {
              return t3 + e2;
            }, 0);
          } else l4 = [r];
          h2.push(l4), f2 = p2 + u2, d3 = m3;
        } else l4.push(r), f2 += d3 + p2, d3 = m3;
      }
      return c2 = u2 ? function(t3, e2) {
        return (e2 ? v3 : "") + t3.join(" ");
      } : function(t3) {
        return t3.join(" ");
      }, h2.map(c2);
    }, Ht2.splitTextToSize = function(t2, e, n) {
      var r, i2 = (n = n || {}).fontSize || this.internal.getFontSize(), a2 = (function(t3) {
        if (t3.widths && t3.kerning) return { widths: t3.widths, kerning: t3.kerning };
        var e2 = this.internal.getFont(t3.fontName, t3.fontStyle), n2 = "Unicode";
        return e2.metadata[n2] ? { widths: e2.metadata[n2].widths || { 0: 1 }, kerning: e2.metadata[n2].kerning || {} } : { font: e2.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
      }).call(this, n);
      r = Array.isArray(t2) ? t2 : String(t2).split(/\r?\n/);
      var o2 = 1 * this.internal.scaleFactor * e / i2;
      a2.textIndent = n.textIndent ? 1 * n.textIndent * this.internal.scaleFactor / i2 : 0, a2.lineIndent = n.lineIndent;
      var s2, u2, c2 = [];
      for (s2 = 0, u2 = r.length; s2 < u2; s2++) c2 = c2.concat(Yt.apply(this, [r[s2], o2, a2]));
      return c2;
    }, (function(e) {
      e.__fontmetrics__ = e.__fontmetrics__ || {};
      for (var n = "0123456789abcdef", r = "klmnopqrstuvwxyz", i2 = {}, a2 = {}, o2 = 0; o2 < 16; o2++) i2[r[o2]] = n[o2], a2[n[o2]] = r[o2];
      var s2 = function(t2) {
        return "0x" + parseInt(t2, 10).toString(16);
      }, u2 = e.__fontmetrics__.compress = function(e2) {
        var n2, r2, i3, o3, c3 = ["{"];
        for (var l5 in e2) {
          if (n2 = e2[l5], isNaN(parseInt(l5, 10)) ? r2 = "'" + l5 + "'" : (l5 = parseInt(l5, 10), r2 = (r2 = s2(l5).slice(2)).slice(0, -1) + a2[r2.slice(-1)]), "number" == typeof n2) n2 < 0 ? (i3 = s2(n2).slice(3), o3 = "-") : (i3 = s2(n2).slice(2), o3 = ""), i3 = o3 + i3.slice(0, -1) + a2[i3.slice(-1)];
          else {
            if ("object" !== _typeof(n2)) throw new Error("Don't know what to do with value type " + _typeof(n2) + ".");
            i3 = u2(n2);
          }
          c3.push(r2 + i3);
        }
        return c3.push("}"), c3.join("");
      }, c2 = e.__fontmetrics__.uncompress = function(t2) {
        if ("string" != typeof t2) throw new Error("Invalid argument passed to uncompress.");
        for (var e2, n2, r2, a3, o3 = {}, s3 = 1, u3 = o3, c3 = [], l5 = "", h3 = "", f3 = t2.length - 1, d3 = 1; d3 < f3; d3 += 1) "'" == (a3 = t2[d3]) ? e2 ? (r2 = e2.join(""), e2 = void 0) : e2 = [] : e2 ? e2.push(a3) : "{" == a3 ? (c3.push([u3, r2]), u3 = {}, r2 = void 0) : "}" == a3 ? ((n2 = c3.pop())[0][n2[1]] = u3, r2 = void 0, u3 = n2[0]) : "-" == a3 ? s3 = -1 : void 0 === r2 ? i2.hasOwnProperty(a3) ? (l5 += i2[a3], r2 = parseInt(l5, 16) * s3, s3 = 1, l5 = "") : l5 += a3 : i2.hasOwnProperty(a3) ? (h3 += i2[a3], u3[r2] = parseInt(h3, 16) * s3, s3 = 1, r2 = void 0, h3 = "") : h3 += a3;
        return o3;
      }, l4 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h2 = { Unicode: { Courier: l4, "Courier-Bold": l4, "Courier-BoldOblique": l4, "Courier-Oblique": l4, Helvetica: l4, "Helvetica-Bold": l4, "Helvetica-BoldOblique": l4, "Helvetica-Oblique": l4, "Times-Roman": l4, "Times-Bold": l4, "Times-BoldItalic": l4, "Times-Italic": l4 } }, f2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
      e.events.push(["addFont", function(t2) {
        var e2 = t2.font, n2 = f2.Unicode[e2.postScriptName];
        n2 && (e2.metadata.Unicode = {}, e2.metadata.Unicode.widths = n2.widths, e2.metadata.Unicode.kerning = n2.kerning);
        var r2 = h2.Unicode[e2.postScriptName];
        r2 && (e2.metadata.Unicode.encoding = r2, e2.encoding = r2.codePages[0]);
      }]);
    })(E3.API), /**
     * @license
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e = function(t3) {
        for (var e2 = t3.length, n = new Uint8Array(e2), r = 0; r < e2; r++) n[r] = t3.charCodeAt(r);
        return n;
      };
      t2.API.events.push(["addFont", function(n) {
        var r = void 0, i2 = n.font, a2 = n.instance;
        if (!i2.isStandardFont) {
          if (void 0 === a2) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
          if ("string" != typeof (r = false === a2.existsFileInVFS(i2.postScriptName) ? a2.loadFile(i2.postScriptName) : a2.getFileFromVFS(i2.postScriptName))) throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
          !(function(n2, r2) {
            r2 = /^\x00\x01\x00\x00/.test(r2) ? e(r2) : e(f(r2)), n2.metadata = t2.API.TTFFont.open(r2), n2.metadata.Unicode = n2.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, n2.metadata.glyIdsUsed = [0];
          })(i2, r);
        }
      }]);
    })(E3), E3.API.addSvgAsImage = function(t2, e, n, r, a2, s2, u2, c2) {
      if (isNaN(e) || isNaN(n)) throw o.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
      if (isNaN(r) || isNaN(a2)) throw o.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
      var l4 = document.createElement("canvas");
      l4.width = r, l4.height = a2;
      var h2 = l4.getContext("2d");
      h2.fillStyle = "#fff", h2.fillRect(0, 0, l4.width, l4.height);
      var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d3 = this;
      return (i.canvg ? Promise.resolve(i.canvg) : import("./chunk-DGDZN5PM.js")).catch(function(t3) {
        return Promise.reject(new Error("Could not load canvg: " + t3));
      }).then(function(t3) {
        return t3.default ? t3.default : t3;
      }).then(function(e2) {
        return e2.fromString(h2, t2, f2);
      }, function() {
        return Promise.reject(new Error("Could not load canvg."));
      }).then(function(t3) {
        return t3.render(f2);
      }).then(function() {
        d3.addImage(l4.toDataURL("image/jpeg", 1), e, n, r, a2, u2, c2);
      });
    }, E3.API.putTotalPages = function(t2) {
      var e, n = 0;
      parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(t2, "g"), n = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(t2, this.internal.getFont()), "g"), n = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
      for (var r = 1; r <= this.internal.getNumberOfPages(); r++) for (var i2 = 0; i2 < this.internal.pages[r].length; i2++) this.internal.pages[r][i2] = this.internal.pages[r][i2].replace(e, n);
      return this;
    }, E3.API.viewerPreferences = function(e, n) {
      var r;
      e = e || {}, n = n || false;
      var i2, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, u2 = Object.keys(s2), c2 = [], l4 = 0, h2 = 0, f2 = 0;
      function d3(t2, e2) {
        var n2, r2 = false;
        for (n2 = 0; n2 < t2.length; n2 += 1) t2[n2] === e2 && (r2 = true);
        return r2;
      }
      if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), r = this.internal.viewerpreferences.configuration, "reset" === e || true === n) {
        var p2 = u2.length;
        for (f2 = 0; f2 < p2; f2 += 1) r[u2[f2]].value = r[u2[f2]].defaultValue, r[u2[f2]].explicitSet = false;
      }
      if ("object" === _typeof(e)) {
        for (a2 in e) if (o2 = e[a2], d3(u2, a2) && void 0 !== o2) {
          if ("boolean" === r[a2].type && "boolean" == typeof o2) r[a2].value = o2;
          else if ("name" === r[a2].type && d3(r[a2].valueSet, o2)) r[a2].value = o2;
          else if ("integer" === r[a2].type && Number.isInteger(o2)) r[a2].value = o2;
          else if ("array" === r[a2].type) {
            for (l4 = 0; l4 < o2.length; l4 += 1) if (i2 = true, 1 === o2[l4].length && "number" == typeof o2[l4][0]) c2.push(String(o2[l4] - 1));
            else if (o2[l4].length > 1) {
              for (h2 = 0; h2 < o2[l4].length; h2 += 1) "number" != typeof o2[l4][h2] && (i2 = false);
              true === i2 && c2.push([o2[l4][0] - 1, o2[l4][1] - 1].join(" "));
            }
            r[a2].value = "[" + c2.join(" ") + "]";
          } else r[a2].value = r[a2].defaultValue;
          r[a2].explicitSet = true;
        }
      }
      return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
        var t2, e2 = [];
        for (t2 in r) true === r[t2].explicitSet && ("name" === r[t2].type ? e2.push("/" + t2 + " /" + r[t2].value) : e2.push("/" + t2 + " " + r[t2].value));
        0 !== e2.length && this.internal.write("/ViewerPreferences\n<<\n" + e2.join("\n") + "\n>>");
      }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = r, this;
    }, /** ====================================================================
     * @license
     * jsPDF XMP metadata plugin
     * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
     *
     * Permission is hereby granted, free of charge, to any person obtaining
     * a copy of this software and associated documentation files (the
     * "Software"), to deal in the Software without restriction, including
     * without limitation the rights to use, copy, modify, merge, publish,
     * distribute, sublicense, and/or sell copies of the Software, and to
     * permit persons to whom the Software is furnished to do so, subject to
     * the following conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
     * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
     * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     * ====================================================================
     */
    (function(t2) {
      var e = function() {
        var t3 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e2 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), n2 = unescape(encodeURIComponent(t3)), r = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i2 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = n2.length + r.length + i2.length + e2.length + a2.length;
        this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e2 + n2 + r + i2 + a2), this.internal.write("endstream"), this.internal.write("endobj");
      }, n = function() {
        this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
      };
      t2.addMetadata = function(t3, r) {
        return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = { metadata: t3, namespaceuri: r || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", n), this.internal.events.subscribe("postPutResources", e)), this;
      };
    })(E3.API), (function(t2) {
      var e = t2.API, n = e.pdfEscape16 = function(t3, e2) {
        for (var n2, r2 = e2.metadata.Unicode.widths, i3 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t3.length; o2 < s2; ++o2) {
          if (n2 = e2.metadata.characterToGlyph(t3.charCodeAt(o2)), e2.metadata.glyIdsUsed.push(n2), e2.metadata.toUnicode[n2] = t3.charCodeAt(o2), -1 == r2.indexOf(n2) && (r2.push(n2), r2.push([parseInt(e2.metadata.widthOfGlyph(n2), 10)])), "0" == n2) return a2.join("");
          n2 = n2.toString(16), a2.push(i3[4 - n2.length], n2);
        }
        return a2.join("");
      }, r = function(t3) {
        var e2, n2, r2, i3, a2, o2, s2;
        for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", r2 = [], o2 = 0, s2 = (n2 = Object.keys(t3).sort(function(t4, e3) {
          return t4 - e3;
        })).length; o2 < s2; o2++) e2 = n2[o2], r2.length >= 100 && (a2 += "\n" + r2.length + " beginbfchar\n" + r2.join("\n") + "\nendbfchar", r2 = []), void 0 !== t3[e2] && null !== t3[e2] && "function" == typeof t3[e2].toString && (i3 = ("0000" + t3[e2].toString(16)).slice(-4), e2 = ("0000" + (+e2).toString(16)).slice(-4), r2.push("<" + e2 + "><" + i3 + ">"));
        return r2.length && (a2 += "\n" + r2.length + " beginbfchar\n" + r2.join("\n") + "\nendbfchar\n"), a2 + "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
      };
      e.events.push(["putFont", function(e2) {
        !(function(e3) {
          var n2 = e3.font, i3 = e3.out, a2 = e3.newObject, o2 = e3.putStream;
          if (n2.metadata instanceof t2.API.TTFFont && "Identity-H" === n2.encoding) {
            for (var s2 = n2.metadata.Unicode.widths, u2 = n2.metadata.subset.encode(n2.metadata.glyIdsUsed, 1), c2 = "", l4 = 0; l4 < u2.length; l4++) c2 += String.fromCharCode(u2[l4]);
            var h2 = a2();
            o2({ data: c2, addLength1: true, objectId: h2 }), i3("endobj");
            var f2 = a2();
            o2({ data: r(n2.metadata.toUnicode), addLength1: true, objectId: f2 }), i3("endobj");
            var d3 = a2();
            i3("<<"), i3("/Type /FontDescriptor"), i3("/FontName /" + j2(n2.fontName)), i3("/FontFile2 " + h2 + " 0 R"), i3("/FontBBox " + t2.API.PDFObject.convert(n2.metadata.bbox)), i3("/Flags " + n2.metadata.flags), i3("/StemV " + n2.metadata.stemV), i3("/ItalicAngle " + n2.metadata.italicAngle), i3("/Ascent " + n2.metadata.ascender), i3("/Descent " + n2.metadata.decender), i3("/CapHeight " + n2.metadata.capHeight), i3(">>"), i3("endobj");
            var p2 = a2();
            i3("<<"), i3("/Type /Font"), i3("/BaseFont /" + j2(n2.fontName)), i3("/FontDescriptor " + d3 + " 0 R"), i3("/W " + t2.API.PDFObject.convert(s2)), i3("/CIDToGIDMap /Identity"), i3("/DW 1000"), i3("/Subtype /CIDFontType2"), i3("/CIDSystemInfo"), i3("<<"), i3("/Supplement 0"), i3("/Registry (Adobe)"), i3("/Ordering (" + n2.encoding + ")"), i3(">>"), i3(">>"), i3("endobj"), n2.objectNumber = a2(), i3("<<"), i3("/Type /Font"), i3("/Subtype /Type0"), i3("/ToUnicode " + f2 + " 0 R"), i3("/BaseFont /" + j2(n2.fontName)), i3("/Encoding /" + n2.encoding), i3("/DescendantFonts [" + p2 + " 0 R]"), i3(">>"), i3("endobj"), n2.isAlreadyPutted = true;
          }
        })(e2);
      }]), e.events.push(["putFont", function(e2) {
        !(function(e3) {
          var n2 = e3.font, i3 = e3.out, a2 = e3.newObject, o2 = e3.putStream;
          if (n2.metadata instanceof t2.API.TTFFont && "WinAnsiEncoding" === n2.encoding) {
            for (var s2 = n2.metadata.rawData, u2 = "", c2 = 0; c2 < s2.length; c2++) u2 += String.fromCharCode(s2[c2]);
            var l4 = a2();
            o2({ data: u2, addLength1: true, objectId: l4 }), i3("endobj");
            var h2 = a2();
            o2({ data: r(n2.metadata.toUnicode), addLength1: true, objectId: h2 }), i3("endobj");
            var f2 = a2();
            i3("<<"), i3("/Descent " + n2.metadata.decender), i3("/CapHeight " + n2.metadata.capHeight), i3("/StemV " + n2.metadata.stemV), i3("/Type /FontDescriptor"), i3("/FontFile2 " + l4 + " 0 R"), i3("/Flags 96"), i3("/FontBBox " + t2.API.PDFObject.convert(n2.metadata.bbox)), i3("/FontName /" + j2(n2.fontName)), i3("/ItalicAngle " + n2.metadata.italicAngle), i3("/Ascent " + n2.metadata.ascender), i3(">>"), i3("endobj"), n2.objectNumber = a2();
            for (var d3 = 0; d3 < n2.metadata.hmtx.widths.length; d3++) n2.metadata.hmtx.widths[d3] = parseInt(n2.metadata.hmtx.widths[d3] * (1e3 / n2.metadata.head.unitsPerEm));
            i3("<</Subtype/TrueType/Type/Font/ToUnicode " + h2 + " 0 R/BaseFont/" + j2(n2.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + n2.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t2.API.PDFObject.convert(n2.metadata.hmtx.widths) + ">>"), i3("endobj"), n2.isAlreadyPutted = true;
          }
        })(e2);
      }]);
      var i2 = function(t3) {
        var e2, r2 = t3.text || "", i3 = t3.x, a2 = t3.y, o2 = t3.options || {}, s2 = t3.mutex || {}, u2 = s2.pdfEscape, c2 = s2.activeFontKey, l4 = s2.fonts, h2 = c2, f2 = "", d3 = 0, p2 = "", g2 = l4[h2].encoding;
        if ("Identity-H" !== l4[h2].encoding) return { text: r2, x: i3, y: a2, options: o2, mutex: s2 };
        for (p2 = r2, h2 = c2, Array.isArray(r2) && (p2 = r2[0]), d3 = 0; d3 < p2.length; d3 += 1) l4[h2].metadata.hasOwnProperty("cmap") && (e2 = l4[h2].metadata.cmap.unicode.codeMap[p2[d3].charCodeAt(0)]), e2 || p2[d3].charCodeAt(0) < 256 && l4[h2].metadata.hasOwnProperty("Unicode") ? f2 += p2[d3] : f2 += "";
        var m3 = "";
        return parseInt(h2.slice(1)) < 14 || "WinAnsiEncoding" === g2 ? m3 = u2(f2, h2).split("").map(function(t4) {
          return t4.charCodeAt(0).toString(16);
        }).join("") : "Identity-H" === g2 && (m3 = n(f2, l4[h2])), s2.isHex = true, { text: m3, x: i3, y: a2, options: o2, mutex: s2 };
      };
      e.events.push(["postProcessText", function(t3) {
        var e2 = t3.text || "", n2 = [], r2 = { text: e2, x: t3.x, y: t3.y, options: t3.options, mutex: t3.mutex };
        if (Array.isArray(e2)) {
          var a2 = 0;
          for (a2 = 0; a2 < e2.length; a2 += 1) Array.isArray(e2[a2]) && 3 === e2[a2].length ? n2.push([i2(Object.assign({}, r2, { text: e2[a2][0] })).text, e2[a2][1], e2[a2][2]]) : n2.push(i2(Object.assign({}, r2, { text: e2[a2] })).text);
          t3.text = n2;
        } else t3.text = i2(Object.assign({}, r2, { text: e2 })).text;
      }]);
    })(E3), /**
     * @license
     * jsPDF virtual FileSystem functionality
     *
     * Licensed under the MIT License.
     * http://opensource.org/licenses/mit-license
     */
    (function(t2) {
      var e = function() {
        return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
      };
      t2.existsFileInVFS = function(t3) {
        return e.call(this), void 0 !== this.internal.vFS[t3];
      }, t2.addFileToVFS = function(t3, n) {
        return e.call(this), this.internal.vFS[t3] = n, this;
      }, t2.getFileFromVFS = function(t3) {
        return e.call(this), void 0 !== this.internal.vFS[t3] ? this.internal.vFS[t3] : null;
      };
    })(E3.API), /**
     * @license
     * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
     * MIT License
     */
    (function(t2) {
      t2.__bidiEngine__ = t2.prototype.__bidiEngine__ = function(t3) {
        var n2, r, i2, a2, o2, s2, u2, c2 = e, l4 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], h2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d3 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p2 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "\xAB", "\xBB", "\xAB", "\u2039", "\u203A", "\u2039", "\u2045", "\u2046", "\u2045", "\u207D", "\u207E", "\u207D", "\u208D", "\u208E", "\u208D", "\u2264", "\u2265", "\u2264", "\u2329", "\u232A", "\u2329", "\uFE59", "\uFE5A", "\uFE59", "\uFE5B", "\uFE5C", "\uFE5B", "\uFE5D", "\uFE5E", "\uFE5D", "\uFE64", "\uFE65", "\uFE64"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m3 = false, v3 = 0;
        this.__bidiEngine__ = {};
        var b3 = function(t4) {
          var e2 = t4.charCodeAt(), n3 = e2 >> 8, r2 = d3[n3];
          return void 0 !== r2 ? c2[256 * r2 + (255 & e2)] : 252 === n3 || 253 === n3 ? "AL" : g2.test(n3) ? "L" : 8 === n3 ? "R" : "N";
        }, y3 = function(t4) {
          for (var e2, n3 = 0; n3 < t4.length; n3++) {
            if ("L" === (e2 = b3(t4.charAt(n3)))) return false;
            if ("R" === e2) return true;
          }
          return false;
        }, w3 = function(t4, e2, o3, s3) {
          var u3, c3, l5, h3, f3 = e2[s3];
          switch (f3) {
            case "L":
            case "R":
            case "LRE":
            case "RLE":
            case "LRO":
            case "RLO":
            case "PDF":
              m3 = false;
              break;
            case "N":
            case "AN":
              break;
            case "EN":
              m3 && (f3 = "AN");
              break;
            case "AL":
              m3 = true, f3 = "R";
              break;
            case "WS":
            case "BN":
              f3 = "N";
              break;
            case "CS":
              s3 < 1 || s3 + 1 >= e2.length || "EN" !== (u3 = o3[s3 - 1]) && "AN" !== u3 || "EN" !== (c3 = e2[s3 + 1]) && "AN" !== c3 ? f3 = "N" : m3 && (c3 = "AN"), f3 = c3 === u3 ? c3 : "N";
              break;
            case "ES":
              f3 = "EN" === (u3 = s3 > 0 ? o3[s3 - 1] : "B") && s3 + 1 < e2.length && "EN" === e2[s3 + 1] ? "EN" : "N";
              break;
            case "ET":
              if (s3 > 0 && "EN" === o3[s3 - 1]) {
                f3 = "EN";
                break;
              }
              if (m3) {
                f3 = "N";
                break;
              }
              for (l5 = s3 + 1, h3 = e2.length; l5 < h3 && "ET" === e2[l5]; ) l5++;
              f3 = l5 < h3 && "EN" === e2[l5] ? "EN" : "N";
              break;
            case "NSM":
              if (i2 && !a2) {
                for (h3 = e2.length, l5 = s3 + 1; l5 < h3 && "NSM" === e2[l5]; ) l5++;
                if (l5 < h3) {
                  var d4 = t4[s3], p3 = d4 >= 1425 && d4 <= 2303 || 64286 === d4;
                  if (u3 = e2[l5], p3 && ("R" === u3 || "AL" === u3)) {
                    f3 = "R";
                    break;
                  }
                }
              }
              f3 = s3 < 1 || "B" === (u3 = e2[s3 - 1]) ? "N" : o3[s3 - 1];
              break;
            case "B":
              m3 = false, n2 = true, f3 = v3;
              break;
            case "S":
              r = true, f3 = "N";
          }
          return f3;
        }, N4 = function(t4, e2, n3) {
          var r2 = t4.split("");
          return n3 && L4(r2, n3, { hiLevel: v3 }), r2.reverse(), e2 && e2.reverse(), r2.join("");
        }, L4 = function(t4, e2, i3) {
          var a3, o3, s3, u3, c3, d4 = -1, p3 = t4.length, g3 = 0, y4 = [], N5 = v3 ? h2 : l4, L5 = [];
          for (m3 = false, n2 = false, r = false, o3 = 0; o3 < p3; o3++) L5[o3] = b3(t4[o3]);
          for (s3 = 0; s3 < p3; s3++) {
            if (c3 = g3, y4[s3] = w3(t4, L5, y4, s3), a3 = 240 & (g3 = N5[c3][f2[y4[s3]]]), g3 &= 15, e2[s3] = u3 = N5[g3][5], a3 > 0) if (16 === a3) {
              for (o3 = d4; o3 < s3; o3++) e2[o3] = 1;
              d4 = -1;
            } else d4 = -1;
            if (N5[g3][6]) -1 === d4 && (d4 = s3);
            else if (d4 > -1) {
              for (o3 = d4; o3 < s3; o3++) e2[o3] = u3;
              d4 = -1;
            }
            "B" === L5[s3] && (e2[s3] = 0), i3.hiLevel |= u3;
          }
          r && (function(t5, e3, n3) {
            for (var r2 = 0; r2 < n3; r2++) if ("S" === t5[r2]) {
              e3[r2] = v3;
              for (var i4 = r2 - 1; i4 >= 0 && "WS" === t5[i4]; i4--) e3[i4] = v3;
            }
          })(L5, e2, p3);
        }, x3 = function(t4, e2, r2, i3, a3) {
          if (!(a3.hiLevel < t4)) {
            if (1 === t4 && 1 === v3 && !n2) return e2.reverse(), void (r2 && r2.reverse());
            for (var o3, s3, u3, c3, l5 = e2.length, h3 = 0; h3 < l5; ) {
              if (i3[h3] >= t4) {
                for (u3 = h3 + 1; u3 < l5 && i3[u3] >= t4; ) u3++;
                for (c3 = h3, s3 = u3 - 1; c3 < s3; c3++, s3--) o3 = e2[c3], e2[c3] = e2[s3], e2[s3] = o3, r2 && (o3 = r2[c3], r2[c3] = r2[s3], r2[s3] = o3);
                h3 = u3;
              }
              h3++;
            }
          }
        }, A3 = function(t4, e2, n3) {
          var r2 = t4.split(""), i3 = { hiLevel: v3 };
          return n3 || (n3 = []), L4(r2, n3, i3), (function(t5, e3, n4) {
            if (0 !== n4.hiLevel && u2) for (var r3, i4 = 0; i4 < t5.length; i4++) 1 === e3[i4] && (r3 = p2.indexOf(t5[i4])) >= 0 && (t5[i4] = p2[r3 + 1]);
          })(r2, n3, i3), x3(2, r2, e2, n3, i3), x3(1, r2, e2, n3, i3), r2.join("");
        };
        return this.__bidiEngine__.doBidiReorder = function(t4, e2, n3) {
          if ((function(t5, e3) {
            if (e3) for (var n4 = 0; n4 < t5.length; n4++) e3[n4] = n4;
            void 0 === a2 && (a2 = y3(t5)), void 0 === s2 && (s2 = y3(t5));
          })(t4, e2), i2 || !o2 || s2) if (i2 && o2 && a2 ^ s2) v3 = a2 ? 1 : 0, t4 = N4(t4, e2, n3);
          else if (!i2 && o2 && s2) v3 = a2 ? 1 : 0, t4 = A3(t4, e2, n3), t4 = N4(t4, e2);
          else if (!i2 || a2 || o2 || s2) {
            if (i2 && !o2 && a2 ^ s2) t4 = N4(t4, e2), a2 ? (v3 = 0, t4 = A3(t4, e2, n3)) : (v3 = 1, t4 = A3(t4, e2, n3), t4 = N4(t4, e2));
            else if (i2 && a2 && !o2 && s2) v3 = 1, t4 = A3(t4, e2, n3), t4 = N4(t4, e2);
            else if (!i2 && !o2 && a2 ^ s2) {
              var r2 = u2;
              a2 ? (v3 = 1, t4 = A3(t4, e2, n3), v3 = 0, u2 = false, t4 = A3(t4, e2, n3), u2 = r2) : (v3 = 0, t4 = A3(t4, e2, n3), t4 = N4(t4, e2), v3 = 1, u2 = false, t4 = A3(t4, e2, n3), u2 = r2, t4 = N4(t4, e2));
            }
          } else v3 = 0, t4 = A3(t4, e2, n3);
          else v3 = a2 ? 1 : 0, t4 = A3(t4, e2, n3);
          return t4;
        }, this.__bidiEngine__.setOptions = function(t4) {
          t4 && (i2 = t4.isInputVisual, o2 = t4.isOutputVisual, a2 = t4.isInputRtl, s2 = t4.isOutputRtl, u2 = t4.isSymmetricSwapping);
        }, this.__bidiEngine__.setOptions(t3), this.__bidiEngine__;
      };
      var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], n = new t2.__bidiEngine__({ isInputVisual: true });
      t2.API.events.push(["postProcessText", function(t3) {
        var e2 = t3.text;
        t3.x, t3.y;
        var r = t3.options || {};
        t3.mutex, r.lang;
        var i2 = [];
        if (r.isInputVisual = "boolean" != typeof r.isInputVisual || r.isInputVisual, n.setOptions(r), "[object Array]" === Object.prototype.toString.call(e2)) {
          var a2 = 0;
          for (i2 = [], a2 = 0; a2 < e2.length; a2 += 1) "[object Array]" === Object.prototype.toString.call(e2[a2]) ? i2.push([n.doBidiReorder(e2[a2][0]), e2[a2][1], e2[a2][2]]) : i2.push([n.doBidiReorder(e2[a2])]);
          t3.text = i2;
        } else t3.text = n.doBidiReorder(e2);
        n.setOptions({ isInputVisual: true });
      }]);
    })(E3), E3.API.TTFFont = (function() {
      function t2(t3) {
        var e;
        if (this.rawData = t3, e = this.contents = new fe2(t3), this.contents.pos = 4, "ttcf" === e.readString(4)) throw new Error("TTCF not supported.");
        e.pos = 0, this.parse(), this.subset = new je2(this), this.registerTTF();
      }
      return t2.open = function(e) {
        return new t2(e);
      }, t2.prototype.parse = function() {
        return this.directory = new de2(this.contents), this.head = new me(this), this.name = new xe2(this), this.cmap = new be2(this), this.toUnicode = {}, this.hhea = new ye2(this), this.maxp = new Ae2(this), this.hmtx = new Se2(this), this.post = new Ne2(this), this.os2 = new we2(this), this.loca = new Ie2(this), this.glyf = new Pe2(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
      }, t2.prototype.registerTTF = function() {
        var t3, e, n, r, i2;
        if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
          var e2, n2, r2, i3;
          for (i3 = [], e2 = 0, n2 = (r2 = this.bbox).length; e2 < n2; e2++) t3 = r2[e2], i3.push(Math.round(t3 * this.scaleFactor));
          return i3;
        }).call(this), this.stemV = 0, this.post.exists ? (n = 255 & (r = this.post.italic_angle), 32768 & (e = r >> 16) && (e = -(1 + (65535 ^ e))), this.italicAngle = +(e + "." + n)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i2 = this.familyClass) || 2 === i2 || 3 === i2 || 4 === i2 || 5 === i2 || 7 === i2, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
      }, t2.prototype.characterToGlyph = function(t3) {
        var e;
        return (null != (e = this.cmap.unicode) ? e.codeMap[t3] : void 0) || 0;
      }, t2.prototype.widthOfGlyph = function(t3) {
        var e;
        return e = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t3).advance * e;
      }, t2.prototype.widthOfString = function(t3, e, n) {
        var r, i2, a2, o2;
        for (a2 = 0, i2 = 0, o2 = (t3 = "" + t3).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2) r = t3.charCodeAt(i2), a2 += this.widthOfGlyph(this.characterToGlyph(r)) + n * (1e3 / e) || 0;
        return a2 * (e / 1e3);
      }, t2.prototype.lineHeight = function(t3, e) {
        var n;
        return null == e && (e = false), n = e ? this.lineGap : 0, (this.ascender + n - this.decender) / 1e3 * t3;
      }, t2;
    })();
    fe2 = (function() {
      function t2(t3) {
        this.data = null != t3 ? t3 : [], this.pos = 0, this.length = this.data.length;
      }
      return t2.prototype.readByte = function() {
        return this.data[this.pos++];
      }, t2.prototype.writeByte = function(t3) {
        return this.data[this.pos++] = t3;
      }, t2.prototype.readUInt32 = function() {
        return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
      }, t2.prototype.writeUInt32 = function(t3) {
        return this.writeByte(t3 >>> 24 & 255), this.writeByte(t3 >> 16 & 255), this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
      }, t2.prototype.readInt32 = function() {
        var t3;
        return (t3 = this.readUInt32()) >= 2147483648 ? t3 - 4294967296 : t3;
      }, t2.prototype.writeInt32 = function(t3) {
        return t3 < 0 && (t3 += 4294967296), this.writeUInt32(t3);
      }, t2.prototype.readUInt16 = function() {
        return this.readByte() << 8 | this.readByte();
      }, t2.prototype.writeUInt16 = function(t3) {
        return this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
      }, t2.prototype.readInt16 = function() {
        var t3;
        return (t3 = this.readUInt16()) >= 32768 ? t3 - 65536 : t3;
      }, t2.prototype.writeInt16 = function(t3) {
        return t3 < 0 && (t3 += 65536), this.writeUInt16(t3);
      }, t2.prototype.readString = function(t3) {
        var e, n;
        for (n = [], e = 0; 0 <= t3 ? e < t3 : e > t3; e = 0 <= t3 ? ++e : --e) n[e] = String.fromCharCode(this.readByte());
        return n.join("");
      }, t2.prototype.writeString = function(t3) {
        var e, n, r;
        for (r = [], e = 0, n = t3.length; 0 <= n ? e < n : e > n; e = 0 <= n ? ++e : --e) r.push(this.writeByte(t3.charCodeAt(e)));
        return r;
      }, t2.prototype.readShort = function() {
        return this.readInt16();
      }, t2.prototype.writeShort = function(t3) {
        return this.writeInt16(t3);
      }, t2.prototype.readLongLong = function() {
        var t3, e, n, r, i2, a2, o2, s2;
        return t3 = this.readByte(), e = this.readByte(), n = this.readByte(), r = this.readByte(), i2 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t3 ? -1 * (72057594037927940 * (255 ^ t3) + 281474976710656 * (255 ^ e) + 1099511627776 * (255 ^ n) + 4294967296 * (255 ^ r) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t3 + 281474976710656 * e + 1099511627776 * n + 4294967296 * r + 16777216 * i2 + 65536 * a2 + 256 * o2 + s2;
      }, t2.prototype.writeLongLong = function(t3) {
        var e, n;
        return e = Math.floor(t3 / 4294967296), n = 4294967295 & t3, this.writeByte(e >> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e), this.writeByte(n >> 24 & 255), this.writeByte(n >> 16 & 255), this.writeByte(n >> 8 & 255), this.writeByte(255 & n);
      }, t2.prototype.readInt = function() {
        return this.readInt32();
      }, t2.prototype.writeInt = function(t3) {
        return this.writeInt32(t3);
      }, t2.prototype.read = function(t3) {
        var e, n;
        for (e = [], n = 0; 0 <= t3 ? n < t3 : n > t3; n = 0 <= t3 ? ++n : --n) e.push(this.readByte());
        return e;
      }, t2.prototype.write = function(t3) {
        var e, n, r, i2;
        for (i2 = [], n = 0, r = t3.length; n < r; n++) e = t3[n], i2.push(this.writeByte(e));
        return i2;
      }, t2;
    })();
    de2 = (function() {
      var t2;
      function e(t3) {
        var e2, n, r;
        for (this.scalarType = t3.readInt(), this.tableCount = t3.readShort(), this.searchRange = t3.readShort(), this.entrySelector = t3.readShort(), this.rangeShift = t3.readShort(), this.tables = {}, n = 0, r = this.tableCount; 0 <= r ? n < r : n > r; n = 0 <= r ? ++n : --n) e2 = { tag: t3.readString(4), checksum: t3.readInt(), offset: t3.readInt(), length: t3.readInt() }, this.tables[e2.tag] = e2;
      }
      return e.prototype.encode = function(e2) {
        var n, r, i2, a2, o2, s2, u2, c2, l4, h2, f2, d3, p2;
        for (p2 in f2 = Object.keys(e2).length, s2 = Math.log(2), l4 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(l4 / s2), c2 = 16 * f2 - l4, (r = new fe2()).writeInt(this.scalarType), r.writeShort(f2), r.writeShort(l4), r.writeShort(a2), r.writeShort(c2), i2 = 16 * f2, u2 = r.pos + i2, o2 = null, d3 = [], e2) for (h2 = e2[p2], r.writeString(p2), r.writeInt(t2(h2)), r.writeInt(u2), r.writeInt(h2.length), d3 = d3.concat(h2), "head" === p2 && (o2 = u2), u2 += h2.length; u2 % 4; ) d3.push(0), u2++;
        return r.write(d3), n = 2981146554 - t2(r.data), r.pos = o2 + 8, r.writeUInt32(n), r.data;
      }, t2 = function(t3) {
        var e2, n, r, i2;
        for (t3 = _e2.call(t3); t3.length % 4; ) t3.push(0);
        for (r = new fe2(t3), n = 0, e2 = 0, i2 = t3.length; e2 < i2; e2 = e2 += 4) n += r.readUInt32();
        return 4294967295 & n;
      }, e;
    })();
    pe2 = {}.hasOwnProperty;
    ge2 = function(t2, e) {
      for (var n in e) pe2.call(e, n) && (t2[n] = e[n]);
      function r() {
        this.constructor = t2;
      }
      return r.prototype = e.prototype, t2.prototype = new r(), t2.__super__ = e.prototype, t2;
    };
    he2 = (function() {
      function t2(t3) {
        var e;
        this.file = t3, e = this.file.directory.tables[this.tag], this.exists = !!e, e && (this.offset = e.offset, this.length = e.length, this.parse(this.file.contents));
      }
      return t2.prototype.parse = function() {
      }, t2.prototype.encode = function() {
      }, t2.prototype.raw = function() {
        return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
      }, t2;
    })();
    me = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ge2(t2, he2), t2.prototype.tag = "head", t2.prototype.parse = function(t3) {
        return t3.pos = this.offset, this.version = t3.readInt(), this.revision = t3.readInt(), this.checkSumAdjustment = t3.readInt(), this.magicNumber = t3.readInt(), this.flags = t3.readShort(), this.unitsPerEm = t3.readShort(), this.created = t3.readLongLong(), this.modified = t3.readLongLong(), this.xMin = t3.readShort(), this.yMin = t3.readShort(), this.xMax = t3.readShort(), this.yMax = t3.readShort(), this.macStyle = t3.readShort(), this.lowestRecPPEM = t3.readShort(), this.fontDirectionHint = t3.readShort(), this.indexToLocFormat = t3.readShort(), this.glyphDataFormat = t3.readShort();
      }, t2.prototype.encode = function(t3) {
        var e;
        return (e = new fe2()).writeInt(this.version), e.writeInt(this.revision), e.writeInt(this.checkSumAdjustment), e.writeInt(this.magicNumber), e.writeShort(this.flags), e.writeShort(this.unitsPerEm), e.writeLongLong(this.created), e.writeLongLong(this.modified), e.writeShort(this.xMin), e.writeShort(this.yMin), e.writeShort(this.xMax), e.writeShort(this.yMax), e.writeShort(this.macStyle), e.writeShort(this.lowestRecPPEM), e.writeShort(this.fontDirectionHint), e.writeShort(t3), e.writeShort(this.glyphDataFormat), e.data;
      }, t2;
    })();
    ve2 = (function() {
      function t2(t3, e) {
        var n, r, i2, a2, o2, s2, u2, c2, l4, h2, f2, d3, p2, g2, m3, v3, b3;
        switch (this.platformID = t3.readUInt16(), this.encodingID = t3.readShort(), this.offset = e + t3.readInt(), l4 = t3.pos, t3.pos = this.offset, this.format = t3.readUInt16(), this.length = t3.readUInt16(), this.language = t3.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
          case 0:
            for (s2 = 0; s2 < 256; ++s2) this.codeMap[s2] = t3.readByte();
            break;
          case 4:
            for (f2 = t3.readUInt16(), h2 = f2 / 2, t3.pos += 6, i2 = (function() {
              var e2, n2;
              for (n2 = [], s2 = e2 = 0; 0 <= h2 ? e2 < h2 : e2 > h2; s2 = 0 <= h2 ? ++e2 : --e2) n2.push(t3.readUInt16());
              return n2;
            })(), t3.pos += 2, p2 = (function() {
              var e2, n2;
              for (n2 = [], s2 = e2 = 0; 0 <= h2 ? e2 < h2 : e2 > h2; s2 = 0 <= h2 ? ++e2 : --e2) n2.push(t3.readUInt16());
              return n2;
            })(), u2 = (function() {
              var e2, n2;
              for (n2 = [], s2 = e2 = 0; 0 <= h2 ? e2 < h2 : e2 > h2; s2 = 0 <= h2 ? ++e2 : --e2) n2.push(t3.readUInt16());
              return n2;
            })(), c2 = (function() {
              var e2, n2;
              for (n2 = [], s2 = e2 = 0; 0 <= h2 ? e2 < h2 : e2 > h2; s2 = 0 <= h2 ? ++e2 : --e2) n2.push(t3.readUInt16());
              return n2;
            })(), r = (this.length - t3.pos + this.offset) / 2, o2 = (function() {
              var e2, n2;
              for (n2 = [], s2 = e2 = 0; 0 <= r ? e2 < r : e2 > r; s2 = 0 <= r ? ++e2 : --e2) n2.push(t3.readUInt16());
              return n2;
            })(), s2 = m3 = 0, b3 = i2.length; m3 < b3; s2 = ++m3) for (g2 = i2[s2], n = v3 = d3 = p2[s2]; d3 <= g2 ? v3 <= g2 : v3 >= g2; n = d3 <= g2 ? ++v3 : --v3) 0 === c2[s2] ? a2 = n + u2[s2] : 0 !== (a2 = o2[c2[s2] / 2 + (n - d3) - (h2 - s2)] || 0) && (a2 += u2[s2]), this.codeMap[n] = 65535 & a2;
        }
        t3.pos = l4;
      }
      return t2.encode = function(t3, e) {
        var n, r, i2, a2, o2, s2, u2, c2, l4, h2, f2, d3, p2, g2, m3, v3, b3, y3, w3, N4, L4, x3, A3, S4, _3, P4, k3, F14, I4, j3, C4, O3, B4, M4, q3, E4, R3, D4, T4, z3, U4, H3, W4, V4, G4, Y3;
        switch (F14 = new fe2(), a2 = Object.keys(t3).sort(function(t4, e2) {
          return t4 - e2;
        }), e) {
          case "macroman":
            for (p2 = 0, g2 = (function() {
              var t4 = [];
              for (d3 = 0; d3 < 256; ++d3) t4.push(0);
              return t4;
            })(), v3 = { 0: 0 }, i2 = {}, I4 = 0, B4 = a2.length; I4 < B4; I4++) null == v3[W4 = t3[r = a2[I4]]] && (v3[W4] = ++p2), i2[r] = { old: t3[r], new: v3[t3[r]] }, g2[r] = v3[t3[r]];
            return F14.writeUInt16(1), F14.writeUInt16(0), F14.writeUInt32(12), F14.writeUInt16(0), F14.writeUInt16(262), F14.writeUInt16(0), F14.write(g2), { charMap: i2, subtable: F14.data, maxGlyphID: p2 + 1 };
          case "unicode":
            for (P4 = [], l4 = [], b3 = 0, v3 = {}, n = {}, m3 = u2 = null, j3 = 0, M4 = a2.length; j3 < M4; j3++) null == v3[w3 = t3[r = a2[j3]]] && (v3[w3] = ++b3), n[r] = { old: w3, new: v3[w3] }, o2 = v3[w3] - r, null != m3 && o2 === u2 || (m3 && l4.push(m3), P4.push(r), u2 = o2), m3 = r;
            for (m3 && l4.push(m3), l4.push(65535), P4.push(65535), S4 = 2 * (A3 = P4.length), x3 = 2 * Math.pow(Math.log(A3) / Math.LN2, 2), h2 = Math.log(x3 / 2) / Math.LN2, L4 = 2 * A3 - x3, s2 = [], N4 = [], f2 = [], d3 = C4 = 0, q3 = P4.length; C4 < q3; d3 = ++C4) {
              if (_3 = P4[d3], c2 = l4[d3], 65535 === _3) {
                s2.push(0), N4.push(0);
                break;
              }
              if (_3 - (k3 = n[_3].new) >= 32768) for (s2.push(0), N4.push(2 * (f2.length + A3 - d3)), r = O3 = _3; _3 <= c2 ? O3 <= c2 : O3 >= c2; r = _3 <= c2 ? ++O3 : --O3) f2.push(n[r].new);
              else s2.push(k3 - _3), N4.push(0);
            }
            for (F14.writeUInt16(3), F14.writeUInt16(1), F14.writeUInt32(12), F14.writeUInt16(4), F14.writeUInt16(16 + 8 * A3 + 2 * f2.length), F14.writeUInt16(0), F14.writeUInt16(S4), F14.writeUInt16(x3), F14.writeUInt16(h2), F14.writeUInt16(L4), U4 = 0, E4 = l4.length; U4 < E4; U4++) r = l4[U4], F14.writeUInt16(r);
            for (F14.writeUInt16(0), H3 = 0, R3 = P4.length; H3 < R3; H3++) r = P4[H3], F14.writeUInt16(r);
            for (V4 = 0, D4 = s2.length; V4 < D4; V4++) o2 = s2[V4], F14.writeUInt16(o2);
            for (G4 = 0, T4 = N4.length; G4 < T4; G4++) y3 = N4[G4], F14.writeUInt16(y3);
            for (Y3 = 0, z3 = f2.length; Y3 < z3; Y3++) p2 = f2[Y3], F14.writeUInt16(p2);
            return { charMap: n, subtable: F14.data, maxGlyphID: b3 + 1 };
        }
      }, t2;
    })();
    be2 = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ge2(t2, he2), t2.prototype.tag = "cmap", t2.prototype.parse = function(t3) {
        var e, n, r;
        for (t3.pos = this.offset, this.version = t3.readUInt16(), r = t3.readUInt16(), this.tables = [], this.unicode = null, n = 0; 0 <= r ? n < r : n > r; n = 0 <= r ? ++n : --n) e = new ve2(t3, this.offset), this.tables.push(e), e.isUnicode && null == this.unicode && (this.unicode = e);
        return true;
      }, t2.encode = function(t3, e) {
        var n, r;
        return null == e && (e = "macroman"), n = ve2.encode(t3, e), (r = new fe2()).writeUInt16(0), r.writeUInt16(1), n.table = r.data.concat(n.subtable), n;
      }, t2;
    })();
    ye2 = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ge2(t2, he2), t2.prototype.tag = "hhea", t2.prototype.parse = function(t3) {
        return t3.pos = this.offset, this.version = t3.readInt(), this.ascender = t3.readShort(), this.decender = t3.readShort(), this.lineGap = t3.readShort(), this.advanceWidthMax = t3.readShort(), this.minLeftSideBearing = t3.readShort(), this.minRightSideBearing = t3.readShort(), this.xMaxExtent = t3.readShort(), this.caretSlopeRise = t3.readShort(), this.caretSlopeRun = t3.readShort(), this.caretOffset = t3.readShort(), t3.pos += 8, this.metricDataFormat = t3.readShort(), this.numberOfMetrics = t3.readUInt16();
      }, t2;
    })();
    we2 = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ge2(t2, he2), t2.prototype.tag = "OS/2", t2.prototype.parse = function(t3) {
        if (t3.pos = this.offset, this.version = t3.readUInt16(), this.averageCharWidth = t3.readShort(), this.weightClass = t3.readUInt16(), this.widthClass = t3.readUInt16(), this.type = t3.readShort(), this.ySubscriptXSize = t3.readShort(), this.ySubscriptYSize = t3.readShort(), this.ySubscriptXOffset = t3.readShort(), this.ySubscriptYOffset = t3.readShort(), this.ySuperscriptXSize = t3.readShort(), this.ySuperscriptYSize = t3.readShort(), this.ySuperscriptXOffset = t3.readShort(), this.ySuperscriptYOffset = t3.readShort(), this.yStrikeoutSize = t3.readShort(), this.yStrikeoutPosition = t3.readShort(), this.familyClass = t3.readShort(), this.panose = (function() {
          var e, n;
          for (n = [], e = 0; e < 10; ++e) n.push(t3.readByte());
          return n;
        })(), this.charRange = (function() {
          var e, n;
          for (n = [], e = 0; e < 4; ++e) n.push(t3.readInt());
          return n;
        })(), this.vendorID = t3.readString(4), this.selection = t3.readShort(), this.firstCharIndex = t3.readShort(), this.lastCharIndex = t3.readShort(), this.version > 0 && (this.ascent = t3.readShort(), this.descent = t3.readShort(), this.lineGap = t3.readShort(), this.winAscent = t3.readShort(), this.winDescent = t3.readShort(), this.codePageRange = (function() {
          var e, n;
          for (n = [], e = 0; e < 2; e = ++e) n.push(t3.readInt());
          return n;
        })(), this.version > 1)) return this.xHeight = t3.readShort(), this.capHeight = t3.readShort(), this.defaultChar = t3.readShort(), this.breakChar = t3.readShort(), this.maxContext = t3.readShort();
      }, t2;
    })();
    Ne2 = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ge2(t2, he2), t2.prototype.tag = "post", t2.prototype.parse = function(t3) {
        var e, n, r;
        switch (t3.pos = this.offset, this.format = t3.readInt(), this.italicAngle = t3.readInt(), this.underlinePosition = t3.readShort(), this.underlineThickness = t3.readShort(), this.isFixedPitch = t3.readInt(), this.minMemType42 = t3.readInt(), this.maxMemType42 = t3.readInt(), this.minMemType1 = t3.readInt(), this.maxMemType1 = t3.readInt(), this.format) {
          case 65536:
          case 196608:
            break;
          case 131072:
            var i2;
            for (n = t3.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= n ? i2 < n : i2 > n; i2 = 0 <= n ? ++i2 : --i2) this.glyphNameIndex.push(t3.readUInt16());
            for (this.names = [], r = []; t3.pos < this.offset + this.length; ) e = t3.readByte(), r.push(this.names.push(t3.readString(e)));
            return r;
          case 151552:
            return n = t3.readUInt16(), this.offsets = t3.read(n);
          case 262144:
            return this.map = (function() {
              var e2, n2, r2;
              for (r2 = [], i2 = e2 = 0, n2 = this.file.maxp.numGlyphs; 0 <= n2 ? e2 < n2 : e2 > n2; i2 = 0 <= n2 ? ++e2 : --e2) r2.push(t3.readUInt32());
              return r2;
            }).call(this);
        }
      }, t2;
    })();
    Le2 = function(t2, e) {
      this.raw = t2, this.length = t2.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
    };
    xe2 = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ge2(t2, he2), t2.prototype.tag = "name", t2.prototype.parse = function(t3) {
        var e, n, r, i2, a2, o2, s2, u2, c2, l4, h2;
        for (t3.pos = this.offset, t3.readShort(), e = t3.readShort(), o2 = t3.readShort(), n = [], i2 = 0; 0 <= e ? i2 < e : i2 > e; i2 = 0 <= e ? ++i2 : --i2) n.push({ platformID: t3.readShort(), encodingID: t3.readShort(), languageID: t3.readShort(), nameID: t3.readShort(), length: t3.readShort(), offset: this.offset + o2 + t3.readShort() });
        for (s2 = {}, i2 = c2 = 0, l4 = n.length; c2 < l4; i2 = ++c2) r = n[i2], t3.pos = r.offset, u2 = t3.readString(r.length), a2 = new Le2(u2, r), null == s2[h2 = r.nameID] && (s2[h2] = []), s2[r.nameID].push(a2);
        this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
        try {
          this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
        } catch (f2) {
          this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
        }
        return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
      }, t2;
    })();
    Ae2 = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ge2(t2, he2), t2.prototype.tag = "maxp", t2.prototype.parse = function(t3) {
        return t3.pos = this.offset, this.version = t3.readInt(), this.numGlyphs = t3.readUInt16(), this.maxPoints = t3.readUInt16(), this.maxContours = t3.readUInt16(), this.maxCompositePoints = t3.readUInt16(), this.maxComponentContours = t3.readUInt16(), this.maxZones = t3.readUInt16(), this.maxTwilightPoints = t3.readUInt16(), this.maxStorage = t3.readUInt16(), this.maxFunctionDefs = t3.readUInt16(), this.maxInstructionDefs = t3.readUInt16(), this.maxStackElements = t3.readUInt16(), this.maxSizeOfInstructions = t3.readUInt16(), this.maxComponentElements = t3.readUInt16(), this.maxComponentDepth = t3.readUInt16();
      }, t2;
    })();
    Se2 = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ge2(t2, he2), t2.prototype.tag = "hmtx", t2.prototype.parse = function(t3) {
        var e, n, r, i2, a2, o2, s2;
        for (t3.pos = this.offset, this.metrics = [], e = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e < o2 : e > o2; e = 0 <= o2 ? ++e : --e) this.metrics.push({ advance: t3.readUInt16(), lsb: t3.readInt16() });
        for (r = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = (function() {
          var n2, i3;
          for (i3 = [], e = n2 = 0; 0 <= r ? n2 < r : n2 > r; e = 0 <= r ? ++n2 : --n2) i3.push(t3.readInt16());
          return i3;
        })(), this.widths = (function() {
          var t4, e2, n2, r2;
          for (r2 = [], t4 = 0, e2 = (n2 = this.metrics).length; t4 < e2; t4++) i2 = n2[t4], r2.push(i2.advance);
          return r2;
        }).call(this), n = this.widths[this.widths.length - 1], s2 = [], e = a2 = 0; 0 <= r ? a2 < r : a2 > r; e = 0 <= r ? ++a2 : --a2) s2.push(this.widths.push(n));
        return s2;
      }, t2.prototype.forGlyph = function(t3) {
        return t3 in this.metrics ? this.metrics[t3] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t3 - this.metrics.length] };
      }, t2;
    })();
    _e2 = [].slice;
    Pe2 = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ge2(t2, he2), t2.prototype.tag = "glyf", t2.prototype.parse = function() {
        return this.cache = {};
      }, t2.prototype.glyphFor = function(t3) {
        var e, n, r, i2, a2, o2, s2, u2, c2, l4;
        return t3 in this.cache ? this.cache[t3] : (i2 = this.file.loca, e = this.file.contents, n = i2.indexOf(t3), 0 === (r = i2.lengthOf(t3)) ? this.cache[t3] = null : (e.pos = this.offset + n, a2 = (o2 = new fe2(e.read(r))).readShort(), u2 = o2.readShort(), l4 = o2.readShort(), s2 = o2.readShort(), c2 = o2.readShort(), this.cache[t3] = -1 === a2 ? new Fe2(o2, u2, l4, s2, c2) : new ke2(o2, a2, u2, l4, s2, c2), this.cache[t3]));
      }, t2.prototype.encode = function(t3, e, n) {
        var r, i2, a2, o2, s2;
        for (a2 = [], i2 = [], o2 = 0, s2 = e.length; o2 < s2; o2++) r = t3[e[o2]], i2.push(a2.length), r && (a2 = a2.concat(r.encode(n)));
        return i2.push(a2.length), { table: a2, offsets: i2 };
      }, t2;
    })();
    ke2 = (function() {
      function t2(t3, e, n, r, i2, a2) {
        this.raw = t3, this.numberOfContours = e, this.xMin = n, this.yMin = r, this.xMax = i2, this.yMax = a2, this.compound = false;
      }
      return t2.prototype.encode = function() {
        return this.raw.data;
      }, t2;
    })();
    Fe2 = (function() {
      function t2(t3, e, n, r, i2) {
        var a2, o2;
        for (this.raw = t3, this.xMin = e, this.yMin = n, this.xMax = r, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; ) a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
      }
      return t2.prototype.encode = function() {
        var t3, e, n;
        for (e = new fe2(_e2.call(this.raw.data)), t3 = 0, n = this.glyphIDs.length; t3 < n; ++t3) e.pos = this.glyphOffsets[t3];
        return e.data;
      }, t2;
    })();
    Ie2 = (function() {
      function t2() {
        return t2.__super__.constructor.apply(this, arguments);
      }
      return ge2(t2, he2), t2.prototype.tag = "loca", t2.prototype.parse = function(t3) {
        var e, n;
        return t3.pos = this.offset, e = this.file.head.indexToLocFormat, this.offsets = 0 === e ? (function() {
          var e2, r;
          for (r = [], n = 0, e2 = this.length; n < e2; n += 2) r.push(2 * t3.readUInt16());
          return r;
        }).call(this) : (function() {
          var e2, r;
          for (r = [], n = 0, e2 = this.length; n < e2; n += 4) r.push(t3.readUInt32());
          return r;
        }).call(this);
      }, t2.prototype.indexOf = function(t3) {
        return this.offsets[t3];
      }, t2.prototype.lengthOf = function(t3) {
        return this.offsets[t3 + 1] - this.offsets[t3];
      }, t2.prototype.encode = function(t3, e) {
        for (var n = new Uint32Array(this.offsets.length), r = 0, i2 = 0, a2 = 0; a2 < n.length; ++a2) if (n[a2] = r, i2 < e.length && e[i2] == a2) {
          ++i2, n[a2] = r;
          var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
          s2 > 0 && (r += s2);
        }
        for (var u2 = new Array(4 * n.length), c2 = 0; c2 < n.length; ++c2) u2[4 * c2 + 3] = 255 & n[c2], u2[4 * c2 + 2] = (65280 & n[c2]) >> 8, u2[4 * c2 + 1] = (16711680 & n[c2]) >> 16, u2[4 * c2] = (4278190080 & n[c2]) >> 24;
        return u2;
      }, t2;
    })();
    je2 = (function() {
      function t2(t3) {
        this.font = t3, this.subset = {}, this.unicodes = {}, this.next = 33;
      }
      return t2.prototype.generateCmap = function() {
        var t3, e, n, r, i2;
        for (e in r = this.font.cmap.tables[0].codeMap, t3 = {}, i2 = this.subset) n = i2[e], t3[e] = r[n];
        return t3;
      }, t2.prototype.glyphsFor = function(t3) {
        var e, n, r, i2, a2, o2, s2;
        for (r = {}, a2 = 0, o2 = t3.length; a2 < o2; a2++) r[i2 = t3[a2]] = this.font.glyf.glyphFor(i2);
        for (i2 in e = [], r) (null != (n = r[i2]) ? n.compound : void 0) && e.push.apply(e, n.glyphIDs);
        if (e.length > 0) for (i2 in s2 = this.glyphsFor(e)) n = s2[i2], r[i2] = n;
        return r;
      }, t2.prototype.encode = function(t3, e) {
        var n, r, i2, a2, o2, s2, u2, c2, l4, h2, f2, d3, p2, g2, m3;
        for (r in n = be2.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t3), f2 = { 0: 0 }, m3 = n.charMap) f2[(s2 = m3[r]).old] = s2.new;
        for (d3 in h2 = n.maxGlyphID, a2) d3 in f2 || (f2[d3] = h2++);
        return c2 = (function(t4) {
          var e2, n2;
          for (e2 in n2 = {}, t4) n2[t4[e2]] = e2;
          return n2;
        })(f2), l4 = Object.keys(c2).sort(function(t4, e2) {
          return t4 - e2;
        }), p2 = (function() {
          var t4, e2, n2;
          for (n2 = [], t4 = 0, e2 = l4.length; t4 < e2; t4++) o2 = l4[t4], n2.push(c2[o2]);
          return n2;
        })(), i2 = this.font.glyf.encode(a2, p2, f2), u2 = this.font.loca.encode(i2.offsets, p2), g2 = { cmap: this.font.cmap.raw(), glyf: i2.table, loca: u2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
      }, t2;
    })();
    E3.API.PDFObject = (function() {
      var t2;
      function e() {
      }
      return t2 = function(t3, e2) {
        return (Array(e2 + 1).join("0") + t3).slice(-e2);
      }, e.convert = function(n) {
        var r, i2, a2, o2;
        if (Array.isArray(n)) return "[" + (function() {
          var t3, i3, a3;
          for (a3 = [], t3 = 0, i3 = n.length; t3 < i3; t3++) r = n[t3], a3.push(e.convert(r));
          return a3;
        })().join(" ") + "]";
        if ("string" == typeof n) return "/" + n;
        if (null != n ? n.isString : void 0) return "(" + n + ")";
        if (n instanceof Date) return "(D:" + t2(n.getUTCFullYear(), 4) + t2(n.getUTCMonth(), 2) + t2(n.getUTCDate(), 2) + t2(n.getUTCHours(), 2) + t2(n.getUTCMinutes(), 2) + t2(n.getUTCSeconds(), 2) + "Z)";
        if ("[object Object]" === {}.toString.call(n)) {
          for (i2 in a2 = ["<<"], n) o2 = n[i2], a2.push("/" + i2 + " " + e.convert(o2));
          return a2.push(">>"), a2.join("\n");
        }
        return "" + n;
      }, e;
    })();
  }
});

// src/app/sidebar/sidebar.ts
var import_html2canvas, SidebarComponent;
var init_sidebar3 = __esm({
  "src/app/sidebar/sidebar.ts"() {
    "use strict";
    init_tslib_es6();
    init_sidebar();
    init_sidebar2();
    init_core();
    init_marked_esm();
    init_common();
    init_sidenav();
    init_button();
    init_icon();
    init_sharedservice();
    init_graph();
    import_html2canvas = __toESM(require_html2canvas());
    init_jspdf_es_min();
    init_swimlane_ngx_graph();
    SidebarComponent = class SidebarComponent2 {
      sharedservice;
      promptMessage = "";
      testPlan = "";
      graphData = [];
      panelData = null;
      selectedGraph;
      testPlanHtml = "";
      constructor(sharedservice) {
        this.sharedservice = sharedservice;
      }
      ngOnInit() {
        this.sharedservice.panelData$.subscribe((data) => {
          if (data) {
            this.testPlan = data.testPlan;
            this.graphData = data.graphData;
            if (this.graphData && this.graphData.length > 0) {
              this.selectedGraph = this.graphData[0];
            }
            const parsed = d.parse(this.testPlan || "");
            if (parsed instanceof Promise) {
              parsed.then((html) => {
                this.testPlanHtml = html;
              });
            } else {
              this.testPlanHtml = parsed;
            }
            console.log("Received panel data:", data);
            console.log("GRAPH:", this.graphData);
            console.log("GRAPH:", this.selectedGraph);
          }
        });
      }
      exportPDF() {
        return __async(this, null, function* () {
          const element = document.getElementById("exportSection");
          if (!element) {
            console.error("PDF element not found");
            return;
          }
          yield new Promise((res) => setTimeout(res, 200));
          const canvas = yield (0, import_html2canvas.default)(element, {
            scale: 2,
            useCORS: true,
            logging: false
          });
          const imgData = canvas.toDataURL("image/png");
          const pdf = new E3("p", "mm", "a4");
          const imgWidth = 210;
          const pageHeight = 295;
          const imgHeight = canvas.height * imgWidth / canvas.width;
          let heightLeft = imgHeight;
          let position = 0;
          pdf.addImage(imgData, "PNG", 0, position, imgWidth, imgHeight);
          heightLeft -= pageHeight;
          while (heightLeft > 0) {
            position = heightLeft - imgHeight;
            pdf.addPage();
            pdf.addImage(imgData, "PNG", 0, position, imgWidth, imgHeight);
            heightLeft -= pageHeight;
          }
          pdf.save("impact-analysis-document.pdf");
        });
      }
      selectGraph(index) {
        this.selectedGraph = this.graphData[index];
      }
      static ctorParameters = () => [
        { type: Sharedservice }
      ];
    };
    SidebarComponent = __decorate([
      Component({
        selector: "app-sidebar",
        standalone: true,
        template: sidebar_default,
        imports: [CommonModule, MatSidenavModule, MatButtonModule, MatIconModule, Graph, NgxGraphModule],
        styles: [sidebar_default2]
      })
    ], SidebarComponent);
  }
});

export {
  Title,
  init_platform_browser,
  MatIconModule,
  init_icon,
  MatSidenavModule,
  init_sidenav,
  SidebarComponent,
  init_sidebar3 as init_sidebar
};
/*! Bundled license information:

@angular/platform-browser/fesm2022/platform-browser.mjs:
  (**
   * @license Angular v20.3.12
   * (c) 2010-2025 Google LLC. https://angular.dev/
   * License: MIT
   *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)

jspdf/dist/jspdf.es.min.js:
  (** @license
   *
   * jsPDF - PDF Document creation from JavaScript
   * Version 3.0.3 Built on 2025-09-18T08:03:54.261Z
   *                      CommitID 00000000
   *
   * Copyright (c) 2010-2025 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
   *               2015-2025 yWorks GmbH, http://www.yworks.com
   *               2015-2025 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
   *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
   *               2010 Aaron Spike, https://github.com/acspike
   *               2012 Willow Systems Corporation, https://github.com/willowsystems
   *               2012 Pablo Hess, https://github.com/pablohess
   *               2012 Florian Jenett, https://github.com/fjenett
   *               2013 Warren Weckesser, https://github.com/warrenweckesser
   *               2013 Youssef Beddad, https://github.com/lifof
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2013 Stefan Slonevskiy, https://github.com/stefslon
   *               2013 Jeremy Morel, https://github.com/jmorel
   *               2013 Christoph Hartmann, https://github.com/chris-rock
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Makes, https://github.com/dollaruw
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Steven Spungin, https://github.com/Flamenco
   *               2014 Kenneth Glassey, https://github.com/Gavvers
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * Contributor(s):
   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
   *    kim3er, mfo, alnorth, Flamenco
   *)
  (**
   * A class to parse color values
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
   * @license Use it if you like it
   *)
  (**
   * @license
   * Joseph Myers does not specify a particular license for his work.
   *
   * Author: Joseph Myers
   * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
   *
   * Modified by: Owen Leong
   *)
  (**
   * @license
   * FPDF is released under a permissive license: there is no usage restriction.
   * You may embed it freely in your application (commercial or not), with or
   * without modifications.
   *
   * Reference: http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   * Author: Owen Leong (@owenl131)
   * Date: 15 Oct 2020
   * References:
   * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
   * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
   * http://www.fpdf.org/en/script/script37.php
   *)
  (**
   * @license
    Copyright (c) 2008, Adobe Systems Incorporated
    All rights reserved.
  
    Redistribution and use in source and binary forms, with or without 
    modification, are permitted provided that the following conditions are
    met:
  
    * Redistributions of source code must retain the above copyright notice, 
      this list of conditions and the following disclaimer.
    
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the 
      documentation and/or other materials provided with the distribution.
    
    * Neither the name of Adobe Systems Incorporated nor the names of its 
      contributors may be used to endorse or promote products derived from 
      this software without specific prior written permission.
  
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)
  (**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   *)
*/
//# sourceMappingURL=chunk-NWRTRRGA.js.map
